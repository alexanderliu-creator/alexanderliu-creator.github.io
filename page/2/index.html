<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-MIT分布式系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/24/MIT%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2021-09-24T11:45:20.000Z" itemprop="datePublished">2021-09-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/24/MIT%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/">MIT分布式系统</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="这是MIT分布式系统相关课程"><a href="#这是MIT分布式系统相关课程" class="headerlink" title="这是MIT分布式系统相关课程"></a>这是MIT分布式系统相关课程</h1><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><ul>
<li>Performance：计算机的表现：<ul>
<li>Scalability</li>
<li>Fauct Tolerance</li>
</ul>
</li>
<li>Scalability：可拓展性<ul>
<li>Scalability —&gt; 2x computers —&gt; 2x throughput ， 如果我们拥有两倍以上的计算机，我们能够拥有对应倍数的性能，这个就叫做可拓展性。</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210924201127.png" alt="image-20210924201118810"></p>
<p>Maybe like this , we have many web servers . With the growth of the web servers. The web servers are not longer the bottleneck , as we can see , we only have one db in the whole picture. The db becomes the bottleneck now ! This way is not <strong>scalable</strong>. </p>
<ul>
<li>Fault Tolerance：故障容忍性<ul>
<li>Availability：可用性，当所有机器没有全挂的时候，应该保证用户的可用性。</li>
<li>Recoverability：可恢复性，例如故障了，如果我人为修复了它，它是否能够继续可用？晚上的网络故障我早上修复好，早上还可以继续使用，没有任何问题。这就体现了高可恢复性。<ul>
<li>NV Storage</li>
<li>Replication</li>
</ul>
</li>
</ul>
</li>
<li>Consistency：<ul>
<li>Put operation：<code>put(key,value)</code></li>
<li>Get operation：<code>get(key) -&gt; value</code></li>
</ul>
</li>
</ul>
<p>The distribution system has many versions ,  we should try to keep the consistency of different computers.</p>
<p>Strong consistency — Weak consistency</p>
<p>Weak dosen’t guarantee you can see the newest data.</p>
<p>Readers and writers should communicate many times to implement strong consistency to let every duplication to get the most recent value they find.</p>
<p>Expensive -&gt; to avoid communication -&gt; Weak system , allow reading old values ,</p>
<p>People like to put different replicates as far apart as possible , like in different cities to construct different data centers. But !!! It takes time to communciate to different replicates , so it’s <strong>expensive</strong> for us to build the strong consistency system.</p>
<h2 id="MapReduce"><a href="#MapReduce" class="headerlink" title="MapReduce"></a>MapReduce</h2><ul>
<li>Google designed and built and used the MapReduce</li>
</ul>
<p>Consuming inputs and split</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210925114653.png" alt="image-20210925114653238"></p>
<p>Entire job -&gt; Map tasks</p>
<ul>
<li>A esay implement：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210925144755.png" alt="image-20210925144755568"></p>
<ul>
<li>GFS：<ul>
<li>Google File System</li>
<li>It’s a cluster file system</li>
<li>Input are stored in the GFS , MapReduce automatically split the inputs and let different computers to execute the tasks. The Reduce will collect the different answers from corresponding servers.</li>
<li>Communciation through network is also a big challenge for the whole system</li>
<li>Every computer run</li>
</ul>
</li>
</ul>
<h1 id="RPC-and-Threads"><a href="#RPC-and-Threads" class="headerlink" title="RPC  and Threads"></a>RPC  and Threads</h1><h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><ul>
<li>GC and safety multi threads and safety allocation of memories make it easy to learn and do our experiment. It is an easy language.</li>
</ul>
<h2 id="Thread"><a href="#Thread" class="headerlink" title="Thread"></a>Thread</h2><ul>
<li><p>Threads are main tools to manage concurrency. Threads are equal to <code>go routines</code> in go.</p>
</li>
<li><p>Reasons for tho importance of multi thread in distributing system:</p>
<ol>
<li><p>I&#x2F;O concurrency</p>
</li>
<li><p>Parallelism</p>
</li>
<li><p>Convenience:</p>
<ul>
<li>Just like if you want to do a periodical job, you can let a thread to do this job periodically.</li>
<li>The job is like checking if the workers(In the C&#x2F;S model) is still alive . If some parts die , we will lift up another worker in another machine</li>
</ul>
</li>
</ol>
</li>
<li><p>Actually go doesn’t know anything about the relationship between lock and variables. So you should schedule where the lock is used to protect our codes.</p>
</li>
<li><p>Coordination of multi threads：</p>
<ul>
<li>Channels</li>
<li>Sync.Cond</li>
<li>WaitGroup</li>
</ul>
</li>
<li><p>Dead Lock</p>
</li>
</ul>
<h1 id="GFS"><a href="#GFS" class="headerlink" title="GFS"></a>GFS</h1><ul>
<li><p>The Google File System</p>
</li>
<li><p>Why  is it hard?</p>
<ul>
<li>Performance -&gt; Sharding</li>
<li>Faults -&gt; Tolerance</li>
<li>Tolerance -&gt; Replication</li>
<li>Replication -&gt; Inconsistency</li>
<li>Consistency -&gt; Low Performance</li>
</ul>
</li>
<li><p>Bad Replication Design</p>
<ul>
<li>two servers</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210927193743.png" alt="image-20210927193742870"></p>
<p>we can’t gurantee the order of the proccess execute.（which is also called anomalous behaviors）</p>
<ul>
<li>GFS：<ul>
<li>How to fix the model below?</li>
<li>Demands:<ul>
<li>Big</li>
<li>Fast</li>
<li>Sharding</li>
<li>Automatic recovery</li>
</ul>
</li>
<li>Features:<ul>
<li>Internal use</li>
<li>Big sequential access</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210927195451.png" alt="image-20210927195450882"></p>
<p>Write has to go to the disk , Read can from the memory to make the data safe . Log and checkpoints should all be kept in disk.</p>
<p>Master knows where to find the data , so it can tell to go to which chunk !!!</p>
<h2 id="Read-operation"><a href="#Read-operation" class="headerlink" title="Read operation:"></a>Read operation:</h2><ol>
<li>name , offset -&gt; master (client only thinking about the filename and the offset , the master is responsible to find the data maybe from several seperate servers and return the data to the client)</li>
<li>master -&gt; chunk handler and list of server (maybe depend on distance , The master will get a list of servers which hold the chunk of the file , and select one , maybe by distance , and let client communicate with that server). Cache the result. (Find which server that hold the chunk of the file)</li>
<li>Client -&gt; One of the chunk servers</li>
<li>Servers -&gt; Return the data to client</li>
</ol>
<ul>
<li>So one question i consider is that you’re actually reading <strong>replicas</strong> of data , maybe there are several servers hold the chunk , and you only communicate with one of them which maybe results in inconsistency of data.</li>
</ul>
<h2 id="Write-operation"><a href="#Write-operation" class="headerlink" title="Write operation:"></a>Write operation:</h2><ul>
<li>When the master reboots , it should communicate to each server to find which server holds which chunk.</li>
<li>One case is not primary:<ul>
<li>Find up to date replicas</li>
<li>Pick up primary , secondary servers</li>
<li>Increments version numbers</li>
<li>Tells primary , secondary versions , and give them leases</li>
<li>Master writes version to disk</li>
<li>Primary picks offset all replicas and told to write at off</li>
<li>If all secondary server say “yes” , primary say “yes” to client. Else say “no” to client. (Maybe some of the secondary servers successfully do the job , primary may still reply “no” to client , that is how it works!!!)</li>
</ul>
</li>
<li>all the secondary servers are the same versions . Only when the master signs the new primary , the version changes（就像我们学习的读服务器和写服务器，写服务器会将内容写到每一个读服务器，以保证数据的一致性一样的嗷！！！，主从复制orz）</li>
<li>当primary服务器群数据不一样的时候，就有可能根据谁的版本最新，进行服务器之间的通信，来更新所有的服务器到最新的版本。（但实际上这种行为不一定会发生，所有secondary的版本都是一样的嗷！！！当出现上述的情况的时候，服务器会尝试先自己进行修复嗷！！！）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210927205747.png" alt="image-20210927205746538"></p>
<p>Actually we can ensure high concurrency by like waiting for the right operation for every server or redo the task , but !!! That will lower the availability.</p>
<ul>
<li><p>When a primary died , the master will desiganate a new one. But the master must wait for the expiration of the lease.</p>
</li>
<li><p>Always three replicas a for chunk for default , always one primary and two backups.</p>
</li>
<li><p><code>&quot;SPLIT BRAIN&quot;</code> is the net partition phenonmenon. Hardest problem to deal with. </p>
</li>
<li><p>If a primary failed to communicate with the master , the master will sit down to wait for the expiration of the lease and it will maybe designate another “brain” or primary to complete the mission.</p>
</li>
<li><p>How to update GFS?</p>
<ul>
<li>Need a primary to detect duplicated requests</li>
<li>When the disks are wrong , and maybe the secondaries are down , what should we do to take away the broken ones and ensure the system is running</li>
<li>When primary asks secondaries to append something , secondaries should not expose their data to readers until the primary ensure the all secondaries really need to execute the append.</li>
<li>If primary crahes ? New primary may differ from the operations of the old secondaries. New primary  should be resynchronizing with the secondaries to make sure they have the same operation history.</li>
</ul>
</li>
<li><p>The most serious limitation is that we have only one single master.</p>
</li>
</ul>
<h1 id="Primary-Backup-Replication"><a href="#Primary-Backup-Replication" class="headerlink" title="Primary-Backup Replication"></a>Primary-Backup Replication</h1><ul>
<li><p>Faliures：</p>
<ul>
<li>Fail-stop faults</li>
<li>Bugs</li>
</ul>
</li>
<li><p>State Transfer</p>
<ul>
<li>Copy the contents of RAM of the primary , and send them to the backup. Maybe you can send the memory changed from last time more efficiently . This is actually what mysql does.</li>
<li>Transfer memory</li>
</ul>
</li>
<li><p>Replicated state Machine</p>
<ul>
<li>don’t send the state among the replicas , just send the external events from the outside input.</li>
<li>Transfer operations from clients or external events</li>
</ul>
</li>
<li><p>people tend to choose replicated state , because operations are always smaller.</p>
</li>
<li><p>Maybe the secondary will take the job if the master is dead , because the secondary may has the latest state of the primary computer.</p>
</li>
<li><p>What do we mean about state</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/24/MIT%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/" data-id="cl6gepmfl001he0jq8qdr2ycs" data-title="MIT分布式系统" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%A7%E4%B8%89%E8%87%AA%E5%AD%A6/" rel="tag">大三自学</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-软件系统架构" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/22/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/" class="article-date">
  <time class="dt-published" datetime="2021-09-22T02:24:04.000Z" itemprop="datePublished">2021-09-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/22/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/">软件系统架构</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="软件系统架构课程学习"><a href="#软件系统架构课程学习" class="headerlink" title="软件系统架构课程学习"></a>软件系统架构课程学习</h1><h1 id="第一章：系统分析与设计概述"><a href="#第一章：系统分析与设计概述" class="headerlink" title="第一章：系统分析与设计概述"></a>第一章：系统分析与设计概述</h1><h2 id="1-1-什么是信息系统"><a href="#1-1-什么是信息系统" class="headerlink" title="1.1 什么是信息系统"></a>1.1 什么是信息系统</h2><ul>
<li><p>信息系统：对于业务进行采集，转换，加工，计算，分析，传输，维护等<strong>信息处理</strong>，并能就某个方面问题给用户提供<strong>信息服务</strong>的计算机应用系统。</p>
</li>
<li><p>信息系统组成：</p>
<ul>
<li>信息化基础设施</li>
<li>应用软件</li>
<li>数据库系统</li>
<li>业务数据</li>
<li>客户端</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210922103053.png" alt="image-20210922103053122"></p>
<ul>
<li><p>信息系统类型：</p>
<ol>
<li>业务处理系统：TPS（Transaction Process System），运用IT技术对于机构 <strong>业务活动</strong> 进行信息处理嗷！！！</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210922103304.png" alt="image-20210922103304183"></p>
<ol start="2">
<li>信息管理系统：MIS（Manage Information System），以机构 <strong>信息管理</strong> 作为主导。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210922103436.png" alt="image-20210922103436536"></p>
<ol start="3">
<li>支持决策系统：DSS（Decision Support System），为解决特定策略提供 <strong>决策支持</strong> 的信息系统。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210922103640.png" alt="image-20210922103640432"></p>
<ol start="4">
<li>专家系统：ES（Expert System），获取，存储与利用 <strong>专家智慧解决某类问题</strong> 的信息系统</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210922103749.png" alt="image-20210922103748812"></p>
<ol start="5">
<li>办公自动化系统：OA（Office Automation），实现办公业务流程自动化。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210922103841.png" alt="image-20210922103841198"></p>
<ol start="6">
<li>知识工作支持系统：KWS（Knowledge Work System），<strong>为知识工作者提供设计创造，技术创新等服务</strong>的信息系统</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210922104035.png" alt="image-20210922104035116"></p>
</li>
<li><p>信息系统利益相关者：</p>
<ul>
<li>客户：系统拥有者</li>
<li>用户：系统使用者或服务对象</li>
<li>开发团队：系统构建者</li>
</ul>
</li>
<li><p>信息系统用户：</p>
<ul>
<li>内部用户：<ul>
<li>业务人员</li>
<li>经理等</li>
</ul>
</li>
<li>外部用户：<ul>
<li>客户</li>
<li>供应商</li>
<li>合作伙伴</li>
</ul>
</li>
</ul>
</li>
<li><p>信息系统开发人员：</p>
<ul>
<li>开发人员：<ul>
<li>系统分析人员</li>
<li>系统设计人员</li>
<li>系统构造人员</li>
<li>系统测试人员</li>
<li>质量保证人员</li>
</ul>
</li>
<li>管理人员：<ul>
<li>项目经理</li>
<li>客户经理</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol>
<li><p>项目经理：</p>
<ul>
<li>项目计划</li>
<li>项目组织</li>
<li>项目领导</li>
<li>项目控制</li>
</ul>
</li>
<li><p>系统分析师：</p>
<ul>
<li>对于机构业务进行调查和分析，利用信息系统分析技术解决问题。</li>
<li>负责信息系统的<strong>需求调研，需求分析，需求管理，</strong>完成《系统需求规格说明书》</li>
<li>对于信息系统进行<strong>业务需求建模，系统需求建模</strong>，讲建模成果转化到<strong>《系统需求规格说明书》</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20211018213055.png" alt="image-20211018213055250"></p>
</li>
<li><p>系统架构师：</p>
<ul>
<li>系统项目的总体设计师</li>
<li>负责对于整个系统架构，关键构建，接口的设计，完成<strong>《系统概要设计说明书》</strong></li>
</ul>
</li>
<li><p>软件工程师：</p>
<ul>
<li><p>编写<strong>《系统详细设计说明书》</strong></p>
</li>
<li><p><strong>负责对于系统功能模块的软件设计和实施</strong>。</p>
</li>
</ul>
</li>
<li><p>界面工程师：</p>
<ul>
<li>功能界面设计，色彩调配等</li>
</ul>
</li>
<li><p>数据库管理员：</p>
<ul>
<li><strong>数据库建模</strong></li>
<li>根据数据库建模结果，创建数据库的<strong>LDM和PDM</strong></li>
</ul>
</li>
<li><p>测试经理：</p>
<ul>
<li>按照项目经理制定的系统质量计划要求，编写测试计划和测试方案。</li>
<li>协调接口，完成项目系统测试。</li>
</ul>
</li>
<li><p>测试工程师</p>
<ul>
<li>编写测试用例，进行测试工作</li>
</ul>
</li>
<li><p>实施经理</p>
<ul>
<li>协调资源，完成相关工作，监控检查工作进展，编写验收测试报告等。</li>
</ul>
</li>
<li><p>产品经理</p>
<ul>
<li>负责推广的软件产品进行策划和管理</li>
<li>对于所负责的产品进行市场调研和分析，提出相应对策。</li>
<li>负责对外宣传和推广，开拓市场，提高品牌知名度等。</li>
</ul>
</li>
<li><p>客户经理</p>
<ul>
<li>策划并且独立完成客户的拜访和沟通</li>
<li>Py客户，参与产品定位研讨</li>
</ul>
</li>
</ol>
<ul>
<li>配合 is very important</li>
</ul>
<h2 id="1-2-信息系统软件"><a href="#1-2-信息系统软件" class="headerlink" title="1.2 信息系统软件"></a>1.2 信息系统软件</h2><ul>
<li><p>软件类型：</p>
<ul>
<li>应用软件</li>
<li>支撑软件（中间件）</li>
<li>系统软件</li>
</ul>
</li>
<li><p>其他分类：</p>
<ul>
<li>开发方式分类：<ul>
<li>通用</li>
<li>定制</li>
</ul>
</li>
<li>授权许可分类：<ul>
<li>产品软件</li>
<li>自由软件</li>
<li>免费软件等</li>
</ul>
</li>
</ul>
</li>
<li><p>软件特性：</p>
<ul>
<li>不会损耗，但会过时</li>
<li>脑力劳动开发</li>
</ul>
</li>
<li><p>开发软件的问题：</p>
<ul>
<li>复杂性 - 应用场景千差万别</li>
<li>一致性 - 软件要求运行平台软硬件一致</li>
<li>可变性 - 版本省级等</li>
</ul>
</li>
<li><p>开发任务：<strong>确保本质问题不会失去控制</strong></p>
</li>
<li><p>成功三要素：</p>
<ul>
<li>利益相关者</li>
<li>软件过程</li>
<li>软件建模</li>
</ul>
</li>
<li><p>软件质量属性：</p>
<ul>
<li>一堆：功能性，可靠性，易用性等等等等orz</li>
<li>ISO建议：<ul>
<li>高层：软件质量需求评价准则</li>
<li>中层：软件质量设计评价准则</li>
<li>底层：软件质量度量贫家准则</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="1-3-信息系统开发过程"><a href="#1-3-信息系统开发过程" class="headerlink" title="1.3 信息系统开发过程"></a>1.3 信息系统开发过程</h2><h3 id="1-3-1-信息系统生命周期"><a href="#1-3-1-信息系统生命周期" class="headerlink" title="1.3.1 信息系统生命周期"></a>1.3.1 信息系统生命周期</h3><ul>
<li>三大步：<ol>
<li>系统规划</li>
<li>系统开发</li>
<li>系统运行和维护</li>
</ol>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20211018215357.png" alt="image-20211018215357597"></p>
<ul>
<li>系统项目过程：<ul>
<li>以<strong>工程项目</strong>方式来管理信息系统的<strong>开发过程，支持过程，组织过程，运行过程</strong>等流程活动</li>
</ul>
</li>
<li>系统开发过程框架：<ul>
<li>组织活动和公共过程框架以及流程模式</li>
</ul>
</li>
</ul>
<h2 id="1-4-系统开发过程模型"><a href="#1-4-系统开发过程模型" class="headerlink" title="1.4 系统开发过程模型"></a>1.4 系统开发过程模型</h2><ol>
<li>瀑布开发过程模型：</li>
</ol>
<ul>
<li>按照生命周期阶段<strong>线性顺序开展</strong></li>
<li>每个阶段都会创建和提交<strong>大量文档</strong></li>
<li>特点：简单，难以获得用户完整需求，前期的bug后期裂开。</li>
<li>应用场景：需求十分明确，需求较小</li>
</ul>
<ol start="2">
<li>原型开发模型：</li>
</ol>
<ul>
<li>解决<strong>需求变更</strong>的快速响应问题。</li>
<li>含有：探索式原型开发，抛弃式原型开发</li>
<li>特点：牛啊！快速开发迭代，但是同时，稳定性会收到挑战。难以标记里程碑，项目管理复杂。</li>
<li>应用场景：<strong>较多人机交互界面</strong>的项目，适合于<strong>需求初期不太明确</strong>的系统项目。</li>
</ul>
<ol start="3">
<li>螺旋式开发：</li>
</ol>
<ul>
<li>进化迭代，原型开发特征+瀑布开发过程的系统化，每一轮都是一个小瀑布。</li>
<li>映入了风险分析，且由内到外进行若干次迭代，直到开发处满足需求的版本。</li>
</ul>
<h1 id="第三章：系统规划"><a href="#第三章：系统规划" class="headerlink" title="第三章：系统规划"></a>第三章：系统规划</h1><h2 id="3-1-系统规划概述："><a href="#3-1-系统规划概述：" class="headerlink" title="3.1 系统规划概述："></a>3.1 系统规划概述：</h2><ul>
<li>什么是系统规划？<ul>
<li>为支撑组织机构未来发展提供 <strong>信息系统建设方案与计划</strong></li>
</ul>
</li>
<li><h2 id="系统规划意义："><a href="#系统规划意义：" class="headerlink" title="系统规划意义："></a>系统规划意义：</h2></li>
</ul>
<h3 id="项目成本估算："><a href="#项目成本估算：" class="headerlink" title="项目成本估算："></a>项目成本估算：</h3><ul>
<li>完成项目工作所需要的<strong>费用估计</strong></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210922143805.png" alt="image-20210922143805077"></p>
<h3 id="项目成本估算方法："><a href="#项目成本估算方法：" class="headerlink" title="项目成本估算方法："></a>项目成本估算方法：</h3><ol>
<li>类比估算法：利用历史信息和专家判断进行估计</li>
<li>自底向上估算方法：最小任务活动市场成本，计算整体</li>
<li>德尔菲法：多个领域专家，最终达成一致性结果</li>
</ol>
<ul>
<li>立项前进行估算</li>
</ul>
<h3 id="项目成本预算："><a href="#项目成本预算：" class="headerlink" title="项目成本预算："></a>项目成本预算：</h3><ul>
<li><p>项目开始做的时候，才细分下来预算嗷！！！</p>
</li>
<li><p>项目估算成功在各具体的任务活动上进行<strong>经费分配的过程</strong></p>
</li>
</ul>
<h2 id="3-1-项目可行性研究："><a href="#3-1-项目可行性研究：" class="headerlink" title="3.1 项目可行性研究："></a>3.1 项目可行性研究：</h2><ul>
<li><p>可行性研究</p>
</li>
<li><p>技术可行性分析：</p>
</li>
<li><p>评估项目解决方案所采用 <strong>技术方案的可行性和合理性</strong> </p>
</li>
<li><p>进度可行性分析：</p>
<ul>
<li><strong>时间长度的合理性和可行性</strong></li>
</ul>
</li>
<li><p>经济可行性分析：</p>
<ul>
<li><strong>投资回报率分析</strong></li>
<li>从项目成本角度考虑，项目成本和投资收益合理吗？</li>
</ul>
</li>
<li><p>社会可行性分析：</p>
<ul>
<li>信息系统建设的<strong>可行性和合规性</strong>，评估信息系统建设的可操作性。</li>
<li>法律，法规等</li>
</ul>
</li>
<li><p>可行性分析报告：</p>
<ul>
<li>可行性研究报告给出了可行性研究结论，为组织机构提供科学依据，进一步开展工作的基础。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210922145642.png" alt="image-20210922145642216"></p>
<p>我们写报告一样的，需要突出我们的可行性和需求嗷！！！</p>
</li>
</ul>
<h1 id="第四章：系统需求分析"><a href="#第四章：系统需求分析" class="headerlink" title="第四章：系统需求分析"></a>第四章：系统需求分析</h1><ul>
<li>需求不是一成不变的，需求的变更需要我们严格的分析。</li>
</ul>
<h2 id="4-1-需求采集："><a href="#4-1-需求采集：" class="headerlink" title="4.1 需求采集："></a>4.1 需求采集：</h2><ul>
<li><p>系统开发的最少技术阶段。需要社交，沟通等技巧。同时交付一个用户需求的定义。</p>
</li>
<li><p>需求采集方法：</p>
</li>
<li><p>具体如下：</p>
</li>
</ul>
<ol>
<li><p>研究现有文档和系统：</p>
<ol>
<li><p>开发目标软件系统之前，一会有一些订单等数据。<strong>这些文档和系统资料真实反映了组织业务过程中数据表现与流转的机制</strong>。</p>
</li>
<li><p>组织结构图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20211019161702.png" alt="image-20211019161654679"></p>
</li>
<li><p>组织的规划和宏观决策相关文档：</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20211019161751.png" alt="image-20211019161751296"></p>
</li>
<li><p>工作规范文档</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20211019161818.png" alt="image-20211019161817945"></p>
</li>
<li><p>业务单据</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20211019161938.png" alt="image-20211019161938054"></p>
</li>
<li><p>报表</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20211019162002.png" alt="image-20211019162002413"></p>
</li>
<li><p>描述问题的文档</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20211019162020.png" alt="image-20211019162019842"></p>
</li>
<li><p>组织业务相关的专业知识</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20211019162034.png" alt="image-20211019162034115"></p>
</li>
<li><p>现存相关软件系统</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20211019162046.png" alt="image-20211019162045934"></p>
</li>
</ol>
</li>
<li><p>与客户以及相关人员进行面谈：</p>
</li>
</ol>
<ul>
<li><p>概念：面谈是指需求调查分析人员与客户以及项目相关人员进行面对面的谈话。</p>
<ul>
<li>访谈对象的多样性：<ol>
<li>客户：周期，预算，质量要求，预期收益</li>
<li>用户：功能需求，非功能需求</li>
<li>领域专家：领域知识</li>
<li>客户的上下游合作伙伴：对系统的合作期望</li>
</ol>
</li>
</ul>
</li>
<li><p>面谈形式：</p>
<ul>
<li>正式面谈</li>
<li>非正式面谈</li>
</ul>
</li>
<li><p>优缺点：</p>
<ul>
<li>优点：深入了解面谈者对于问题的看法和回答，动态地调整面谈内容。</li>
<li>缺点：不一定能及时安排，而且需要书面确认，导致过程延长。</li>
</ul>
<ol start="3">
<li>调查表法：</li>
</ol>
<ul>
<li>传统方法：纸质文档，人工填写，成本高，难以异地。</li>
<li>新型渠道方法：网页，H5页面，电子邮件，即时通信软件等。</li>
</ul>
</li>
<li><p>问题分类：</p>
<ul>
<li>封闭式问题（有备选答案）</li>
<li>开放式问题（没有备选答案）</li>
</ul>
<ol start="4">
<li>观察法：</li>
</ol>
</li>
<li><p>旁观式观察：观察特定的业务活动，不打扰。条件允许还可以拍摄，便于回访分析。</p>
<ul>
<li>解释式观察：不仅观察，还可以得到业务人员解释，说明所做业务的要素和关键点。</li>
<li>参与式观察：参与业务活动，成为一份子，承担业务功能，<strong>三种观察中最深入的一种！！！</strong></li>
<li>观察法特点：<ul>
<li>时间多样性</li>
<li>地点多样性</li>
<li>观察人员多样性</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="5">
<li>头脑风暴</li>
</ol>
<ul>
<li>自由思考，自由讨论。对于一个观点共同讨论，高强度的思想碰撞。</li>
<li>会议要求：<ul>
<li>特定讨论主题</li>
<li>主持人</li>
<li>人数限制</li>
<li>有限时间</li>
<li>消极旁观打咩</li>
<li>私下议论打咩</li>
<li>相互尊重</li>
<li>开门见山，不要客套等</li>
</ul>
</li>
<li>风暴问题：<ul>
<li>输入输出数据是啥等</li>
<li>安全风险是啥等</li>
<li>接口关系等</li>
</ul>
</li>
<li>优点：<ul>
<li>没有拘束的规则，人们更加能够自由思考。</li>
<li>对一个观点共同讨论</li>
<li>高强度的思想碰撞。</li>
</ul>
</li>
</ul>
<ol start="6">
<li>原型法</li>
</ol>
<ul>
<li><p>概念：构建原型进行可视化模拟，获得用户对于需求反馈的方法。</p>
</li>
<li><p>主要目的：<strong>明确需求</strong>嗷！！！</p>
</li>
<li><p><strong>现代且广泛采用</strong>的需求采集和确定的方法</p>
</li>
<li><p>本质：<strong>一个演示系统</strong></p>
</li>
<li><p>使用场景：用户无法准确描述需求。</p>
</li>
<li><p>原型需求采集法是基于原型的软件工程过程模型的一部分。</p>
</li>
<li><p>不适用于难以界面模拟，存在大量运算和逻辑性强的系统。</p>
</li>
<li><p>分类：</p>
<ul>
<li>丢弃型原型</li>
<li>进化型原型</li>
</ul>
</li>
</ul>
<ol start="7">
<li>快速应用开发（RAD）</li>
</ol>
<ul>
<li><p><strong>快速生成系统</strong>的开发方法，也是一种 <strong>需求抽取</strong>方法。</p>
</li>
<li><p>目标是<strong>快速交付系统解决方案</strong></p>
</li>
<li><p>RAD融合了进化型原型和头脑风暴。</p>
</li>
<li><p>结合了五个方面的技术：</p>
<ol>
<li>进化原型</li>
<li>CASE工具</li>
<li>拥有能够使用先进工具的专门人员</li>
<li>交互式联合应用开发活动（头脑风暴）</li>
<li>项目进度表，<strong>时间盒</strong>的项目管理方法</li>
</ol>
</li>
<li><p>不足：</p>
<ul>
<li>需要人力多，投入精力多。</li>
<li>很短的时间内需要一系列的需求分析，开发和客户任何一边出了问题就会导致RAD项目失败。</li>
<li>不适合技术风险很高的情况。</li>
<li>可能产生难以维护和拓展的软件。</li>
</ul>
</li>
</ul>
<h2 id="4-2-需求可视化建模："><a href="#4-2-需求可视化建模：" class="headerlink" title="4.2 需求可视化建模："></a>4.2 需求可视化建模：</h2><ul>
<li>业务流程图建模，用例图建模，活动图建模，类图建模</li>
</ul>
<h3 id="4-2-1-业务流程建模："><a href="#4-2-1-业务流程建模：" class="headerlink" title="4.2.1 业务流程建模："></a>4.2.1 业务流程建模：</h3><ul>
<li><p>可以使用BPMN，或者是UML</p>
</li>
<li><p>三种业务流程：</p>
<ul>
<li>普通流程（Process）</li>
<li>合作流程（Collaboration Process）</li>
<li>编排流程（Choreography Process或者Choreography）</li>
</ul>
</li>
<li><p>三者组合利用，可以表达更为复杂的业务流程。</p>
</li>
</ul>
<h4 id="普通流程建模："><a href="#普通流程建模：" class="headerlink" title="普通流程建模："></a>普通流程建模：</h4><ul>
<li>私有业务流程建立某个<strong>特定组织内部的流程</strong>，被称为工作流或者业务流程。<ul>
<li><strong>不可执行的私有业务流程</strong>：不要求自动执行，用于业务流程描述和文档化的流程。</li>
<li><strong>可执行的私有业务流程</strong>：可以根据语义定义而自动执行的流程。一个私有流程必须限制在一个泳池之内。</li>
</ul>
</li>
<li><strong>公开业务流程</strong>：一个<strong>私有业务流程</strong>与其他流程或参与者之间的<strong>交互</strong>，向外部世界显示<strong>交互的信息</strong>以及<strong>信息之间的次序</strong>。<ul>
<li>私有业务流程和其他流程或参与者之间的交互。</li>
<li>仅仅包含这些参与活动和活动之间的次序，不显示其他非交互的活动。</li>
<li>向外部世界显示 <strong>交互的信息</strong> 以及 *<em>消息之间的次序</em></li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20211019164619.png" alt="image-20211019164619604"></p>
<h4 id="合作流程建模："><a href="#合作流程建模：" class="headerlink" title="合作流程建模："></a>合作流程建模：</h4><ul>
<li>合作指的是组织中两个参与者在业务流程中的合作。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20211019164721.png" alt="image-20211019164721080"></p>
<ul>
<li>两个泳池之间通过<strong>消息流</strong>是表示两个相应参与者之间交换的消息。</li>
<li>合作流程中的泳池可以是空泳池，泳池之间的消息流连接在泳池边界上。</li>
<li>把信息流直接加入到泳池中，消息流直接连接在流程活动上，也可以的嗷！！！</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20211019164857.png" alt="image-20211019164856853"></p>
<ul>
<li>也可以使用对话来表示一组具有顺序逻辑关联的交互消息。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20211019164911.png" alt="image-20211019164911565"></p>
<h4 id="编排流程建模："><a href="#编排流程建模：" class="headerlink" title="编排流程建模："></a>编排流程建模：</h4><ul>
<li><strong>也是描述多个参与者的交互</strong>，强调交互，<strong>取消掉了池的概念</strong>，由<strong>编排活动</strong>直接表现多个参与者之间的消息交互，提供了一种<strong>基于流程图的视图</strong>。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20211019164954.png" alt="image-20211019164953872"></p>
<ul>
<li>没有阴影的参与者的是交互的发起者，其他的都是参与者。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20211019165153.png" alt="image-20211019165152944"></p>
<ul>
<li>这个是从<strong>交互的角度</strong>来建模，上面两个是从<strong>活动的角度</strong>来建模。</li>
<li>分为：<ul>
<li>合作图</li>
<li>编排图</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20211019165335.png" alt="image-20211019165335128"></p>
<h3 id="4-2-2-用例图建模（功能建模）："><a href="#4-2-2-用例图建模（功能建模）：" class="headerlink" title="4.2.2 用例图建模（功能建模）："></a>4.2.2 用例图建模（功能建模）：</h3><ul>
<li><p>用例图以及其构成：</p>
<ul>
<li><strong>参与者，用例</strong>和他们之间的<strong>关系</strong>构成的用于描述<strong>系统功能</strong>的图称为<strong>用例图</strong>。</li>
<li>用例模型由若干用例组成。</li>
<li>描述系统 <strong>功能性需求</strong> 的方法，是对于系统<strong>功能需求</strong>的建模。</li>
</ul>
</li>
<li><p>用例图构成：</p>
<ul>
<li>参与者</li>
<li>用例</li>
<li>关系</li>
</ul>
</li>
<li><p>可选元素：</p>
<ul>
<li>系统边界</li>
<li>包</li>
<li>注释</li>
</ul>
</li>
<li><p>建模角度：</p>
<ul>
<li>功能</li>
<li>数据</li>
<li>行为</li>
</ul>
</li>
<li><p>功能一般就是使用用例图进行建模的嗷！！！</p>
</li>
</ul>
<h4 id="参与者："><a href="#参与者：" class="headerlink" title="参与者："></a>参与者：</h4><ul>
<li><strong>系统外部</strong>与系统<strong>直接交互</strong>的<strong>人或事务</strong></li>
<li>角色不是具体的人，代表了扮演的角色。</li>
<li><strong>参与者作为外部用户与系统发生交互作用</strong></li>
<li>典型三类参与者：<ol>
<li>人</li>
<li>外部系统</li>
<li>设备</li>
</ol>
</li>
</ul>
<h4 id="用例："><a href="#用例：" class="headerlink" title="用例："></a>用例：</h4><ul>
<li><strong>外部可见</strong>的一个<strong>系统功能单元</strong></li>
<li>用例名称通常使用<strong>动词短语或者动名词组</strong></li>
<li>系统功能由系统单元提供，通过一系列功能系统单元与一个或多个参与者之间交换的信息所表达。</li>
<li><strong>任何用例都不能够在缺少参与者的情况下独立存在。</strong></li>
<li>发现用例的方法：<ol>
<li><strong>从参与者角度</strong>：<ul>
<li>根据参与者的职责要求，参与者完成了什么任务？</li>
<li>参与者任务怎么触发呢？</li>
<li>需要多个参与者的配合吗？</li>
<li>参与者需要完成多个任务如何进行拆解和合并，映射到不同的系统功能。</li>
</ul>
</li>
<li><strong>从系统功能角度</strong>：<ul>
<li>需求采集文档描述了若干系统应该实现的功能。功能是否能够被用例覆盖？</li>
<li>有些功能容易被忽略，系统自动执行的，例如备份等，参与者不明显嗷！！！</li>
</ul>
</li>
</ol>
</li>
<li>箭头加不加都行，箭头指向代表参与者使用某个用例的功能嗷！！！</li>
<li>用例之间的关系：<ol>
<li>泛化关系：若干拓展用例以不同的方式实现了基用例，这个就是泛化关系<ul>
<li>例如：支付，微信支付，支付宝支付嗷！！！</li>
</ul>
</li>
<li>包含关系：基用例执行过程中，一定要执行其中的包含用例，这个就是包含关系<ul>
<li>具有共同行为，多个行为都要做的事情，本质上是一种复用嗷！！！</li>
<li>用例功能过多，我们对于用例中的具体功能进行拆解。达到<strong>简化描述</strong>的目的。</li>
</ul>
</li>
<li>扩展关系：基用例执行过程中，其中的某个用例<strong>在某些条件下才会执行</strong>，不是一定会执行嗷！！！<ul>
<li>注意是反过来的嗷，拓展用例指向基用例。拓展用例的执行会改变基用例的行为。</li>
</ul>
</li>
</ol>
</li>
<li>用例规约：<ul>
<li>对于每一个用例进行详细的描述，用例规约应该包含以下内容：<ul>
<li>简要描述</li>
<li>参与者</li>
<li>事件流</li>
<li>前置条件</li>
<li>后置条件</li>
<li>补充说明</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="4-2-3-活动图建模（行为建模）："><a href="#4-2-3-活动图建模（行为建模）：" class="headerlink" title="4.2.3 活动图建模（行为建模）："></a>4.2.3 活动图建模（行为建模）：</h3><ul>
<li>用于描述系统行为的模型图，可以用来描述过程（业务过程，工作流，事件流等）中的活动以及其迁移。</li>
<li>一个活动图对应一个过程。通常一个活动就对应一个过程，一般可以为<strong>一个用例画一个活动图</strong>，表示用例的详细执行过程。</li>
<li>用例+其对应的活动图，就十分完整了嗷！！！</li>
<li>过程：<ol>
<li>建立用例模型</li>
<li>对于用例模型进行用例规约</li>
<li>对于用例画出活动图</li>
</ol>
</li>
<li>但凡是要描述过程，就可以使用活动图嗷！！！</li>
<li>动作和活动：<ul>
<li>动作具有原子性，不可以被进一步分解，一旦开始执行，这个动作就需要被完成嗷！！！</li>
<li>活动则不具有原子性，活动状态可以有<strong>入口动作，出口动作，内部活动，内部转换</strong>。</li>
</ul>
</li>
<li>三种常见的控制流：<ol>
<li>顺序控制流（顺序行为建模）：<ul>
<li>触发条件不能省略，默认就是上一个活动结束进行下一个活动。</li>
<li>如果有触发条件，触发条件 &amp; 上一个活动结束才能够进入下一个活动嗷！！！</li>
</ul>
</li>
<li>分支控制流（条件行为建模）：<ul>
<li>分支与合并</li>
<li>监控条件（最好是加到括号里面去嗷！！！）的是否满足嗷！！！</li>
</ul>
</li>
<li>并发控制流（并发行为建模）：<ul>
<li>分叉和回合：一个控制流变成多个并发的控制流或者反过来</li>
<li>也被称为同步嗷！！！</li>
</ul>
</li>
</ol>
</li>
</ul>
<h4 id="组合活动："><a href="#组合活动：" class="headerlink" title="组合活动："></a>组合活动：</h4><ul>
<li><p>简单活动：不包含内嵌活动或者动作</p>
</li>
<li><p>组合活动：嵌套了若干活动或者动作</p>
</li>
<li><p>组合活动不具有原子性，可以在执行中被中断</p>
</li>
<li><p>可以体现层次感嗷！！！</p>
</li>
</ul>
<h4 id="泳道："><a href="#泳道：" class="headerlink" title="泳道："></a>泳道：</h4><ul>
<li><p>将活动划分为不同的道，每一条道代表不同的活动者。</p>
</li>
<li><p>泳道图（带泳道的活动图），并且比普通的活动图表达的信息更多嗷！！！可以把类的行为给找出来嗷！！！</p>
</li>
<li><p>假如我们有建模输入输出的需求，我们还可以对于数据流状态进行建模哦，这里不讲了嗷！！！</p>
</li>
</ul>
<h3 id="4-2-4-类图建模（数据建模）："><a href="#4-2-4-类图建模（数据建模）：" class="headerlink" title="4.2.4 类图建模（数据建模）："></a>4.2.4 类图建模（数据建模）：</h3><ul>
<li><p>类和类之间的关系：</p>
<ul>
<li>关联：虚线</li>
<li>依赖：视线</li>
<li>泛化</li>
<li>实现</li>
</ul>
</li>
<li><p>接口使用🍭表示法比较fashion嗷！！！</p>
</li>
<li><p>类图建模的方面：</p>
<ul>
<li>类名 &#x2F; 属性</li>
<li>类关系</li>
<li>类数据操作</li>
</ul>
</li>
<li><p>类名：</p>
<ul>
<li>见名知意</li>
<li>类名通常是名词，首字母大写。</li>
</ul>
</li>
<li><p>类属性：</p>
<ul>
<li><p>名词或名词短语</p>
</li>
<li><p>第一个首字母小写，其他单词首字母大写</p>
</li>
<li><p>可以有多个属性也可以没有属性</p>
</li>
<li><p><code>[可见性] 属性名称: [属性类型] [=初始值]</code></p>
</li>
<li><p>分类：</p>
<ul>
<li>自然属性</li>
<li>管理属性</li>
<li>类之间关系的属性</li>
</ul>
</li>
</ul>
</li>
<li><p>发现类的操作：</p>
<ul>
<li>分析类的每一个属性</li>
<li>分析对象的状态</li>
<li>分析用例规约中描述中的动作（用例驱动法）</li>
<li>分析活动图的活动</li>
<li>分析顺序图 &#x2F; 通信图中两个对象间的消息</li>
</ul>
</li>
<li><p>识别类的方法：</p>
<ul>
<li>名词短语法：<ul>
<li>需求描述中抽取出名词短语</li>
<li>可以分为三类：<ul>
<li>相关类</li>
<li>无关类</li>
<li>模糊类</li>
</ul>
</li>
</ul>
</li>
<li>公共类模式法</li>
<li>用例驱动法</li>
<li>CRC法</li>
</ul>
</li>
<li><p>发现关联：</p>
<ul>
<li>关联名</li>
<li>关联关系：<ul>
<li>类可以与自身关联。</li>
<li>当一个类关联到本身时，不是类的实例与本身关联，而是类的一个实例与类的另外一个实例关联。</li>
</ul>
</li>
<li>关联关系之间的</li>
</ul>
</li>
</ul>
<h4 id="类与类之间的关系："><a href="#类与类之间的关系：" class="headerlink" title="类与类之间的关系："></a>类与类之间的关系：</h4><ul>
<li><p>聚合关系：</p>
<ul>
<li>菱形在大头的那一边嗷！！！</li>
</ul>
</li>
<li><p>泛化关系：</p>
<ul>
<li>继承</li>
</ul>
</li>
</ul>
<h2 id="4-3-需求文档化"><a href="#4-3-需求文档化" class="headerlink" title="4.3 需求文档化"></a>4.3 需求文档化</h2><h2 id="4-4-需求管理"><a href="#4-4-需求管理" class="headerlink" title="4.4 需求管理"></a>4.4 需求管理</h2><h3 id="需求依赖矩阵"><a href="#需求依赖矩阵" class="headerlink" title="需求依赖矩阵"></a>需求依赖矩阵</h3><h3 id="需求变更"><a href="#需求变更" class="headerlink" title="需求变更"></a>需求变更</h3><h1 id="第五章：系统架构设计"><a href="#第五章：系统架构设计" class="headerlink" title="第五章：系统架构设计"></a>第五章：系统架构设计</h1><h2 id="5-1-系统设计概述"><a href="#5-1-系统设计概述" class="headerlink" title="5.1 系统设计概述"></a>5.1 系统设计概述</h2><ol>
<li>基础信息平台设计<ul>
<li><strong>系统设计</strong>是指在系统需求分析的基础上，设计出能够满足系统需求目标的新系统的<strong>构造方案</strong>的活动</li>
</ul>
</li>
<li>系统架构设计<ul>
<li>这里补上</li>
</ul>
</li>
<li>系统界面设计<ul>
<li>这里补上</li>
</ul>
</li>
<li>系统数据库设计<ul>
<li>数据库结构</li>
</ul>
</li>
<li>系统构件设计<ul>
<li>构件功能逻辑，构件接口</li>
</ul>
</li>
</ol>
<ul>
<li>系统设计方法：<ul>
<li>抽象化：在系统规模大，逻辑复杂的情况下，通过抽象实现系统设计建模，降低系统设计复杂性的基本策略。</li>
<li>逐步求精：把问题的求解分解为若干步骤或阶段，抽象使得设计者能够描述过程和数据而忽略低层的细节。</li>
<li>模块化：把一个大系统按照特定规则，划分为若干较小的，又相互关联的部件，把复杂问题简单化。</li>
<li>信息隐藏：</li>
<li>模块独立：便于功能被划分，更易于开发和维护。一般可以由两项指标来衡量：内聚性和耦合性。</li>
</ul>
</li>
</ul>
<h2 id="5-2-系统架构基础"><a href="#5-2-系统架构基础" class="headerlink" title="5.2 系统架构基础"></a>5.2 系统架构基础</h2><ul>
<li><strong>系统架构</strong>是指系统组成的<strong>结构模式</strong>，它由反应系统部件组成的关联性，交互性和约束机制进行描述。</li>
<li>系统架构类型：<ol>
<li>系统总体架构</li>
<li>系统架构模式：<ul>
<li>应用架构</li>
<li>软件架构</li>
</ul>
</li>
</ol>
</li>
</ul>
<h2 id="5-3-软件架构风格"><a href="#5-3-软件架构风格" class="headerlink" title="5.3 软件架构风格"></a>5.3 软件架构风格</h2><h3 id="5-3-1"><a href="#5-3-1" class="headerlink" title="5.3.1"></a>5.3.1</h3><h3 id="5-3-2-软件机构风格应用"><a href="#5-3-2-软件机构风格应用" class="headerlink" title="5.3.2 软件机构风格应用"></a>5.3.2 软件机构风格应用</h3><h3 id="5-3-3-软件架构风格要素"><a href="#5-3-3-软件架构风格要素" class="headerlink" title="5.3.3 软件架构风格要素"></a>5.3.3 软件架构风格要素</h3><h3 id="5-3-4-软件架构风格分类"><a href="#5-3-4-软件架构风格分类" class="headerlink" title="5.3.4 软件架构风格分类"></a>5.3.4 软件架构风格分类</h3><h3 id="5-3-5-分层体系结构"><a href="#5-3-5-分层体系结构" class="headerlink" title="5.3.5 分层体系结构"></a>5.3.5 分层体系结构</h3><h3 id="5-3-6-数据共享体系架构"><a href="#5-3-6-数据共享体系架构" class="headerlink" title="5.3.6 数据共享体系架构"></a>5.3.6 数据共享体系架构</h3><h2 id="5-4-软件架构模式"><a href="#5-4-软件架构模式" class="headerlink" title="5.4 软件架构模式"></a>5.4 软件架构模式</h2><h2 id="5-5-软件架构UML建模设计"><a href="#5-5-软件架构UML建模设计" class="headerlink" title="5.5 软件架构UML建模设计"></a>5.5 软件架构UML建模设计</h2><h1 id="第六章：软件模块详细设计"><a href="#第六章：软件模块详细设计" class="headerlink" title="第六章：软件模块详细设计"></a>第六章：软件模块详细设计</h1><h2 id="6-1-软件建模设计概述："><a href="#6-1-软件建模设计概述：" class="headerlink" title="6.1 软件建模设计概述："></a>6.1 软件建模设计概述：</h2><h3 id="6-1-1-软件建模设计的目标："><a href="#6-1-1-软件建模设计的目标：" class="headerlink" title="6.1.1 软件建模设计的目标："></a>6.1.1 软件建模设计的目标：</h3><ul>
<li>详细设计对于系统各种的每个构件进行详细建模描述。</li>
<li>软件详细建模设计在<strong>分析模型</strong>和<strong>架构模型</strong>上，<strong>对于系统中的构件的内部工作进行建模描述</strong>，为每个构件设计完整的<strong>数据结构，处理逻辑，接口和通信机制</strong>。</li>
<li>构件包括一组协作的类或者构件。</li>
<li>好的构件设计：<ul>
<li>满足分析模型中的所有明确要求。</li>
<li>满足客户期望的所有隐含要求。</li>
<li>必须对于编码人员，测试人员和维护人员是可读可理解的。</li>
<li>应提供软件的完整视图，从实现的角度解决数据，功能和行为等各方面的问题。</li>
</ul>
</li>
</ul>
<h3 id="6-1-2-软件设计的原则："><a href="#6-1-2-软件设计的原则：" class="headerlink" title="6.1.2 软件设计的原则："></a>6.1.2 软件设计的原则：</h3><ul>
<li>设计在发生变更的时能够适应变更并且减少副作用的传播，构件级设计应该遵循设计的基本原则：</li>
</ul>
<ol>
<li>开闭原则（OCP）：对于拓展具有开放性，对于修改具有封闭性：<ul>
<li>对于构件的拓展不需要改变原来构件的代码，内部的封闭性无法保证。</li>
<li>常见情况：使用Interface，Interface不需要进行改变，但是接口的实现可以动态拓展嗷！！！</li>
</ul>
</li>
<li>里氏替换原则（LSP）：子类可以替换它们的基类：<ul>
<li>从基类导出的子类传递给该基类的其他构件的时候，使用该基类的构件仍然能够正常工作。</li>
<li>要求：基类的子类必须遵循基类与使用该基类的构件之间的<strong>隐含约定</strong>。</li>
</ul>
</li>
<li>依赖倒置原则（DIP）：依赖于抽象，而非具体实现<ul>
<li>抽象比较容易对于设计进行拓展</li>
</ul>
</li>
<li>接口分离原则（ISP）：多个客户专用接口比一个通用接口要好<ul>
<li>提供者构件应该为每个主要的客户构件类型提供一个特定的接口</li>
<li>只有和特定客户构件类型相关的操作才会出现在该接口中</li>
</ul>
</li>
<li>内聚性：构件或者类只封装那些相互关联密切，以及与构件或类自身有密切关系的属性和操作<ul>
<li>内聚性分为：<ul>
<li>功能内聚：所有元素配合完成同一个功能。</li>
<li>分层内聚：高层访问低层，低层不能访问高层。</li>
<li>通信内聚：模块内的所有元素都访问相同的数据。用于数据的查询，访问和存储。</li>
</ul>
</li>
<li>从上往下，强度由强到弱。</li>
<li>内聚性越强，越容易实现，测试和维护。</li>
</ul>
</li>
<li>耦合性：指不同对象之间相互关联的程度<ul>
<li>构件设计要尽可能保持低耦合</li>
<li>通过类的公共系统实现耦合</li>
</ul>
</li>
<li>可重用性：尽量使用已有的类<ul>
<li>确实需要构件新类的时候，在这几这些新类的时候考虑将来的可重用性。</li>
</ul>
</li>
</ol>
<h3 id="6-1-3-软件建模设计内容："><a href="#6-1-3-软件建模设计内容：" class="headerlink" title="6.1.3 软件建模设计内容："></a>6.1.3 软件建模设计内容：</h3><ul>
<li><p>软件静态交互建模：</p>
</li>
<li><p>软件动态交互建模：</p>
<ul>
<li>展现对象之间的<strong>交互和协作</strong></li>
<li>使用<strong>顺序图</strong>或者<strong>通信图</strong>建模并细化对象之间的交互</li>
</ul>
</li>
<li><p>软件状态机建模：</p>
<ul>
<li>通常一个状态机依附于一个类。</li>
</ul>
</li>
</ul>
<h3 id="6-1-4-软件建模设计活动："><a href="#6-1-4-软件建模设计活动：" class="headerlink" title="6.1.4 软件建模设计活动："></a>6.1.4 软件建模设计活动：</h3><h2 id="6-2-UML软件静态结构视图建模："><a href="#6-2-UML软件静态结构视图建模：" class="headerlink" title="6.2 UML软件静态结构视图建模："></a>6.2 UML软件静态结构视图建模：</h2><h3 id="6-2-1-软件静态结构视图"><a href="#6-2-1-软件静态结构视图" class="headerlink" title="6.2.1 软件静态结构视图"></a>6.2.1 软件静态结构视图</h3><ul>
<li>主要使用 <strong>类图</strong> 来表示</li>
<li>类：<ul>
<li>对于一组具有相同属性，操作，关系和语义的对象的描述。</li>
<li>常见的分类包括：<ul>
<li>实体类</li>
<li>边界类</li>
<li>控制类</li>
</ul>
</li>
<li>类建模不是一个确定的过程，是 <strong>高度迭代增量式</strong></li>
<li></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/22/%E8%BD%AF%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/" data-id="cl6gepmh2009be0jqe5fp6oid" data-title="软件系统架构" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%A7%E4%B8%89%E8%87%AA%E5%AD%A6/" rel="tag">大三自学</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-大数据分析课程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/14/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E8%AF%BE%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-09-14T11:33:01.000Z" itemprop="datePublished">2021-09-14</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/14/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E8%AF%BE%E7%A8%8B/">大数据分析课程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="大三大数据课程上课笔记以及课下补充"><a href="#大三大数据课程上课笔记以及课下补充" class="headerlink" title="大三大数据课程上课笔记以及课下补充"></a>大三大数据课程上课笔记以及课下补充</h1><h1 id="数据分析（机器学习算法基础）："><a href="#数据分析（机器学习算法基础）：" class="headerlink" title="数据分析（机器学习算法基础）："></a>数据分析（机器学习算法基础）：</h1><h1 id="数据关系算法："><a href="#数据关系算法：" class="headerlink" title="数据关系算法："></a>数据关系算法：</h1><ul>
<li>获取心的知识或者技能嗷！！！</li>
<li>知识体系：<ul>
<li>统计学</li>
<li>人工智能</li>
<li>信息论</li>
<li>认知科学</li>
<li>计算复杂性</li>
<li>控制等</li>
</ul>
</li>
</ul>
<h2 id="TF-IDF算法："><a href="#TF-IDF算法：" class="headerlink" title="TF-IDF算法："></a>TF-IDF算法：</h2><ul>
<li><p>Term Frequency-Inverse Document Frequency</p>
</li>
<li><p>典型的应用是<strong>一堆文档中选择属于每个文本最具有代表性的词汇</strong>。</p>
</li>
<li><p>常用于<strong>检索系统的加权技术</strong>。</p>
</li>
<li><p>What is key-word ? A word can describe the whole passage.</p>
</li>
</ul>
<h3 id="词袋模型："><a href="#词袋模型：" class="headerlink" title="词袋模型："></a>词袋模型：</h3><ul>
<li>第一步：将文本转换为向量，转换为能够作为计算的数量，即<strong>把文本转换到数量空间</strong>。（向量空间模型）<ul>
<li>what is 词袋模型：<ul>
<li>一种广泛用于自然语言处理和信息检索的词语模型</li>
<li>若干词语直接放在一个“袋子”中，而<strong>不考虑词语间的语法和相互顺序</strong></li>
</ul>
</li>
<li>A,B取所有词的并集构成词袋，然后词袋分别在A,B文档中遍历一次，获得每个文档对应的向量（长度是相同的，因为词袋的大小是固定的嗷！！）</li>
<li>词袋模型仅仅与词频有关系，但是对于逻辑，语义和顺序是没有关系的嗷！！！</li>
</ul>
</li>
<li>基本思想：文档中的每个词的重要性与它在当前文档中出现的次数成正比，但是与它在其他文件中出现的次数成反比。（想法：找出每个文档中特有的词汇嗷！！！）</li>
<li>推论：如果某个词在A中出现频率高，在其他中出现很低，那么这个文档就可以由这个词语进行区分嗷！！！</li>
</ul>
<h3 id="过程："><a href="#过程：" class="headerlink" title="过程："></a>过程：</h3><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ol>
<li>对于过长文本和短文本的处理不是很好</li>
<li>忽略了语法和语义的表达</li>
<li>词语之间必须完全匹配，对于相似的词语或者词语的子词语之间不能够进行有效的匹配。</li>
</ol>
<h2 id="余弦相似性算法："><a href="#余弦相似性算法：" class="headerlink" title="余弦相似性算法："></a>余弦相似性算法：</h2><ul>
<li>平行的衡量相似度的系数：Jaccard系数，通过符号度量或者布尔值标识，适合集合的计算。</li>
<li>直观想法：两篇文章越相似，他们词语的交集就越多。余弦向量的计算公式：</li>
</ul>
<p>$$<br>cos{\theta} &#x3D; \frac{a \times b}{||a|| \times ||b||}<br>$$</p>
<p>然后通过向量的定义，能够再拆开成数量的计算嗷！！！</p>
<h3 id="优缺点："><a href="#优缺点：" class="headerlink" title="优缺点："></a>优缺点：</h3><ol>
<li>余弦相似度考虑了每个词的频次和顺序，Jaccarb则考虑的就少了嗷！！！</li>
<li>长文本计算复杂度高嗷！</li>
</ol>
<h2 id="Apriori算法："><a href="#Apriori算法：" class="headerlink" title="Apriori算法："></a>Apriori算法：</h2><ul>
<li><p>数据的关联规则挖掘就是用这个算法来操作的嗷！！！看似无关的海量历史数据中，挖掘出可能具有的价值信息，再商业活动中会利用数据之间的关系产生较大的商业价值。</p>
</li>
<li><p>关联规则反映的是两个或者多个事务相互之间的<strong>依存性和关联性</strong>。</p>
</li>
<li><p>频繁项集算法</p>
</li>
<li><p>应用广泛，超市商品关联分析，消费习惯分析等。。。</p>
</li>
<li><p>概念：</p>
<ul>
<li>项集：项的结合。</li>
<li>关联规则：蕴含表达式，其中X和Y是不相交的项集。</li>
<li>支持度：关联规则的支持度，说白了就是联合概率密度。</li>
<li>置信度：项集X发生的情况下，项集Y发生的概率。</li>
<li>最小支持度：统计意义上的最低重要性。</li>
<li>最小置信度：人为按照实际意义的阈值，表示关联规则的最低可靠性。</li>
<li>频繁项集：满足最小支持度的所有项集，称为频繁项集。</li>
</ul>
</li>
<li><p>如果一个集合是频繁项集，那么它的所有集合都是频繁项集合。如果一个集合它不是频繁项集，那么它的所有超集都不是频繁项集。</p>
</li>
</ul>
<h3 id="算法流程："><a href="#算法流程：" class="headerlink" title="算法流程："></a>算法流程：</h3><ol>
<li>扫描历史数据，对于每项数据进行频率次数统计。</li>
<li>构建候选项集C1，并计算其支持度。</li>
<li>对于候选项集进行筛选，形成频繁项集L1。</li>
<li>对于频繁项集L1进行连接生成候选项集C2。</li>
<li>重复上述步骤，最终形成频繁K项集或者最大频繁项集。</li>
</ol>
<h3 id="缺点：-1"><a href="#缺点：-1" class="headerlink" title="缺点："></a>缺点：</h3><ol>
<li>没有考虑排除一些无关元素。</li>
<li>候选项集产生较多的组合。</li>
<li>每次计算项集的过程都会扫描原始的数据表。</li>
<li>对于数据量较大的系统而言，重复扫描开销大。</li>
</ol>
<h3 id="解决途径："><a href="#解决途径：" class="headerlink" title="解决途径："></a>解决途径：</h3><ol>
<li>压缩数据表</li>
<li>利用哈希表的快速查找特性对于项集进行计数统计。</li>
<li>合理选样</li>
<li>FP-Growth算法</li>
</ol>
<h2 id="PageRank算法："><a href="#PageRank算法：" class="headerlink" title="PageRank算法："></a>PageRank算法：</h2><ul>
<li>数据关系还可以应用到<strong>搜索引擎和推荐系统</strong>。</li>
<li>PageRank的思想：<strong>看一个人怎样，看他有什么朋友就知道了</strong>。<strong>被越多优质的网页所指向的网页，它是优质的网页的概率就越大</strong>。</li>
<li>假设：<ul>
<li>数量假设：一个页面节点接收到的其他页面指向的入链数量越多，那么这个页面越重要。</li>
<li>质量假设：越是质量高的页面指向页面A，则页面A越重要嗷！！！</li>
</ul>
</li>
</ul>
<h3 id="算法步骤："><a href="#算法步骤：" class="headerlink" title="算法步骤："></a>算法步骤：</h3><ol>
<li>每个网页初始化PR值为1&#x2F;N，其中N为网页总数。</li>
<li>投票算法不断迭代，知道达到平稳分布为止。</li>
</ol>
<h3 id="常见问题："><a href="#常见问题：" class="headerlink" title="常见问题："></a>常见问题：</h3><ul>
<li>排名上升</li>
<li>排名下沉</li>
<li>排名</li>
</ul>
<h3 id="优缺点：-1"><a href="#优缺点：-1" class="headerlink" title="优缺点："></a>优缺点：</h3><ol>
<li>离线计算获得，减少在线查询的计算量</li>
<li>过分相信链接关系</li>
<li>忽视了主题相关性，旧的页面等级会比新的页面高</li>
</ol>
<h1 id="分类和聚类："><a href="#分类和聚类：" class="headerlink" title="分类和聚类："></a>分类和聚类：</h1><ul>
<li><p>分类与聚类：</p>
<ul>
<li><strong>监督</strong>学习：分类</li>
</ul>
<p><strong>需要人类先验的知识</strong>，<strong>打上flag</strong>，例如猫狗大战的训练数据。我们把分类好的数据给计算机，去引导计算机进行学习分类</p>
<ul>
<li><strong>非监督</strong>学习：聚类</li>
</ul>
<p><strong>不需要人类先验的知识</strong>，也不需要打flag。计算机自己根据传递的数据，将数据分为几类。比如我们给了一坨数据给机器，告诉它咱给他分两类。这个就是聚类嗷！！！</p>
</li>
<li><p>分类过程：</p>
<ol>
<li>训练</li>
<li>识别</li>
</ol>
</li>
</ul>
<h2 id="Naive-Bayes（重点）："><a href="#Naive-Bayes（重点）：" class="headerlink" title="Naive Bayes（重点）："></a>Naive Bayes（重点）：</h2><ul>
<li>根据Bayes定理为理论基础，进行了推论嗷！！！</li>
<li>贝叶斯的前提：假设所有因素都是无关的嗷！！！</li>
<li>贝叶斯公式：</li>
</ul>
<p>$$<br>P(H | X) &#x3D; \frac{P(X|H)P(H)}{P(X)}<br>$$</p>
<ul>
<li>给定特征<code>W = (w1 , w2 , ... , wn)</code>，给定类别<code>C = (c1 , ... , cm)</code>，然后我们就回去算这个概率嗷！！！</li>
<li>我们对于给定的所有特征进行计算，然后比较不同的条件概率，最大的，就是我们判定的标签嗷！！！</li>
</ul>
<h2 id="AdaBoost（重点）："><a href="#AdaBoost（重点）：" class="headerlink" title="AdaBoost（重点）："></a>AdaBoost（重点）：</h2><ul>
<li>想法：组合分类器，是一种强分类器。先训练出一批弱分类器，将弱分类器组合为强分类器。</li>
<li>具有基于测试过程中的错误反馈调节分类器的分类效果嗷！！！</li>
<li>某个样本被错判，下一次迭代过程中，错的样本的权值就会增加嗷！！！同时，判断正确的样本的权值下一轮就会被降低嗷！！！</li>
<li>优点：<ul>
<li>准确率大幅提高</li>
<li>分类速度快，基本不用调参</li>
<li>过拟合的情况几乎不会出现嗷！！！</li>
<li>构建子分类器时有多种情况可以使用！</li>
<li>方法简单，容易理解和掌握，不用做特征分类。</li>
</ul>
</li>
</ul>
<h2 id="SVM："><a href="#SVM：" class="headerlink" title="SVM："></a>SVM：</h2><ul>
<li>适用于小样本，高维模式的识别。</li>
<li>基于结构风险最小化：经验风险和置信区间的折中（考虑了容错的哦！！！）。</li>
<li>原理：超平面去切这些点的空间，会把点分到两侧。超平面以上是正样本，以下是负样本。（超平面在两边的边界之间嗷！！！）</li>
<li>还有个什么核，可以将叠加让平面不规则帮助我们完成分类嗷！！！</li>
</ul>
<h2 id="KNN："><a href="#KNN：" class="headerlink" title="KNN："></a>KNN：</h2><ul>
<li>计算并且获得待测样本附近的K个样本</li>
<li>根据分类决策规则，投票康康这个点是哪个类的嗷！！！</li>
<li>缺点：<ol>
<li>不平衡样本</li>
<li>计算量相对较大</li>
<li>K值的设定对于算法的结果有很大影响</li>
</ol>
</li>
<li>解决途径：在实际应用过程中将类别典型的样本纳入样本库中嗷！！！</li>
</ul>
<h2 id="K-Means："><a href="#K-Means：" class="headerlink" title="K-Means："></a>K-Means：</h2><ul>
<li>聚类的方法，非监督学习的方法。核心思想：人以类聚，物以群分嗷！！！</li>
<li>聚类的个数往往是人为选取的嗷！！！（但是有章可循）</li>
<li>句子之间的相似性可以采用余弦相似性来进行计算嗷！！！</li>
<li>缺点：<ul>
<li>对于异常值和摇摆值比较敏感，收敛比较慢嗷！！！</li>
<li>非常不适合分布均匀，数据界限不明晰的聚类。</li>
<li>初始中心点的选择对于迭代次数影响大，K-Means++算法，改进了初始点的选择</li>
<li>需要提前确定聚类簇的值嗷！！！</li>
</ul>
</li>
</ul>
<h1 id="数据决策："><a href="#数据决策：" class="headerlink" title="数据决策："></a>数据决策：</h1><h2 id="ID3："><a href="#ID3：" class="headerlink" title="ID3："></a>ID3：</h2><ul>
<li><p>决策树，是一个预测模型，代表 <strong>对象属性和对象值的一种映射关系</strong> 。</p>
</li>
<li><p>决策树经常用于数据挖掘中的 <strong>数据分析和预测</strong> 。</p>
</li>
<li><p>决策树是一种特殊的树结构，用来<strong>创建达到目标的规划</strong>。</p>
</li>
<li><p>理论基础：</p>
<ul>
<li><strong>信息熵和信息增益</strong></li>
</ul>
</li>
<li><p>决策树的关键问题：树分支裂变的依据，选择准则。</p>
</li>
<li><p>ID3算法默认的变量是离散型变量嗷！！！</p>
</li>
<li><p>根据什么裂变？</p>
<ul>
<li>算出每个属性的信息增益</li>
<li>选择信息增益最大的属性来进行裂变</li>
<li>如果结果有确定性，那递归，不然就结束算法嗷！！！</li>
</ul>
</li>
</ul>
<h2 id="C4-5："><a href="#C4-5：" class="headerlink" title="C4.5："></a>C4.5：</h2><ul>
<li>ID3偏向于选择属性多的属性，因为其信息增益较大，这样某种概念上是不公平的嗷！！！</li>
<li>决策树在构造过程中支持剪枝。</li>
<li>C4.5还需要计算分裂信息度量，计算信息增益率，选择信息增益率最高的属性作为决策树结点进行分裂。</li>
<li>递归！！！</li>
</ul>
<h2 id="CART："><a href="#CART：" class="headerlink" title="CART："></a>CART：</h2><ul>
<li>分类与回归树，根据变量是离散的还是回归的，CART都可以进行处理嗷！！！</li>
<li><strong>GINI指数</strong><ul>
<li>用于表示信息不确定性的（集合不确定性）</li>
<li>指数越大，样本不确定性也越大嗷！！！</li>
</ul>
</li>
</ul>
<h1 id="汤老师："><a href="#汤老师：" class="headerlink" title="汤老师："></a>汤老师：</h1><h2 id="Lession1："><a href="#Lession1：" class="headerlink" title="Lession1："></a>Lession1：</h2><ul>
<li>每一层都是分布式架构（MR , HDFS …）</li>
<li>HDFS底层就是<strong>主从架构模式</strong>，对应的软件和硬件是配套的，都是主从架构（HDFS , HBase , Zookeeper…）。</li>
<li>Hadoop几层架构要搞清楚。</li>
<li>HDFS为什么要分成64KB？Load Balance</li>
<li>Fault Tolerance? Three duplicates , one on one sack ,another two on the same sack (different machines)</li>
</ul>
<h2 id="Lession2"><a href="#Lession2" class="headerlink" title="Lession2:"></a>Lession2:</h2><ul>
<li><p>Hadoop上面建立已成HBase分布式数据库，why？底层以及提供Fault Tolerance和Load Balance两层了orz</p>
</li>
<li><p>系统架构含义：</p>
<ul>
<li>Hardware : Hadoop cluster</li>
<li>Software : HDFS system</li>
</ul>
</li>
<li><p>Hbase集群部署：四大组件</p>
<ul>
<li>Master</li>
<li>Region Server（HBase的Worker程序）</li>
<li>Zookeeper（HBase的Master程序）</li>
<li>Client（HBase的Client程序）</li>
</ul>
</li>
<li><p>数据的逻辑存储结构：</p>
<ul>
<li>Stack , Queue , Tree , Hash…</li>
</ul>
</li>
<li><p>数据的物理存储结构：</p>
<ul>
<li>Volume -&gt; Section -&gt; Track（机械磁盘）</li>
<li>持久化存储</li>
<li>驱动器和文件系统都完成了实际上的物理存储的功能。</li>
</ul>
</li>
<li><p>从逻辑到物理架构的转换 -&gt; 有程序负责从物理存储结构到逻辑转换（类似于HBase），Restore -&gt; Hbase + HDFS</p>
</li>
<li><p>HDFS只负责数据相关的存储和容错等，HBase负责存储架构的转换，读取出来的数据的复原等等！！！</p>
</li>
<li><p>HBase如何存储？</p>
<ul>
<li>Region（HBase的分区）：<ul>
<li>数据库表单被拆分为不同的子表存储到不同的Machine上</li>
<li>算法负责将子表分发到不同的<strong>服务器</strong>上存储</li>
<li>一个结点部署一个Region Server，子表实际上被划分到的服务器就是Region Server（本质是一个程序）</li>
<li>一个服务器上就运行着一个Region Server</li>
<li>每一个HBase都是独立的，那负载均衡咋办？？？ —&gt; Zookeeper就是负责统一协调部署的嗷！！！</li>
</ul>
</li>
<li>Region到底是怎么存的呢？<ul>
<li>Region内部是一个子表</li>
<li>子表按照列（不一定是一列）又分区了，分成了Store</li>
<li>把Store在内部水平分区分成了StoreFile</li>
<li>StoreFile和HDFS的大小刚好匹配上了嗷！！！StoreFile直接就给HDFS了，整活！</li>
<li>HDFS再生成Copy啊，分发到部分结点上嗷（完成灾备等功能）！！（本质上交给HDFS之后，HDFS只负责另外两个备份存到哪个Server上嗷！！！）</li>
</ul>
</li>
</ul>
</li>
<li><p>HLog缓冲区：</p>
<ul>
<li>HLog缓存的常用的Store</li>
<li>对于每个Store，在内存中开辟缓冲区来缓存信息（MemStore），存储常用的StoreFile。</li>
<li>观测程序在不断统计哪些Store和StoreFile被访问的最多，拿出来放到HLog，MemStore（缓冲区中）</li>
<li>HBase底层自动帮助我们进行缓冲和缓冲区的分配，采用LRU进行缓冲的替换嗷！！！</li>
</ul>
</li>
<li><p>Hbase存储的什么数据结构？？？</p>
<ul>
<li>HBase数据模型：<ul>
<li>非常简单，非常灵活</li>
<li>三元组，key-value pair（行键，列族：列限制符，时间戳）</li>
<li>小的数据类型非常灵活，不受限制</li>
</ul>
</li>
</ul>
</li>
<li><p>对于一个数据的Instance，只有一个RegionServer，对于不同的Instance，每个Instance对应的一个RegionServer。</p>
</li>
<li><p>寻址：</p>
<ul>
<li>三层机构：<ul>
<li>Zookeeper</li>
<li>Root</li>
<li>.META.</li>
</ul>
</li>
<li>客户端从Zookeeper获得Region存储位置后，直接在RegionServer写数据嗷！！！</li>
</ul>
</li>
<li><p>HBase索引与检索：</p>
<ul>
<li>HBase查询方式：<ol>
<li>单个RowKey</li>
<li>RowKey区间访问查询</li>
<li>全表扫描</li>
</ol>
</li>
<li>二次检索表技术：<ul>
<li>建立列和行键的关系，方便我们通过列找到对应的行键</li>
<li>再通过行键就能查找找到对应的列了嗷！！！</li>
<li>表的维护，表的存储，表的分区等等（表在内存嗷！！！）。。。好多问题，但是！！！以空间换时间嗷！！！</li>
<li>关键：避免全表搜索！最痛恨的就是全表搜索。。。</li>
</ul>
</li>
</ul>
</li>
<li><p>工程经验：</p>
<ol>
<li>遇到大数据第一想数据拆分</li>
<li>第二想多线程</li>
<li>第三大数据平台嗷！！！</li>
</ol>
</li>
<li><p>分布式协同管理组件Zookeeper：</p>
<ul>
<li>提供服务：<ul>
<li>主从架构</li>
<li>一个主节点</li>
<li>多个从节点</li>
</ul>
</li>
<li>每台机器上也有Zookeeper，Worker也会有Zookeeper的从节点嗷！！！</li>
</ul>
</li>
<li><p>分布式消息队列： 同步队列和FIFO队列</p>
</li>
<li><p>分布式锁：独占锁和控制时序锁 -&gt; Zookeeper调用接口使用过</p>
</li>
<li><p>作业调度与工作引擎流Oozie：</p>
<ul>
<li>工作流：定义作业任务的拓扑和执行逻辑</li>
<li>协调层：</li>
</ul>
</li>
<li><p>Oozie工作原理</p>
</li>
<li><p>集群资源管理框架YARN：主从架构</p>
</li>
</ul>
<h2 id="Lession3："><a href="#Lession3：" class="headerlink" title="Lession3："></a>Lession3：</h2><ul>
<li><p>计算模型：算法+特定的数据结构（逻辑解决方案）</p>
</li>
<li><p>计算架构：在分布式机器上用软件实现计算模型（物理解决方案）</p>
</li>
<li><p>Flynn并行计算模型：</p>
<ul>
<li>两个维度：1.指令流（Instruction）   2.数据流（Data）</li>
<li>可以按照指令流和数据流划分为：<ul>
<li>SISD（Single Instruction Single Data）</li>
<li>SIMD（Single Instruction Multiple Data）</li>
<li>MISD（Multiple Instruction Single Data）</li>
<li>MIMD（Multiple Instruction Multiple Data）(最常用的架构模式，我们Hadoop的Cluster就在其中)</li>
</ul>
</li>
</ul>
</li>
<li><p>MR会慢？？？为什么？？？三个原因？？？</p>
<ul>
<li>生成大量中间文件</li>
<li>将文件存储到磁盘中</li>
<li>中间文件的远程读取</li>
</ul>
</li>
<li><p>存在内存？是否合理，是否所有的Map结果中间文件都要使用呢？</p>
</li>
</ul>
<h2 id="Lession4："><a href="#Lession4：" class="headerlink" title="Lession4："></a>Lession4：</h2><ul>
<li>应用场景：大数据分析解决的有关于图（网络）的问题。</li>
<li>图分割模型难题：<ul>
<li>图的切割</li>
</ul>
</li>
<li>BSP模型：<ul>
<li>三个部分：<ul>
<li>组件：处理器</li>
<li>路由器：实现组件通讯</li>
<li>全局时钟：用于同步全部或部分的组件</li>
</ul>
</li>
<li>超步（Superstep）:<ul>
<li>将一个大任务分解为一定数量的超步</li>
<li>压缩数据通信的时间！</li>
<li>付出代价：Barrier要求要等其他的哇！！！跑得快的要等！！！</li>
</ul>
</li>
</ul>
</li>
<li>计算过程：<ul>
<li>本地计算</li>
<li>全局通信</li>
<li>栅栏同步</li>
</ul>
</li>
<li>BSP的实现：逻辑架构 -&gt; 物理架构（开发工具包或API函数库）</li>
<li>谷歌做出来的框架就是Pregel开发包。</li>
<li><strong>BSP也是主从架构嗷！！！</strong><ul>
<li>BSPMaster</li>
<li>GroomServer</li>
</ul>
</li>
<li>图分割，使用$Hash(Node)$ % N这种模式来进行图分割。</li>
<li>两种状态：<ul>
<li>active</li>
<li>inactive</li>
</ul>
</li>
<li>所有都inactive流程就结束了嗷！</li>
<li>最大值&#x2F;最小值&#x2F;平均值&#x2F;中位数&#x2F;众数。。。都可以用这个状态机搞定嗷！！！</li>
<li>开源图并行计算框架Hama：<ul>
<li>大规模数据处理计算：<ul>
<li>大规模矩阵运算</li>
<li>机器学习（K-means Clustering , Decision Tree）</li>
<li>图计算（BFS , PageRank , SSSP , MF-MC）</li>
<li>网络算法（神经网络，社交网络分析，网络实时流量检测等）</li>
</ul>
</li>
<li></li>
</ul>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/14/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E8%AF%BE%E7%A8%8B/" data-id="cl6gepmgl006me0jq98au3pif" data-title="大数据分析课程" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%A7%E4%B8%89%E8%87%AA%E5%AD%A6/" rel="tag">大三自学</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-深入了解JVM" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/13/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3JVM/" class="article-date">
  <time class="dt-published" datetime="2021-09-13T10:54:37.000Z" itemprop="datePublished">2021-09-13</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/13/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3JVM/">深入了解JVM</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="新增了一个part叫做读书分享嗷！！！"><a href="#新增了一个part叫做读书分享嗷！！！" class="headerlink" title="新增了一个part叫做读书分享嗷！！！"></a>新增了一个part叫做读书分享嗷！！！</h1>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/13/%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3JVM/" data-id="cl6gepmgt007ye0jqholx6nlo" data-title="深入了解JVM" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%AB/" rel="tag">读书分享</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-深入学习-Java基础" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/31/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-Java%E5%9F%BA%E7%A1%80/" class="article-date">
  <time class="dt-published" datetime="2021-08-31T07:16:09.000Z" itemprop="datePublished">2021-08-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/31/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-Java%E5%9F%BA%E7%A1%80/">深入学习-Java基础</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="这个是对于Java基础的补充学习嗷！！！"><a href="#这个是对于Java基础的补充学习嗷！！！" class="headerlink" title="这个是对于Java基础的补充学习嗷！！！"></a>这个是对于Java基础的补充学习嗷！！！</h1>
        
          <p class="article-more-link">
            <a href="/2021/08/31/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-Java%E5%9F%BA%E7%A1%80/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/31/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-Java%E5%9F%BA%E7%A1%80/" data-id="cl6gepmgt0081e0jq7k0tbtgi" data-title="深入学习-Java基础" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%A7%E4%B8%89%E8%87%AA%E5%AD%A6/" rel="tag">大三自学</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-深入学习-Leetcode刷题" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/31/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-Leetcode%E5%88%B7%E9%A2%98/" class="article-date">
  <time class="dt-published" datetime="2021-08-31T07:02:57.000Z" itemprop="datePublished">2021-08-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/31/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-Leetcode%E5%88%B7%E9%A2%98/">深入学习-Leetcode刷题</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="这里是刷LeetCode-Top100中所记录的一些问题嗷！！！"><a href="#这里是刷LeetCode-Top100中所记录的一些问题嗷！！！" class="headerlink" title="这里是刷LeetCode Top100中所记录的一些问题嗷！！！"></a>这里是刷LeetCode Top100中所记录的一些问题嗷！！！</h1><h2 id="5-最长回文子串："><a href="#5-最长回文子串：" class="headerlink" title="5. 最长回文子串："></a>5. 最长回文子串：</h2><ul>
<li>强调技巧：</li>
</ul>
<ol>
<li>发现动态规划的影子</li>
<li>你必须有意识，动态规划的终点是什么。比如这道题目中，<code>bp[i][j] = s[i]==s[j] + dp[i+1][j-1]</code>，那么这个条件能够执行下去的条件是什么，对于我这一层来讲，必须<code>j-1 &gt;= i+1</code>，那反过来呢？反过来就不能够递推，也就有可能达到了重点。</li>
<li>Length + Begin的方式遍历，成功实现了一层层把房子搭起来嗷！！！</li>
<li>像这一道题目，重点还在于，搭建的时候，我们必须意识到。递推这个过程，是从下往上进行的，所以我们写代码的时候，也需要从下往上构建。所谓的从下往上构建，本质上就是把这一张二维表不断填满的过程，但是我们使用的不是递归，是动态规划，因此这个时候，就不是自己调用自己，看返回值了。而是从下往上，把整个表给构建好嗷！！！</li>
</ol>
<ul>
<li>题目：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210901212053.png" alt="image-20210901212053052"></p>
<ul>
<li>代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">longestPalindrome</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] array = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[len][len];</span><br><span class="line">        <span class="type">int</span> <span class="variable">begin</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxLen</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len &lt; <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">1</span>;length &lt;= len ;length ++)&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i+length;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= len)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (array[i]==array[j])&#123;</span><br><span class="line">                        <span class="keyword">if</span> (j-i == <span class="number">1</span>)&#123;</span><br><span class="line">                            dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            dp[i][j] = dp[i+<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        dp[i][j] = <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &amp;&amp; j - i + <span class="number">1</span> &gt; maxLen) &#123;</span><br><span class="line">                    maxLen = j - i + <span class="number">1</span>;</span><br><span class="line">                    begin = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> s.substring(begin, begin + maxLen);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>







<h2 id="19-删除链表的倒数第N个结点"><a href="#19-删除链表的倒数第N个结点" class="headerlink" title="19. 删除链表的倒数第N个结点"></a>19. 删除链表的倒数第N个结点</h2><ul>
<li>强调技巧：<ol>
<li>哑结点的加入（便于链表操作的一致性，非常有用嗷！！！）</li>
<li>例如提供链表表头，获得链表长度这种简单的代码应该形成肌肉记忆和反射。不要写成段的代码，要封装成函数嗷！！！</li>
</ol>
</li>
<li>题目：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210831172423.png" alt="image-20210831172416608"></p>
<ul>
<li><p>答案：</p>
<ul>
<li>解法一：</li>
</ul>
<p>遍历链表两次，第一次获得链表长度，第二次删除对应的结点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">removeNthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>, head);</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> getLength(head);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> dummy;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length - n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = cur.next.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> dummy.next;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getLength</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            ++length;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解法二：</li>
</ul>
<p>使用栈FILO的特性，将每一个结点入栈，出栈的时候删掉对应位置的结点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ListNode19 <span class="title function_">removeNthFromEnd2</span><span class="params">(ListNode19 head, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">ListNode19</span> <span class="variable">dummy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode19</span>(<span class="number">0</span>,head);</span><br><span class="line">      <span class="type">ListNode19</span> <span class="variable">newHead</span> <span class="operator">=</span> dummy;</span><br><span class="line">        LinkedList&lt;ListNode19&gt; linkedList = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;ListNode19&gt;();</span><br><span class="line">      <span class="keyword">while</span> (dummy!=<span class="literal">null</span>)&#123;</span><br><span class="line">            linkedList.addLast(dummy);</span><br><span class="line">            dummy = dummy.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode19</span> <span class="variable">listNode19</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (n &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            listNode19 = linkedList.removeLast();</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        listNode19.next = listNode19.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newHead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解法三：</li>
</ul>
<p>双指针，两者相隔为n，这样前面的结点到达最后一个元素的时候，后面一个结点恰好位置为要删除元素的位置嗷！！！</p>
</li>
</ul>
<h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a>70. 爬楼梯</h2><ol>
<li>题目：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210902092955.png" alt="image-20210902092955558"></p>
<ol start="2">
<li>答案：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCostClimbingStairs</span><span class="params">(<span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="comment">//记得这里下标减去1嗷！！！</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> cost.length;</span><br><span class="line">        <span class="type">int</span>[] mem = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mem[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        mem[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            mem[i] = Math.min(mem[i-<span class="number">1</span>]+cost[i-<span class="number">1</span>],mem[i-<span class="number">2</span>]+cost[i-<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mem[len];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>这里很多细节哈，前两个阶梯默认开销都是0，如果你不往上走的话，默认开销都是零。在这里，三阶以上的阶梯，只能从下一阶梯或者下两阶梯跳上来。所以这一阶梯的最小值就等于下一阶梯的最小值加上下一阶梯的开销，或者是下两阶梯的最小值，加上下两阶梯的开销嗷！！！</li>
</ul>
<h2 id="509-斐波那契数列："><a href="#509-斐波那契数列：" class="headerlink" title="509. 斐波那契数列："></a>509. 斐波那契数列：</h2><ol>
<li>做法一：动态规划：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">    temp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    temp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        temp[i] = temp[i - <span class="number">1</span>] + temp[i - <span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> temp[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>明显看出来，要计算n，那就必须建立出来n-1和n-2，n-1和n-2到了最基层，就是0和1。由于动态规划是用之前的结果推导出现在的结果，我们要从2开始，一直推导到n才能结束嗷！！！（从底层往上层推导），典型的以空间换时间，保存每一次的执行结果，供下一次循环的时候调用。特点：For从小到大，构造数组存储中间过程数据，以推导出最后的结果，公式中间用到了递推关系嗷！！！</li>
</ul>
<ol start="2">
<li>做法二：递归：</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>(fib2(n-<span class="number">1</span>) + fib2(n-<span class="number">2</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>和上面相比，一样的，用到了递推的想法，不一样的地方在于。递归并没有存储中间的数据，而是单纯关系每一层之间的关系，并将底层关系理清除了而已嗷！！！</li>
<li>由于反复入栈出栈，递归的效率并不高，但是和上面相比，没有用到额外内存，内存消耗较低。</li>
</ul>
<h2 id="1137-第-N-个泰波那契数"><a href="#1137-第-N-个泰波那契数" class="headerlink" title="1137. 第 N 个泰波那契数"></a>1137. 第 N 个泰波那契数</h2><p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210901221638.png" alt="image-20210901221638884"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution1137</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">tribonacci1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ints = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        ints[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        ints[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        ints[<span class="number">2</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">3</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            ints[i] = ints[i-<span class="number">1</span>] + ints[i-<span class="number">2</span>] + ints[i-<span class="number">3</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ints[n];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">tribonacci2</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> tribonacci2(n-<span class="number">1</span>) + tribonacci2(n-<span class="number">2</span>) + tribonacci2(n-<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>和509没啥本质区别嗷！！！</p>
<ul>
<li>但是问题凸显十分明显：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210901221750.png" alt="image-20210901221750238"></p>
<p>递归时间太长了，动规刚刚好嗷！！！</p>
<h1 id="方法论："><a href="#方法论：" class="headerlink" title="方法论："></a>方法论：</h1><h2 id="KMP："><a href="#KMP：" class="headerlink" title="KMP："></a>KMP：</h2><ul>
<li>解决的是字符串的匹配问题嗷！！！</li>
<li>暴力匹配</li>
</ul>
<h2 id="二叉树："><a href="#二叉树：" class="headerlink" title="二叉树："></a>二叉树：</h2><h3 id="递归遍历："><a href="#递归遍历：" class="headerlink" title="递归遍历："></a>递归遍历：</h3><ul>
<li>递归三部曲：<ol>
<li>确定递归参数的参数和返回值</li>
<li>确定终止条件</li>
<li><strong>单层</strong>递归逻辑</li>
</ol>
</li>
<li>传入二叉树的时候，传入根节点就可以了嗷！！！</li>
<li>主要是单层逻辑的编写还有终止条件的确定嗷！！！确定不好的话，可能就会一入递归深似海嗷！！！</li>
<li>上面这个递归的方法，对于所有的递归都适用的嗷！！！</li>
<li>这里适用三部曲进行一个分析：<ol>
<li>确定递归的参数和返回值：二叉树的递归的参数比较少。例如这里递归遍历，传入的参数就是二叉树的头指针和记录结果的一个数据结果。</li>
<li>终止条件：什么时候终止，二叉树的特殊节点显然为终止节点，就是为NULL的时候哇！！！</li>
<li>单层逻辑：前序遍历，本层逻辑，应该先遍历自己，再遍历左子树，再遍历右子树嗷！！！</li>
</ol>
</li>
<li>栈 —&gt; push root —&gt; 读取一个元素 —&gt; push right —&gt; push left —&gt; 循环…</li>
</ul>
<h3 id="非递归遍历："><a href="#非递归遍历：" class="headerlink" title="非递归遍历："></a>非递归遍历：</h3><ul>
<li>又称为迭代法嗷！！！</li>
<li>递归逻辑本质上是适用栈这种结构来模拟和实现的嗷！！！</li>
<li>前序和后续都可以使用栈来解决哦！！！（可以通过颠倒顺序来解决嗷！！！）</li>
</ul>
<h2 id="回溯算法："><a href="#回溯算法：" class="headerlink" title="回溯算法："></a>回溯算法：</h2><ul>
<li><p>回溯和递归是相辅相成的嗷！！！回溯算法在递归下面嗷！！！</p>
</li>
<li><p>回溯本质是一个纯暴力的解法嗷！！！</p>
</li>
<li><p>目标问题：</p>
<ul>
<li>组合问题</li>
<li>排列问题</li>
<li>切割问题</li>
<li>子集问题</li>
<li>棋盘问题</li>
</ul>
</li>
<li><p>如何理解回溯法：</p>
<ul>
<li><p>可以抽象为一个树形结构（N叉树）</p>
</li>
<li><p>&#96;&#96;&#96;java<br>void backtracing(params){<br>if(终止条件){<br>    &#x2F;&#x2F;收集结果<br>    return;<br>}<br>&#x2F;&#x2F;单层搜索逻辑<br>for(集合的元素集){<br>    &#x2F;&#x2F;处理节点<br>    …<br>    &#x2F;&#x2F;递归<br>    …<br>    &#x2F;&#x2F;回溯操作<br>}<br>return;<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 组合问题：</span><br><span class="line"></span><br><span class="line">- 通过理性的暴力解决不理性的暴力嗷！！！</span><br><span class="line">- 所有可以通过回溯算法解决的问题，都可以抽象为一棵树嗷！！！</span><br><span class="line">- 思路：先把组合对应的树画出来再去coding解决这个问题嗷！！！</span><br><span class="line">- 回溯三部曲：</span><br><span class="line">  1. 确定递归函数的参数和返回值</span><br><span class="line">  2. 确定递归的终止条件</span><br><span class="line">  3. 确定单层递归的逻辑（单层搜索的逻辑）</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">//二维数组result，放到全局变量而不是参数，可以让代码参数更少，更加简洁嗷！！！</span><br><span class="line">//一维数组path</span><br><span class="line">//n为要处理的数组，k为目标组合中元素的个数嗷！！！</span><br><span class="line">void backtracing(n,k,startIndex)&#123;</span><br><span class="line">    //到了叶子节点之后，就到递归终点啦！！！</span><br><span class="line">    if(path.size == k)&#123;</span><br><span class="line">        result.push(path);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    for(i=startIndex,i&lt;n;i++)&#123;</span><br><span class="line">        //这里是递归操作</span><br><span class="line">        path.push(i);</span><br><span class="line">        backtracing(n,k,i+1);</span><br><span class="line">        //这里是回溯操作</span><br><span class="line">        path.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>LeetCode第77题的代码：</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">No77Combinations</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;new Solution77().combine(4,2) = &quot;</span> + <span class="keyword">new</span> <span class="title class_">Solution77</span>().combine(<span class="number">4</span>, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution77</span> &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; result = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;java.util.List&lt;Integer&gt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">combine</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        combine2(n,k,<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">combine2</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> startIndex)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (path.size() == k)&#123;</span><br><span class="line">            result.add((List&lt;Integer&gt;) path.clone());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> startIndex; i &lt;= n; i++) &#123;</span><br><span class="line">            path.addLast(i);</span><br><span class="line">            combine2(n,k,i+<span class="number">1</span>);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="组合问题的减枝操作："><a href="#组合问题的减枝操作：" class="headerlink" title="组合问题的减枝操作："></a>组合问题的减枝操作：</h3><ul>
<li>减少时间和空间的浪费嗷！！！</li>
<li>这里主要是对于单层搜索逻辑优化：</li>
<li>剪枝一般的都是在遍历的for循环中做文章嗷！！！</li>
</ul>
<h2 id="快速排序："><a href="#快速排序：" class="headerlink" title="快速排序："></a>快速排序：</h2><ul>
<li>每次排序，将一个元素排到对应的位置上嗷！！！</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] temp = &#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        quickSort(temp,<span class="number">0</span>,temp.length-<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;temp[i] = &quot;</span> + temp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="comment">/*left -- 数组的左边界(例如，从起始位置开始排序，则l=0)</span></span><br><span class="line"><span class="comment">         *right -- 数组的右边界(例如，排序截至到数组末尾，则r=a.length-1)</span></span><br><span class="line"><span class="comment">         *array -- 待排序的数组</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> partition(array, left, right);</span><br><span class="line">            quickSort(array, left, cur-<span class="number">1</span>); <span class="comment">//递归</span></span><br><span class="line">            quickSort(array, cur+<span class="number">1</span>, right);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left ,<span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> arr[left];</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt; base)&#123;</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt; base)&#123;</span><br><span class="line">                right --;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (left &lt; right &amp;&amp; arr[left] == arr[right])&#123;</span><br><span class="line">                left ++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                swap(arr,left,right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr,<span class="type">int</span> left , <span class="type">int</span> right)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[left];</span><br><span class="line">        arr[left] = arr[right];</span><br><span class="line">        arr[right] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h2 id="动态规划："><a href="#动态规划：" class="headerlink" title="动态规划："></a>动态规划：</h2><ul>
<li>动态规划五部曲：<ul>
<li>dp数组（一维数组或者二维数组）以及下标的含义</li>
<li>递推公式</li>
<li>dp数组如何初始化</li>
<li><strong>遍历顺序</strong></li>
<li>打印dp数组</li>
</ul>
</li>
<li>注意，这里的定义以及下标的含义会直接影响到dp数组的size，这个很重要，dp[m]和dp[m+1]有的时候，<code>dp[m+1]</code>更加好用嗷！！！下标就对上了物理含义嗷！！！</li>
</ul>
<h3 id="背包问题："><a href="#背包问题：" class="headerlink" title="背包问题："></a>背包问题：</h3><ul>
<li>01背包：n种物品，每种物品只有一个</li>
<li>完全背包：n种物品，每种物品有无限个</li>
<li>n重背包：n种物品，每种物品个数各不相同</li>
<li>例题：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210914112235.png" alt="image-20210914112235066"></p>
<p>暴力解法：</p>
<p>每个物品取或者不取，可以采用回溯进行暴力搜索嗷！！！说白了就是每种情况遍历，每个物品取或者不取有两种状态，因此时间复杂度为($2^{n}$)的复杂度嗷！！！</p>
<ul>
<li><p>五部曲：</p>
<ol>
<li><p>二维dp数组：<code>dp[i][j]</code>，i表示，任取下标为[0,i]的物品，放入容量为j的背包里面的最大价值。</p>
</li>
<li><p>放与不放物品i就是这个状态之前的状态嗷！！！</p>
<p><code>dp[i][j] = dp[i-1][j]</code> — 不放物品i</p>
<p><code>dp[i-1][j-weight[i]]+ value[i]</code> — 放入物品i</p>
<p><code>dp[i][j] = Math.max&#123;上面两个嗷！！！&#125;</code></p>
</li>
<li><p>画表看情况先嗷！！！（初始化非常重要嗷！！！）</p>
</li>
<li><p>遍历（两层for循环嗷！！！）</p>
</li>
</ol>
<p>两层循环是可以颠倒的，可以通过元素推导的顺序推导出来</p>
<ol start="5">
<li>打印出dp数组最后的那个值就是答案嗷！！！</li>
</ol>
</li>
</ul>
<h2 id="单调栈："><a href="#单调栈：" class="headerlink" title="单调栈："></a>单调栈：</h2><ol>
<li>单调栈里存放的元素是什么？</li>
</ol>
<p>单调栈里只需要存放元素的<strong>下标i</strong>就可以了，如果需要使用对应的元素，直接T[i]就可以获取。</p>
<ol start="2">
<li>单调栈里元素是递增呢？ 还是递减呢？</li>
</ol>
<p><strong>注意一下顺序为 从栈头到栈底的顺序</strong>，因为单纯的说从左到右或者从前到后，不说栈头朝哪个方向的话，大家一定会越看越懵。</p>
<ul>
<li>使用单调栈主要有三个判断条件：<ol>
<li>当前遍历的元素T[i]小于栈顶元素T[st.top()]的情况</li>
<li>当前遍历的元素T[i]等于栈顶元素T[st.top()]的情况</li>
<li>当前遍历的元素T[i]大于栈顶元素T[st.top()]的情况</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] temperatures) &#123;</span><br><span class="line">    Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">    <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[temperatures.length];</span><br><span class="line">    <span class="keyword">if</span> (temperatures.length == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; temperatures.length; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (stack.size() &gt; <span class="number">0</span> &amp;&amp; temperatures[i] &gt; temperatures[stack.peek()])&#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">top</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            result[top] = i - top;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        stack.push(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>










      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/31/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-Leetcode%E5%88%B7%E9%A2%98/" data-id="cl6gepmgu0085e0jq8yjehwey" data-title="深入学习-Leetcode刷题" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%A7%E4%B8%89%E8%87%AA%E5%AD%A6/" rel="tag">大三自学</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-深入学习-数据库" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/31/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E5%BA%93/" class="article-date">
  <time class="dt-published" datetime="2021-08-31T07:02:17.000Z" itemprop="datePublished">2021-08-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/31/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E5%BA%93/">深入学习-数据库</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/31/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-%E6%95%B0%E6%8D%AE%E5%BA%93/" data-id="cl6gepmgu0088e0jq9zuv5v7i" data-title="深入学习-数据库" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%A7%E4%B8%89%E8%87%AA%E5%AD%A6/" rel="tag">大三自学</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-深入学习-操作系统" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/31/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" class="article-date">
  <time class="dt-published" datetime="2021-08-31T07:01:12.000Z" itemprop="datePublished">2021-08-31</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/31/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统深入学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="这里对于操作系统面试内容的准备课程嗷！（来自于哈工大！！！）"><a href="#这里对于操作系统面试内容的准备课程嗷！（来自于哈工大！！！）" class="headerlink" title="这里对于操作系统面试内容的准备课程嗷！（来自于哈工大！！！）"></a>这里对于操作系统面试内容的准备课程嗷！（来自于哈工大！！！）</h1><h1 id="第一章-启动-："><a href="#第一章-启动-：" class="headerlink" title="第一章(启动)："></a>第一章(启动)：</h1><h2 id="什么是操作系统："><a href="#什么是操作系统：" class="headerlink" title="什么是操作系统："></a>什么是操作系统：</h2><p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210831153205.png" alt="image-20210831153204926"></p>
<ul>
<li><p>操作系统就是在计算机硬件上包了一层软件，方便我们使用硬件的！！！</p>
</li>
<li><p>管理哪些硬件：</p>
<ul>
<li><strong>CPU</strong></li>
<li><strong>内存</strong></li>
<li><strong>终端</strong></li>
<li><strong>磁盘</strong></li>
<li><strong>文件</strong></li>
<li>网络</li>
<li>电源</li>
<li>多核</li>
</ul>
</li>
<li><p>学习什么？</p>
<ul>
<li>掌握计算机关键技术的工程师</li>
</ul>
</li>
</ul>
<h2 id="揭开钢琴的盖子："><a href="#揭开钢琴的盖子：" class="headerlink" title="揭开钢琴的盖子："></a>揭开钢琴的盖子：</h2><ul>
<li>冯诺依曼提出的存储程序的思想</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210831155455.png" alt="image-20210831155455611"></p>
<p>非常基本的尝试，将程序放入存储器，用指针指向代码，通过代码来执行。</p>
<ul>
<li><p><strong>取指执行</strong></p>
</li>
<li><p>x86结构：</p>
<ul>
<li>ROM BIOS是固化的！！！（Base Input Output System就是固化的）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210831155752.png" alt="image-20210831155752116"></p>
<ul>
<li>固化的这部分的内容，在电脑开机的时候，就会自动执行嗷！！！</li>
<li>0磁道0扇区，就是操作系统的引导扇区嗷！！！这是操作系统的第一段代码。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210831160117.png" alt="image-20210831160117500"></p>
</li>
<li><p>汇编：</p>
<ul>
<li>不像C语言，可以对于操作系统的每一处地方进行完整的控制嗷！！！</li>
</ul>
</li>
</ul>
<h3 id="启动过程汇编代码解析："><a href="#启动过程汇编代码解析：" class="headerlink" title="启动过程汇编代码解析："></a>启动过程汇编代码解析：</h3><p>  <img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210831160823.png" alt="image-20210831160822348"></p>
<p>  jmpi</p>
<p>  <img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210831160912.png" alt="image-20210831160912641"></p>
<ul>
<li>BootSect上半部分的代码把自己挪动了一下，腾出了空间嗷！！！上面的jmpi本质上就是跳到了一下段代码go，本质上还是顺序执行嗷！！！</li>
</ul>
<p>  <img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210831162103.png" alt="image-20210831162103355"></p>
<p>  因为一个传统的硬盘扇区的大小就是512个字节嗷！！！</p>
<ul>
<li>下面打印出了图标嗷！！！</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210831162631.png" alt="image-20210831162631606"></p>
<ul>
<li>下面就是跳转到了read_it部分的代码嗷！！！</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210831163048.png" alt="image-20210831163048114"></p>
<h2 id="操作系统启动："><a href="#操作系统启动：" class="headerlink" title="操作系统启动："></a>操作系统启动：</h2><ul>
<li>Setup读入OS的相关设置：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210901192015.png" alt="image-20210901192015617"></p>
<ul>
<li>Setup将操作系统代码移动到0地址嗷！！！：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210901192355.png" alt="image-20210901192355791"></p>
<ul>
<li>保护模式：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210901194203.png" alt="image-20210901194203165"></p>
<ul>
<li>上面引入了GDT的概念：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210901194335.png" alt="image-20210901194335159"></p>
<ul>
<li>地址翻译和中断处理：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210901194419.png" alt="image-20210901194419779"></p>
<ul>
<li>下面就是8这个位置对应的东西，硬件是如何解释的：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210901195144.png" alt="image-20210901195144516"></p>
<p>本质上还是跳转到了0000这个位置嗷！！！回到了操作系统代码的初始位置，开始执行操作系统的代码，启动过程到这里就结束了嗷！！！</p>
<h3 id="跳转到System模块执行："><a href="#跳转到System模块执行：" class="headerlink" title="跳转到System模块执行："></a>跳转到System模块执行：</h3><ul>
<li>Bootsect   —&gt;   Setup   —&gt;   System，我们必须严格限制它们位于内存中的位置，一切的事情都要由我们自己控制。Linux&#x2F;Makefile , Makefile十分重要嗷！！！每一个细节都要我们自己来做嗷！！！</li>
<li>操作系统被Makefile编译为了Image，这个Image通过对应的操作可以写入0磁道，0扇区的位置。然后再用Image进行操作系统的引导程序，这样才能成功嗷！！！</li>
</ul>
<h3 id="Head-s："><a href="#Head-s：" class="headerlink" title="Head.s："></a>Head.s：</h3><p>为啥叫head，因为是System第一个.s文件嗷！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210901195901.png" alt="image-20210901195901302"></p>
<ul>
<li>setup是进入保护模式，head是进入系统之后的初始化：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210901200040.png" alt="image-20210901200039982"></p>
<p>上面是建立临时的gdt表之类的，这里是正式的建立这些表格嗷！！！</p>
<p>使用了16位汇编，32位汇编，内嵌汇编等嗷！！！</p>
<ul>
<li>Head.s最后跳出来，执行main.c函数：</li>
</ul>
<p>从汇编跳到c函数嗷！！！</p>
<ul>
<li><p>汇编跳转到c函数：</p>
<ul>
<li>c -&gt; c，本质上也是编译成了汇编，底层发生了对应地址的调用的嘛！！！</li>
<li>汇编 -&gt; c，和上面没啥区别嗷！！！本质底层都是汇编嘛！！！本质上都是通过栈来实现的嗷！！！</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210901200505.png" alt="image-20210901200505479"></p>
<ul>
<li>本质上，也是压入对应的参数，然后压入c语言函数对应的位置嘛！！！</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210901200604.png" alt="image-20210901200604520"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210901200823.png" alt="image-20210901200823117"></p>
<p>上面就是把参数压入栈，然后把main返回地址压入栈嗷！！！</p>
</li>
</ul>
<h3 id="main-c和mem-init："><a href="#main-c和mem-init：" class="headerlink" title="main.c和mem_init："></a>main.c和mem_init：</h3><p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210901200928.png" alt="image-20210901200928608"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210901201254.png" alt="image-20210901201253845"></p>
<ul>
<li>summary：<ul>
<li>将操作系统从硬盘读取内存！！！（这样我们才能取指执行嗷！！！）</li>
<li>完成相应内容的初始化操作嗷！！！（操作系统管理硬件，我们要读取硬件的信息，建立对应的硬件建立数据结构，这样才能实现我们操作系统的管理功能嗷！！！）</li>
<li>bootsect —&gt; setup —&gt; head —&gt; main —&gt; mem_init</li>
</ul>
</li>
</ul>
<h1 id="第二章（接口）："><a href="#第二章（接口）：" class="headerlink" title="第二章（接口）："></a>第二章（接口）：</h1><h2 id="操作系统接口："><a href="#操作系统接口：" class="headerlink" title="操作系统接口："></a>操作系统接口：</h2><h3 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h3><ul>
<li>这里重点放在两个部分：<ul>
<li>上层怎么调用系统接口的</li>
<li>系统接口在调用过程中发生了而什么</li>
</ul>
</li>
<li>shell也是一段程序，&#x2F;bin&#x2F;sh。系统在初始化的最后一句就是启动&#x2F;bin&#x2F;sh。开启shell程序。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210902144041.png" alt="image-20210902144040576"></p>
<p>所以shell本质上就是一个无限循环的程序嗷！！！</p>
<ul>
<li>图形化界面的原理：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210902144610.png" alt="image-20210902144609652"></p>
<p>插座：C语言 + 重要函数（这个就是操作系统提供的接口嗷！！！）</p>
<ul>
<li>系统调用：<code>system_call</code>，就是与操作系统交互的接口嗷！！！</li>
<li>系统调用例子：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210902144856.png" alt="image-20210902144855322"></p>
<p>POSIX就是IEEE定义的一个标准族，如果对于系统是否提供特定功能有疑惑，直接上POSIX官方文档查找即可。</p>
<ul>
<li>总结：操作系统接口就是一堆系统调用函数嗷！！！</li>
</ul>
<h2 id="系统调用的实现："><a href="#系统调用的实现：" class="headerlink" title="系统调用的实现："></a>系统调用的实现：</h2><p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210902150024.png" alt="image-20210902150023509"></p>
<ul>
<li><p>这里不让jump，咋不让他进去的？</p>
<ul>
<li>硬件不让我们这么做的嗷！！！类似于GDT之类的，硬件非常重要嗷！！！这些功能都是硬件做的嗷！！！</li>
</ul>
</li>
<li><p>那么硬件到底干了啥呢？</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210902151100.png" alt="image-20210902151059692"></p>
<p>硬件判断是否符合优先级要求，只有符合要求的才能进得去嗷！！！</p>
<p>当OS启动Shell给用户执行的时候，CS中的CPL就是3，gdt表中对应的DPL对应的表项为0。当执行系统调用的时候变为0，回到用户态的时候又变成了3嗷！！！</p>
<ul>
<li>计算机提供了唯一的办法可以进入内核嗷！！！：<ul>
<li>设计了一些中断可以进入内核嗷！！！</li>
</ul>
</li>
<li>中断！！！：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210902151817.png" alt="image-20210902151816782"></p>
<ul>
<li>从printf到最终调用操作系统经历了什么？</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210902153853.png" alt="image-20210902153853244"></p>
<ul>
<li><p>实现细节：</p>
<ul>
<li>通过宏来实现的嗷！！！</li>
<li>上面那个右下方就是定义了一个系统调用的宏嗷！！！</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210902154509.png" alt="image-20210902154509512"></p>
</li>
<li><p><code>INT 0x80</code>如何执行？</p>
</li>
</ul>
<p>从<code>int 0x80</code>进入执行，执行完成之后再跳出来，之后继续执行嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210902155329.png" alt="image-20210902155329163"></p>
<p>本质就是把后面那张表给填好了</p>
<p>CS设置为8，addr设置为system_call</p>
<p>这里的8很熟悉啊，<code>jmpi 0 ,8</code>， CS&#x3D;8的时候刚好是写系统代码段嗷！！！</p>
<p>跳进去之后，CS变为8了，CPL变为0了，这个时候特权级就变成0了嗷！！！到了内核，就什么都可以做了嗷！！！</p>
<ul>
<li>system_call又干了什么呢？</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210902155841.png" alt="image-20210902155840557"></p>
<p>这里就从中断表中，找到了对应的中断函数的地址，转去执行中断函数了嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210902160110.png" alt="image-20210902160110392"></p>
<ul>
<li>总结：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210902160552.png" alt="image-20210902160551953"></p>
<h2 id="操作系统的历史："><a href="#操作系统的历史：" class="headerlink" title="操作系统的历史："></a>操作系统的历史：</h2><ul>
<li><p>批处理系统嗷！！！（一个作业完成，自动读入下一个作业嗷！！！）。</p>
</li>
<li><p>作业之间的切换和调度成为核心。（多线程）</p>
</li>
<li><p>分时系统   —&gt;   Unix   —&gt;   Linux，核心一直是多进程结构，多任务结构。</p>
</li>
<li><p>DOS   —&gt;   Windows</p>
</li>
<li><p>多进程   —&gt;   用户友好交互</p>
</li>
<li><p>任务：</p>
<ul>
<li><ol>
<li>掌握，实现操作系统的<strong>多进程图谱</strong>。<ul>
<li>CPU</li>
<li>内存</li>
</ul>
</li>
<li>掌握，实现操作系统的<strong>文件操作视图</strong>。<ul>
<li>文件</li>
<li>磁盘</li>
<li>I&#x2F;O</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
</ul>
<h2 id="我们的学习任务："><a href="#我们的学习任务：" class="headerlink" title="我们的学习任务："></a>我们的学习任务：</h2><ul>
<li>CPU，内存， I&#x2F;O等等</li>
</ul>
<h1 id="第三章（进程）："><a href="#第三章（进程）：" class="headerlink" title="第三章（进程）："></a>第三章（进程）：</h1><h2 id="CPU管理的直观想法："><a href="#CPU管理的直观想法：" class="headerlink" title="CPU管理的直观想法："></a>CPU管理的直观想法：</h2><ul>
<li>多进程管理明白了CPU嗷！！！</li>
<li>CPU管理的直观想法：<ul>
<li>让CPU更加高效的使用，就管理好了呀！！！</li>
</ul>
</li>
<li>CPU如何工作？自动的<strong>取值，执行</strong>嗷！！！</li>
<li>最直观想法：<ul>
<li>你把PC初值设置好了之后，让其自动执行就可以了嘛！！！CPU就会自动取值执行嗷！！！</li>
<li>有问题吗？<ul>
<li><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210903152639.png" alt="image-20210903152638769"></li>
<li>I&#x2F;O太慢了，CPU又要等I&#x2F;O。如果执行10^6的计算指令，一条I&#x2F;O指令，CPU利用率采用50%的利用率orz，所以I&#x2F;O没有管理好哇！！！</li>
</ul>
</li>
<li>如何解决？<ul>
<li>当我们遇到I&#x2F;O这样的事情的时候，让CPU去干别的事情，不要死等着呀，切到别的程序去执行哇！！！</li>
<li>让CPU忙起来哈哈哈哈哈哈！！！</li>
</ul>
</li>
</ul>
</li>
<li>多道程序交替执行，好东西啊！！！哈哈哈哈哈！！！</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210903153206.png" alt="image-20210903153205603"></p>
<ul>
<li>CPU上交替的执行多个程序被称为并发嗷！！！</li>
<li>怎么做到并发呢？<ul>
<li>我们控制PC进行切换就行</li>
<li>只修改PC就行了吗？<ul>
<li>不行哇！！！还要记录一些信息，例如寄存器的信息嗷！！！</li>
<li>运行的程序和静态的程序不一样哇！！！</li>
</ul>
</li>
</ul>
</li>
<li>引入进程的概念：<ul>
<li>进行中的程序，和静态的程序不一样嗷！！是动态的程序嗷！！！</li>
<li>将所有的信息存放在PCB中，PCB就是用于记录进程的信息的嗷！！！</li>
</ul>
</li>
</ul>
<h2 id="多进程图像："><a href="#多进程图像：" class="headerlink" title="多进程图像："></a>多进程图像：</h2><ul>
<li><p>多个进程使用CPU的图像</p>
</li>
<li><p>多进程图像从启动开始到关机结束：</p>
<ul>
<li><code>if(!fork())&#123;init();&#125;</code>，这是main.c中的最后一个调用，init执行了shell</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210904114430.png" alt="image-20210904114415503"></p>
</li>
<li><p>操作系统就是通过管理进程来管理用户对于计算机的使用的嗷！！！</p>
</li>
<li><p>多进程如何组织和存放？</p>
</li>
<li><p>感知和组织进程全靠PCB嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210904114816.png" alt="image-20210904114815939"></p>
</li>
<li><p>多进程如何交替？</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210904115302.png" alt="image-20210904115302384"></li>
</ul>
</li>
<li><p>操作系统常见的进程调度算法：</p>
<ul>
<li>FIFO</li>
<li>Priority</li>
</ul>
</li>
<li><p>交替的三个部分：</p>
<ol>
<li>队列操作</li>
<li>调度</li>
<li>切换</li>
</ol>
</li>
<li><p>把CPU中上一个进程的信息保存在对应的PCB中，然后把下一个调度的进程的信息装入CPU中，再进行下一个进程的调度嗷！！！</p>
</li>
<li><p>要用汇编进行控制嗷，C语言的控制不够精细，要用汇编实现精细的控制嗷！！！</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210904120322.png" alt="image-20210904120321875"></p>
<ul>
<li><p>多个进程相互操作的时候，可能会产生相互影响嗷！！！如果进程1，修改了进程2的东西，不就会导致出现问题吗？</p>
<ul>
<li>DPL和CPL可以吗？不可以，这些东西设计出来是为了保护操作系统的，不是用在这种场合的嗷！！！对于用户进程来说，DPL都是等于3啊…</li>
<li>如何限制进程之间的相互访问和修改？通过映射表实现多进程的地址的分离嗷！！！</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210904120720.png" alt="image-20210904120719467"></p>
</li>
<li><p>多进程如何合作？</p>
<ul>
<li>有人往共享缓冲区里放置，有其他人往共享缓冲区里防止，还有人从缓冲区里面取。由此，才实现了合作嗷！！！</li>
<li>核心在于进程同步：合理的推进顺序嗷！！！（加锁加锁加锁！！！）</li>
</ul>
</li>
</ul>
<h2 id="用户级线程："><a href="#用户级线程：" class="headerlink" title="用户级线程："></a>用户级线程：</h2><ul>
<li><p>线程：将资源和指令的执行分开。既保留了并发的特点，又避免了进程切换的代价嗷！！！</p>
</li>
<li><p>线程的存在有价值吗？</p>
<ul>
<li>多个执行顺序 + 一个地址空间是否实用？</li>
<li>例如浏览器的下载：一些时间下载，一些时间加载到页面上，本质上是一个进程嗷！！！</li>
</ul>
<p>不能让下载线程一直执行，不然用户不友好。因此先下载一段，然后再切到显示页面的线程，把页面显示出来嗷！！！</p>
<p>相比于多个进程的地址空间分离，还要拷贝内容，显然不太合适，因此线程切换是有非常大的使用价值的嗷！！！</p>
</li>
</ul>
<h3 id="Yield（线程切换）："><a href="#Yield（线程切换）：" class="headerlink" title="Yield（线程切换）："></a>Yield（线程切换）：</h3><ul>
<li><p>线程切换的骨干代码：</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210904141914.png" alt="image-20210904141914123"></li>
</ul>
</li>
<li><p>两个执行序列和一个栈：</p>
<ul>
<li>Yield会让当前进程放弃CPU嗷！！！但是ret从理论上来说，应该在本进程中切换回别的函数执行嗷！！！（这里是模拟进程切换嗷！！！）</li>
<li>return会弹栈，然后跳转到弹栈的栈顶，开始继续执行嗷！！！</li>
<li>Yield才允许跨栈，ret是不允许跨栈的嗷！！！</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210904142805.png" alt="image-20210904142804408"></p>
<ul>
<li>这里的逻辑是，A调用了B，B执行完了，应该回到A。但是这里的B执行完了之后却跳转到了D中执行，人傻了orz。</li>
</ul>
</li>
<li><p>一个栈到两个栈：</p>
<ul>
<li>切换进程的时候，首先栈也是要切换的嗷！！！要切换目标进程对应的栈嗷！！！</li>
<li>TCB是一个全局的数据结构嗷！把栈的指针会放入到全局的TCB中，在切换进程的时候，对应的栈就进行了切换嗷！！！</li>
</ul>
</li>
</ul>
<p>100 -&gt; 200 -&gt; 300 -&gt; 400 -&gt; 400执行完成之后，还是执行100中的内容：</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210904143010.png" alt="image-20210904143010418"></p>
<ul>
<li>上面哪个Yield，本质上就对于内存中的寄存器，进行了切换栈的操作嗷！！！T<strong>CB和栈相互配合，这是核心的部分嗷</strong>！！！</li>
</ul>
<p>下面这一段Yield就出现问题了，跳转到204去执行，这个时候对应的是esp&#x3D;1000的这个栈。执行完成204之后，遇到了<code>&#125;</code>，会自动从栈中弹出元素，跳转到这个元素继续执行。我们发现弹出来的元素是204 … ，这样<strong>导致204及以下的代码又被执行了一遍</strong>嗷！！！</p>
<p>切换栈的时候，根据不同的进程才去切换不同切换嗷！！！</p>
<ul>
<li>核心代码解决这个问题：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210904143320.png" alt="image-20210904143319802"></p>
<p>jmp 204这个语句，导致<code>&#125;</code>不执行，栈内保存的204这个地址始终没有弹出来orz，咱把它去掉，那么栈中的204就会弹出来啦！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210904144929.png" alt="image-20210904144929062"></p>
<p>说白了，这里的Yield函数，本质上就是把寄存器中的栈切换为了1000而已，进程的跳转，本质上是通过1000的204栈顶元素和Yield函数的<code>&#125;</code>实现的嗷！！！</p>
<p>204弹出来执行之后，再次遇到<code>&#125;</code>。再次ret弹出来104，跳转到了A中的方法继续执行，这样就实现了我们的目的嗷！！！</p>
<ul>
<li>Yield实现线程的切换 -&gt; 进程独立的栈（TCB和栈相互对应嗷！！！）加上寄存器的切换（栈的切换），实质上就实现了进程切换和顺序执行协调的功能嗷！！</li>
</ul>
<h3 id="Create（线程初始化）："><a href="#Create（线程初始化）：" class="headerlink" title="Create（线程初始化）："></a>Create（线程初始化）：</h3><p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210904145510.png" alt="image-20210904145509613"></p>
<ul>
<li>初始化无非就是完成了线程对应的栈的初始化而已嘛！！！</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210904145653.png" alt="image-20210904145653128"></p>
<ul>
<li>用户级线程切换就可以这样实现嗷！！！</li>
</ul>
<h3 id="用户级别线程："><a href="#用户级别线程：" class="headerlink" title="用户级别线程："></a>用户级别线程：</h3><p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210904150210.png" alt="image-20210904150210341"></p>
<p>上面这种模式的问题就是：虽然有非常多的用户级线程，但是对应的只有一个内核级进程，内核无法感知到用户级线程的存在。比如两个线程分别为下载和显示，对应的内核进程的下载阻塞了，但是进程１无法感知到显示进程的存在。这个阻塞，就会导致内核的进程切换，切换到了进程２，这样浏览器下载的内容还是显示不出来啊orz，导致用户体验极差orz。这就是上面这种模式的缺点嗷！！！如果系统中没有其他线程，甚至会导致CPU空转。</p>
<h3 id="内核级别线程："><a href="#内核级别线程：" class="headerlink" title="内核级别线程："></a>内核级别线程：</h3><ul>
<li>创建线程的时候，就在内核中创建，TCB存在于内核之中，内存可以感受到TCB的存在嗷！！！</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210904151417.png" alt="image-20210904151417158"></p>
<p>内核感知到一个进程中某个线程阻塞，就可以及时切换到别的线程执行嗷！！！就解决了上述的问题嗷！！！</p>
<ul>
<li>系统级别的线程的系统调用所通过的Yield方法，是用户不可见的，调度点由系统决定嗷！！！Yield如果在内核中被称为Schedule，比用户级别的线程要复杂嗷！！！</li>
</ul>
<h2 id="内核级线程："><a href="#内核级线程：" class="headerlink" title="内核级线程："></a>内核级线程：</h2><ul>
<li>进程都在内核嗷！！！为什么进程在内核呢？<ul>
<li>因为要分配资源</li>
<li>要访问系统中的一些资源</li>
<li>因此进程作为资源分配的基本单位，在内核中嗷！！！</li>
</ul>
</li>
<li>多核（这个概念和多处理器还有点区别）要想充分发挥作用：<ul>
<li>就要使用线程嗷！！！</li>
<li>多个线程可以使用多个核，这样才能保证多核的资源被充分利用嗷！！！</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210905150331.png" alt="image-20210905150322412"></p>
<p>可以看出来，所谓的多核是在同一个MMU和Cache的基础上，并行运行的多个CPU。这就保证了，在进程所分配的资源，例如MMU不变的基础上，能够同时运行多个进程，榨干多核的处理能力嗷！！！</p>
<p>看到左图中的核心级线程，只有核心级线程能够被操作系统中的多核感知，被多核调度，并发并行执行，这也是内核级线程的优点嗷！！！多进程，用户级线程都做不到，但是核心级线程做的到嗷！！！</p>
<ul>
<li>从用户级别线程引申出来：<ul>
<li>切换到内核，在内核栈中分配空间，才能够创建内核级别的线程嗷！</li>
<li>两个栈，是用户级线程的核心。两套栈，是内核级别线程的核心嗷！！！</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210905150907.png" alt="image-20210905150907086"></p>
<p>内核级别的TCB切换的时候，用户栈和内核栈，这一套栈都要切换嗷！！！</p>
<ul>
<li>用户栈和内核栈之间的关联：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210905151158.png" alt="image-20210905151157318"></p>
<ul>
<li>带着中断进入到核心级线程的例子：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210905151512.png" alt="image-20210905151511366"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210905152031.png" alt="image-20210905152031266"></p>
<p>以前用户栈的切换就是切换用户栈，现在是切换内核栈，由于内核栈和用户栈紧紧绑定，就实现了用户栈线程之间的切换嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210905152404.png" alt="image-20210905152404310"></p>
<p>上面就是内核态线程切换的核心代码嗷！！！通过中断进入内核就是通过INT 0x80来实现的嗷！！！</p>
<ul>
<li>内核switch_to五段论：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210905152701.png" alt="image-20210905152700656"></p>
<p>上面这个过程就是switch_to的整个流程嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210905152859.png" alt="image-20210905152858760"></p>
<ul>
<li>手动创建内核级别线程：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210905153118.png" alt="image-20210905153117905"></p>
<p>可以看出来，这里的Thread线程的创建，无非是在模拟我们的。</p>
<ul>
<li>对比图嗷！！！</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210905153734.png" alt="image-20210905153734361"></p>
<h2 id="内核级别的代码实现："><a href="#内核级别的代码实现：" class="headerlink" title="内核级别的代码实现："></a>内核级别的代码实现：</h2><ul>
<li>回顾：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210906101359.png" alt="image-20210906101344913"></p>
<p>上图就是我们常说的五段论，用户只能看到内核之上的用户线程的切换。但是实际上，加起来一共进行了五次大的切换嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210906101803.png" alt="image-20210906101801961"></p>
<p>fork本质上引起了0x80这个中断，在0x80执行完成之后，才成功进入到内核。在执行0x80的时候，PC还是指向mov这条指令的。就在这个时候，ret被设置好，并且硬件帮助我们自动把SS和SP和用户栈建立了关联嗷！！！</p>
<p>ret下面就是system_call，执行中断处理函数，因此接着执行system_call函数嗷！！！</p>
<ul>
<li>sys_fork和类似于sys_write这种：</li>
</ul>
<p>不一定能够正常执行，有可能被其他的线程阻塞，这个时候，就应该重新调度嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210906102523.png" alt="image-20210906102522309"></p>
<p>下面那个cmp1和counter的计算，是时间片的判断，如果时间片用光了，也要触发重新调度的嗷！！！</p>
<p>接下来，ret_from_sys_call就会执行中断返回函数嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210906102856.png" alt="image-20210906102855660"></p>
<ul>
<li><p>可以看到reschedule本质上就是将ret那个函数的地址压栈，jmp _schedule是调用了一个schedule的c函数。在C函数的最后，有一个<code>&#125;</code>。默认就是将栈中的ret_from_sys_call弹出来，执行这一段函数。本质上就是在执行完成schedule之后，执行系统调用返回函数嗷！！！</p>
</li>
<li><p>中断入口是一堆push，中断出口是一堆pop</p>
</li>
<li><p>五段论中的schedule和中断出口：</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210906104927.png" alt="image-20210906104926599"></p>
<ul>
<li>schedule中的switch_to函数：</li>
</ul>
<p>基于TSS的切换：不常用，一句长跳转指令非常方便，但是执行效率特别低，所以现在用的都是kernel</p>
<p>TR是固有的寄存器，选择描述符，指向TSS描述符。TSS就类似于之前的CS。</p>
<p>TSS就是类似于某个线程某个状态的所有寄存器的快照，切换就是把整个TSS状态<code>扣</code>在寄存器上，由此就完成了切换嗷！！！</p>
<p>这一条指令会非常长，没有办法变成指令流水，无法适用硬件的加速功能等嗷！！！</p>
<p>切换步骤：</p>
<ol>
<li>将当前CPU的内容，由当前TR指向的TSS，将快照保存在TSS中</li>
<li>核心线程切换的时候，会将TR指向新的线程的TSS描述符</li>
<li>将新的TSS描述符中指向的新的TSS中的内容，扣到CPU的每一个寄存器中，这样就完成了线程栈的切换嗷！！！</li>
</ol>
<p>INT —&gt; Switch_to(Long_Jump) —&gt; IRET（完成用户栈的切换嗷！！！）</p>
<p>只要做好TSS和TCB，就能够非常方便的进程切换嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210906142526.png" alt="image-20210906142525274"></p>
<p>TSS实质上就是TCB中的一个子段嗷！！！</p>
<h3 id="ThreadCreate："><a href="#ThreadCreate：" class="headerlink" title="ThreadCreate："></a>ThreadCreate：</h3><ul>
<li>TCB要有，然后再把TSS做好，就能够成功嗷！！！</li>
<li><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210906214948.png" alt="image-20210906214948408"></li>
<li>copy_process的细节：创建栈：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210906215326.png" alt="image-20210906215326381"></p>
<p>不能用malloc，malloc是用户级代码，get_free_page才是内核级代码嗷！！！</p>
<p>创建TCB，创建用户栈，创建内核栈，关联两个栈：</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210906215737.png" alt="image-20210906215736884"></p>
<p>注意，子进程创建的时候，eax寄存器中的值被置为0了。mov的过程中，就会把res的值赋予为0，这就有了我们经典<code>if(!fork())</code>中那个0的由来嗷！！！</p>
<p>父进程为啥不是0呢？可以看看代码嗷！！！</p>
<ul>
<li>如何执行我们想要的代码？</li>
</ul>
<p>也就是子进程在exec(cmd)后，如何跳转并执行我们规定子进程执行的代码：</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210907215731.png" alt="image-20210907215724479"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210907220043.png" alt="image-20210907220042879"></p>
<ul>
<li>summary：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210907220157.png" alt="image-20210907220157298"></p>
<h2 id="操作系统的那颗“树”："><a href="#操作系统的那颗“树”：" class="headerlink" title="操作系统的那颗“树”："></a>操作系统的那颗“树”：</h2><ul>
<li><p>CPU -&gt; 要让CPU好好运转嗷！！！ -&gt; 跳转 -&gt; 如何跳转？</p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210908090252.png" alt="image-20210908090148849"></p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210908090300.png" alt="image-20210908090210570"></p>
</li>
<li><p>一直用户态怎么办？</p>
<ul>
<li>引入内核态切换</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210908090920.png" alt="image-20210908090919731"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210908091018.png" alt="image-20210908091017731"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210908091048.png" alt="image-20210908091048526"></p>
<ul>
<li>switch_to的切换：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210908091156.png" alt="image-20210908091155977"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210908091222.png" alt="image-20210908091221950"></p>
<ul>
<li>如何打出B？</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210908091436.png" alt="image-20210908091435950"></p>
<p>那就要中断才能进入内核，如何调用schedule函数来进入内核呢？才能够切换到B哇！！！</p>
<p>这个中断怎么整？？？ -&gt; INT 0x80，如何引发这个中断呢？ -&gt; 时钟中断！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210908091714.png" alt="image-20210908091713455"></p>
<ul>
<li>接下来？</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210908091823.png" alt="image-20210908091822636"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210908091906.png" alt="image-20210908091905855"></p>
<ul>
<li>是不是还要中断才能打A哇？？？</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210908091940.png" alt="image-20210908091939670"></p>
<p><img src="C:\Users\Alexander\AppData\Roaming\Typora\typora-user-images\image-20210908092014611.png" alt="image-20210908092014611"></p>
<h2 id="CPU调度策略："><a href="#CPU调度策略：" class="headerlink" title="CPU调度策略："></a>CPU调度策略：</h2><ul>
<li>基本方法：<ul>
<li>FIFO</li>
<li>Priority</li>
</ul>
</li>
<li>算法应该让什么更好？<ul>
<li>面对客户：用户满意</li>
<li>面对进程：进程满意</li>
</ul>
</li>
<li>怎么让进程满意？<ul>
<li>尽快结束任务</li>
<li>操作尽快响应</li>
<li>系统内耗时间少：吞吐量</li>
</ul>
</li>
<li>总原则：专注于任务执行，合理分配任务</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210908202232.png" alt="image-20210908202225064"></p>
<p>比如下面两个，I&#x2F;O的优先级就会比CPU要高嗷！！！I&#x2F;O尽早调度运行，使用一段时间后启动I&#x2F;O。这个时候，I&#x2F;O和CPU就可以充分并行，充分利用各种资源嗷！！！</p>
<p>折中和综合让操作系统复杂，但是有效的系统又要求尽量的简单orz。。。。。</p>
<ul>
<li>常见CPU调度算法：<ul>
<li>FCFS</li>
<li>SJF（引入优先级）</li>
<li>RR（引入时间片）</li>
<li>优先级 -&gt; 动态优先级</li>
</ul>
</li>
</ul>
<h2 id="一个实际的schedule函数："><a href="#一个实际的schedule函数：" class="headerlink" title="一个实际的schedule函数："></a>一个实际的schedule函数：</h2><ul>
<li>实际的schedule函数是怎么做的？</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210909190203.png" alt="image-20210909190147738"></p>
<p>基于counter的优先级和时间片嗷！！！</p>
<ul>
<li>counter如何修改：<ul>
<li>就绪态进程的counter都用完了</li>
<li>下面这个就是counter的处理，处于阻塞状态的进程回来之后，优先级一定要高一些嗷！！！</li>
</ul>
</li>
<li>counter是个多面派：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210909190631.png" alt="image-20210909190631165"></p>
<p>当counter（时间片）的值减少到了0，就自动引发schedule函数嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210909190808.png" alt="image-20210909190807897"></p>
<p>I&#x2F;O就是前台进程的特征，优先级也比只用CPU的线程的优先级要高嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210909191359.png" alt="image-20210909191358546"></p>
<h2 id="进程同步和信号量："><a href="#进程同步和信号量：" class="headerlink" title="进程同步和信号量："></a>进程同步和信号量：</h2><ul>
<li>信号 —&gt; 信号量（生产者消费者进程的合作嗷！！！）</li>
<li>信号能够表达的信息太少了，因此引入了信号量来记录整体的信息嗷！！！</li>
<li>例如只有唤醒信号，那我是唤醒呢？还是别的咋整呢？？？</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210909192947.png" alt="image-20210909192946248"></p>
<ul>
<li>信号量如何工作？</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210909193326.png" alt="image-20210909193325787"></p>
<p>信号量成功记录了系统中的资源数，在信号量的基础上，信号得以正常的发送和沟通，信号量yyds！！！</p>
<ul>
<li>习题：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210909193658.png" alt="image-20210909193658295"></p>
<ul>
<li>信号量定义：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210909194958.png" alt="image-20210909194958376"></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">V(semaphore s)</span><br><span class="line">&#123;</span><br><span class="line">	s.value++;</span><br><span class="line">	if(s.value &lt;= 0)&#123;</span><br><span class="line">		wakeup(s.queue);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>解决生产者-消费者问题（你电特色）：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210909202625.png" alt="image-20210909202624172"></p>
<p>什么时候会停下来？特别有意思</p>
<p>mutex为互斥信号量，一次只能有一个人进去。</p>
<p>empty为缓冲区信号量，用于记录系统资源。</p>
<p>在兔兔看来，信号量就是用于表示系统中争抢占用的共享资源的。特殊用法就是作为mutex（只能有一个人进去对于资源进行修改嗷！！！），控制进程间的顺序。</p>
<h2 id="信号量临界区保护："><a href="#信号量临界区保护：" class="headerlink" title="信号量临界区保护："></a>信号量临界区保护：</h2><ul>
<li>不好保护出现的问题：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210911214538.png" alt="image-20210911214530293"></p>
<p>并不是变成造成的错误，而是多个进程并发操作共享数据引起。</p>
<p>错误和调度顺序有关，难于发现和调试</p>
<ul>
<li>直观想法：<ul>
<li>改之前上锁哇！！！（类似于数据的操作）</li>
<li>一段代码一次只允许一个进程进入嗷！！！</li>
</ul>
</li>
<li>临界区：<ul>
<li>一次只允许一个进程进入的该进程的那一段代码</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210911215321.png" alt="image-20210911215321150"></p>
<ul>
<li>进入区和退出区才是核心代码嗷！！！怎么写这些代码是个大问题！！！</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210911215551.png" alt="image-20210911215550597"></p>
<ul>
<li>轮换法：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210911215610.png" alt="image-20210911215610501"></p>
<p>可以实现，但是不满足空闲让进和有限等待的原则嗷！！！</p>
<ul>
<li>标记法：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210911220010.png" alt="image-20210911220009925"></p>
<p>但是这个可能有问题，互斥可能会出问题嗷！！！</p>
<ul>
<li>非对称标记：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210911220110.png" alt="image-20210911220110172"></p>
<ul>
<li>Peterson算法：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210911220324.png" alt="image-20210911220324123"></p>
<p>满足互斥条件（可以通过反证法来证明，特别好用！！！）</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210911220226.png" alt="image-20210911220226407"></p>
<p>三个条件都满足嗷，特别有意思嗷！！！</p>
<ul>
<li>多个进程咋办捏？</li>
</ul>
<p>仍然可以<strong>标记+轮转</strong>进行结合来解决这个问题嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210911220703.png" alt="image-20210911220702911"></p>
<p>就有点像排队取号考驾照，里面的人出来了，你手上有号，并且考场是空的，你才能进去考试嗷！！！</p>
<ul>
<li>太复杂了，有没有简单的方法？硬件yyds，硬件和软件相互合作，协同设计，能够更加有效哦！</li>
</ul>
<p>从硬件角度来看，软件通过schedule，调用中断，才能够实现线程或者进程的切换。老子直接从硬件上不让你中断，你能咋地？？？因此先从硬件上把中断关了，让程序正常执行，执行完成之后再开中断，这就是硬件的做法嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210911221902.png" alt="image-20210911221901996"></p>
<p>单个CPU是这样，但是如果是多CPU的，a在A的CPU上，b在B的CPU上。A关中断了，但是管不到B，那还是gg，会造成中断。多核情况下会不好使哦！！！</p>
<ul>
<li>硬件的原子指令：</li>
</ul>
<p>锁就是一个信号量嗷！！！！（信号量的保护套娃了orz）</p>
<p>硬件能不能内部就直接完成信号量的保护呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210912145346.png" alt="image-20210912145345681"></p>
<p>多CPU可以吗？？？</p>
<p>个人思考：可以，上面的关中断那种方式是针对于CPU来说的。但是多个CPU可以修改同一个存储单元地址，导致了问题的发生。这里原子指令，无论是哪一个CPU去执行这条指令，只有一个原子指令可以执行成功。确实，不可以被打断，但是没有说不可以等待呀！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210912145723.png" alt="image-20210912145723225"></p>
<p>说白了就是硬件这部分处理的地方不一样，一个是单独的CPU上，会有冲突，还有一个是作用在总线上，抢夺资源，因此可以实现多CPU的原子性操作的功能嗷！！！</p>
<ul>
<li>summary：</li>
</ul>
<p>用临界区去保护信号量，用信号量来实现同步</p>
<h2 id="信号量的代码实现："><a href="#信号量的代码实现：" class="headerlink" title="信号量的代码实现："></a>信号量的代码实现：</h2><ul>
<li>sem_open和sem_wait：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210912150404.png" alt="image-20210912150403560"></p>
<ul>
<li>lock_buffer：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210912150857.png" alt="image-20210912150856837"></p>
<ul>
<li>世界上最隐蔽的队列嗷！！！</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210912151217.png" alt="image-20210912151216707"></p>
<ul>
<li>唤醒这个队列中的东西</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210912151340.png" alt="image-20210912151340234"></p>
<p>和上面就是对应的，将进程的状态改为就绪态（0），就可以了嗷！</p>
<ul>
<li>唤醒之后会从刚刚停下的地方往后执行，也就是刚刚上面schedule()方法之后往后执行：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210912151507.png" alt="image-20210912151507441"></p>
<p>通过这种队列不断套娃往前唤醒的机制，实质上把队列中的每一个元素全部都唤醒了嗷！！！</p>
<p>这又解释了，上面为啥是while嗷！！！</p>
<ul>
<li>为啥while？</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210912151627.png" alt="image-20210912151626890"></p>
<p>所有进程全部唤醒，然后由schedule()来决定谁来执行嗷（优先级高的进程先执行），其他的进程再次判断资源（while），再次进行阻塞哦！！！</p>
<p>所有进程唤醒之后先抢一下资源，再去睡眠，这是一个循环往复的过程。因此这里使用的是while而不是if嗷！！！</p>
<p>特点：信号量不需要有负数，因为不需要记录有多少个进程在等待，我有个队列嘛，反正每次全部唤醒。队列中没人自然就不用唤醒了呀！！！while这个东西就弥补了没有记录数量的缺陷嗷！！！</p>
<h2 id="死锁处理："><a href="#死锁处理：" class="headerlink" title="死锁处理："></a>死锁处理：</h2><p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210912152644.png" alt="image-20210912152644422"></p>
<ul>
<li><p>原因：</p>
<ul>
<li>互斥使用</li>
<li>不可抢占</li>
<li>请求和保持</li>
<li>环路等待</li>
</ul>
</li>
<li><p>死锁处理：</p>
<ul>
<li>死锁预防：<ul>
<li>破坏死锁出现的条件</li>
</ul>
</li>
<li>死锁避免：<ul>
<li>检测某个资源请求，造成死锁就拒绝</li>
</ul>
</li>
<li>死锁检测+恢复：<ul>
<li>“灭火”，发现死锁就检查并且处理</li>
</ul>
</li>
<li>死锁忽略：<ul>
<li>不管</li>
</ul>
</li>
</ul>
</li>
<li><p>预防：</p>
<ol>
<li>一次性申请所有需要的资源</li>
<li>资源必须按照资源顺序进行</li>
</ol>
<p>总会有浪费，不推荐使用嗷！！！</p>
</li>
<li><p>避免：</p>
<ol>
<li>银行家算法</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210912154048.png" alt="image-20210912154048285"></p>
<p>效率太低了orz，可以考虑采用先发现问题再处理的方式进行处理嗷！！！</p>
<ul>
<li>定时检测或者是发现资源利用率低的时候检测嗷！</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210912154426.png" alt="image-20210912154426529"></p>
</li>
<li><p>死锁检测+恢复：</p>
<ul>
<li>例如上面这个，一段时间利用银行家算法进行一次检测或当CPU利用率低的时候进行检测，来减少消耗嗷！！！</li>
</ul>
</li>
<li><p>死锁忽略：</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210912154739.png" alt="image-20210912154738893"></p>
<p>死锁忽略代价小，对于Windows和Linux来说，重启就解决了，很方便。而且编程也很困难，因此这种方式的适用性还是非常好的嗷！！！！</p>
<p>实际的开发过程中使用这种偏多嗷！！！</p>
<h1 id="第四章（内存管理）："><a href="#第四章（内存管理）：" class="headerlink" title="第四章（内存管理）："></a>第四章（内存管理）：</h1><h2 id="内存使用和分段："><a href="#内存使用和分段：" class="headerlink" title="内存使用和分段："></a>内存使用和分段：</h2><ul>
<li>如何让内存用起来：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210913091557.png" alt="image-20210913091557376"></p>
<p>将程序放入内存中跑起来，内存就用起来了嘛！！！</p>
<ul>
<li>相对地址需要转换：</li>
</ul>
<p>注意哈：指令<code>call 40</code>本质上是直接往地址总线上发40，访问40地址的这个东西，是行不通的嗷！！！（把40赋值给IP了嗷！！！）</p>
<p>不能仅仅把程序搬过来！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210913092127.png" alt="image-20210913092127305"></p>
<p>如果这样的话，就算搬到1000位置，还是废的，执行call之后还是跳转到40，这个地址空间去执行了嗷！！！</p>
<ul>
<li>逻辑地址（逻辑地址） -&gt; 物理地址：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210913092350.png" alt="image-20210913092349265"></p>
<ul>
<li>什么时候完成重定位：<ul>
<li>编译时：除非能够确定嗷！！！不然编译的时候一般是不能确定位置的，因为系统是动态的而不是静态的嗷！！！</li>
<li>载入时：更加灵活，根据哪一段空闲，再去进行基址的转化哦！！！（虽然会稍微慢一点嗷！！！）</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210913092554.png" alt="image-20210913092554092"></p>
<ul>
<li><p>载入的时候还要移动咋办orz：</p>
<ul>
<li>交换的概念：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210913092710.png" alt="image-20210913092709743"></p>
<p>内存宝贵，内外交换</p>
<ul>
<li>运行时重定位！！！</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210913093039.png" alt="image-20210913093038625"></p>
<ul>
<li>这种情况下，编译不用动任何内容，找到内存中的空位，把起始地址赋予PCB，然后就可以把程序放进去，就可以跑了嗷！！！</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210913093815.png" alt="image-20210913093815025"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210913093848.png" alt="image-20210913093848069"></p>
</li>
<li><p>引入分段：</p>
<ul>
<li>是将整个程序一起载入内存中吗？</li>
<li>若干部分（段）组成，每个段都有各自的特点，用途</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210913095333.png" alt="image-20210913095332604"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210913100344.png" alt="image-20210913100343750"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210913100544.png" alt="image-20210913100543730"></p>
<ul>
<li>每个PCB中都有一个LDT，LDT结合GDT就能够正确重定位到跳转指令的位置嗷！！！</li>
<li>GDT就是段表寄存器</li>
</ul>
<h2 id="内存分区与分页："><a href="#内存分区与分页：" class="headerlink" title="内存分区与分页："></a>内存分区与分页：</h2><ul>
<li>可变分区的管理过程：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210913163242.png" alt="image-20210913163241803"></p>
<p>内存可以分配和回收嗷！！！这个东西我比较清楚，就不写了嗷！！！</p>
<ul>
<li><p>适配算法：</p>
<ul>
<li>最佳适配</li>
<li>最差适配</li>
<li>首先适配（快）</li>
</ul>
</li>
<li><p>分页：</p>
<ul>
<li>一个进程最多浪费4K嗷，如果一页的大小是4K的话</li>
<li>好处：不用进行紧缩嗷，物理内存浪费少了嗷！！！</li>
<li>用户希望分段，物理内存希望分页，因此出现了段页式嗷！！！</li>
</ul>
</li>
<li><p>CR3就是页表寄存器</p>
</li>
<li><p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210913170522.png" alt="image-20210913170521878"></p>
</li>
</ul>
<p>实际上这个操作都是MMU这个硬件做的嗷！！！自动帮助我们完成从偏移地址到对应页的地址转换嗷！！！</p>
<p>MMU自动根据CR3就去计算，实际的物理地址。查页表，重定位，进行计算嗷！！！</p>
<h2 id="多级页表与快表："><a href="#多级页表与快表：" class="headerlink" title="多级页表与快表："></a>多级页表与快表：</h2><ul>
<li>分页问题：<ul>
<li>页小了，页表就大了orz，内存高效利用 -&gt; 页小 -&gt; 页表大</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210914151647.png" alt="image-20210914151646894"></p>
<ul>
<li>尝试：只存放用的页！！！内存中只存用到的页嗷！！！页表目的：根据页号找到物理页框号。</li>
<li>页表查找：</li>
</ul>
<p>页表长，顺序查找某个页号，那很费时间啊orz</p>
<p>怎么解决：折半查找！！！（还是时间长啊orz）</p>
<p>页号连续，查到第一个之后，之后根据每一行的大小进行偏移，可以很快找到嗷！！！</p>
<p>但是问题：页表连续，即使没有用到的，也要占住内存中的位置才能方便我们查找，how？</p>
<p><strong>既要连续又要让页表占用内存少？？？</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210914152222.png" alt="image-20210914152222406"></p>
<ul>
<li><p>多级页表的诞生：</p>
<ul>
<li>书的章目录和节目录来类比嗷！！！</li>
</ul>
<p>把中间分成大段，然后根据不同的章节，再去</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210914152901.png" alt="image-20210914152900721"></p>
<p>只用看章，不用看其中的很多节，只看我对应要看的节。因此省了很多内存嗷！！！（专门拿了一个4K的页面出来作为目录嗷！！！）</p>
<p>空间上高效，时间上呢？会有损耗！！！会增加一级，就会多访问一次内存嗷！！！时间上就会有所损耗嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210914153333.png" alt="image-20210914153333303"></p>
<p>引入了快表这个概念嗷！！！</p>
<ul>
<li>快表：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210914153504.png" alt="image-20210914153503684"></p>
<p>快表+多级页表的结构：既节省了时间，又节省了空间嗷！！！</p>
<p>TCB存在寄存器中嗷！！！速度特别快嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210914153730.png" alt="image-20210914153729928"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210914153809.png" alt="image-20210914153808364"></p>
<p>正因为程序具有这种局部性，所以这种方式才能够生效嗷！！！</p>
<h2 id="段页结合的实际内存管理："><a href="#段页结合的实际内存管理：" class="headerlink" title="段页结合的实际内存管理："></a>段页结合的实际内存管理：</h2><ul>
<li>程序员用段 ， 物理内存（硬件）需要用页 ， 因此产生了段页结合的方法嗷！！！</li>
<li>段隔开了地址空间，再映射到实际的物理页上！！！</li>
</ul>
<p>段 -&gt; <strong>虚拟内存</strong> -&gt; 物理页</p>
<ul>
<li>段页同时存在：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210915091146.png" alt="image-20210915091138167"></p>
<h3 id="虚拟地址："><a href="#虚拟地址：" class="headerlink" title="虚拟地址："></a>虚拟地址：</h3><ul>
<li>这个概念是在段和页揉在一起的情况下引出的，隐藏了物理地址上页的分配，从而为用户提供段的服务嗷！！！</li>
<li>透明的那一层映射，干了什么？</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210915091810.png" alt="image-20210915091809748"></p>
<ul>
<li>内存管理的核心就是内存分配，所以将程序放入内存</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210915092544.png" alt="image-20210915092542861"></p>
<h3 id="内存故事："><a href="#内存故事：" class="headerlink" title="内存故事："></a>内存故事：</h3><ul>
<li>从fork进程开始探究整个过程：</li>
</ul>
<p>分配虚存，建段表</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210915093011.png" alt="image-20210915093009849"></p>
<ul>
<li>虚存简化：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210915093647.png" alt="image-20210915093646415"></p>
<ul>
<li>分配内存，建页表：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210916152341.png" alt="image-20210916152340071"></p>
<p>from是父进程的页表的地址</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210916152642.png" alt="image-20210916152640781"></p>
<p>上面这里只是找到了哪一章，接下来要找是哪一节（段页式），因此还需要一次转换嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210916152948.png" alt="image-20210916152947493"></p>
<ul>
<li>操作拷贝：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210916153134.png" alt="image-20210916153133419"></p>
<p>注意这里，写时复制！！！</p>
<ul>
<li>复制完之后，整体架构：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210916153242.png" alt="image-20210916153241784"></p>
<p>可以看出来，这里fork之后，创建了进程的LDT，并且分配了虚拟内存和页表给进程，指向了父进程实际的内存空间，至少能跑了orz</p>
<h4 id="写时复制："><a href="#写时复制：" class="headerlink" title="写时复制："></a>写时复制：</h4><ul>
<li>写时复制！！！子进程如何体现？？？</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210916153934.png" alt="image-20210916153933436"></p>
<p>还记得前面子进程和父进程指向一样的地方吗？为啥设置为只读，就是为了这里的写时复制，多个进程在内存中的时候。写时复制就能够帮助我们消除多个进程fork的影响！！！就能够独立运行嗷！！！</p>
<h2 id="内存换入-请求调页："><a href="#内存换入-请求调页：" class="headerlink" title="内存换入-请求调页："></a>内存换入-请求调页：</h2><ul>
<li>虚拟内存！！！<ul>
<li>用户眼里的内存：</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210917150500.png" alt="image-20210917150500015"></p>
<p>用户不知道后面的细节，由操作系统完成映射，为用户提供“假象”</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210917150754.png" alt="image-20210917150753439"></p>
<p>通过换入来实现展现给用户的假象嗷！！！</p>
<ul>
<li>请求调页：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210917151042.png" alt="image-20210917151042058"></p>
<p>虚拟地址和虚拟内存有啥关系呢？虚拟地址的取值范围就是虚拟内存的范围，给用户的感受就是这些虚拟内存（虚拟地址）我可以随意使用。至于虚拟地址映射到哪个真正的物理地址上，不需要咱操心嗷！！！</p>
<p>上面告诉了我们页表可以映射到物理内存上，这里告诉了我们，当页表和物理内存不是一一对应的时候，操作系统是如何实现的（通过请求调页实现的嗷！！！）</p>
<ul>
<li>发现缺页了怎么办？？？</li>
</ul>
<p>中断！！！转去执行页错误处理程序嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210917152901.png" alt="image-20210917152900875"></p>
<ul>
<li>问题：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210917152916.png" alt="image-20210917152916071"></p>
<p>答案肯定是C哇！！！整个段也太浪费了叭呜呜，又不一定都用的上orz！！！</p>
<h3 id="请求调页故事："><a href="#请求调页故事：" class="headerlink" title="请求调页故事："></a>请求调页故事：</h3><ul>
<li><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210917153212.png" alt="image-20210917153211895"></li>
</ul>
<p>这里的14中断号就代表着请求调页嗷！！！</p>
<ul>
<li>处理中断page fault：</li>
</ul>
<p>将当前栈中的内容保存：</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210917153411.png" alt="image-20210917153411393"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210917153434.png" alt="image-20210917153434299"></p>
<ul>
<li>这里的_do_no_page干了什么？</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210917153703.png" alt="image-20210917153703336"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210917153737.png" alt="image-20210917153737196"></p>
<ul>
<li>建立虚拟页与物理页的映射：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210917153921.png" alt="image-20210917153920679"></p>
<ul>
<li>这些都做完了，给用户的感觉就是：你访问0-4G的内存都有东西嗷！！！我一个人拥有了4G的内存呢！！！</li>
</ul>
<h2 id="内存换出："><a href="#内存换出：" class="headerlink" title="内存换出："></a>内存换出：</h2><ul>
<li>上面的get_free_page有问题，不一定总是能够获得新的空闲页嗷！！！：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210917183841.png" alt="image-20210917183840758"></p>
<ul>
<li><p>换出算法：</p>
<ol>
<li>FIFO：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210917184043.png" alt="image-20210917184043015"></p>
</li>
<li><p>评价准则：缺页次数！！！</p>
</li>
<li><p>换出算法：</p>
<ol start="2">
<li>MIN页面置换：</li>
</ol>
<p>最优的情况！！！最好情况的置换！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210917184230.png" alt="image-20210917184229666"></p>
<p>可惜，预测未来很困难，MIN不现实啊orz</p>
</li>
<li><p>换出算法：</p>
<ol start="3">
<li>LRU页面置换：</li>
</ol>
<p>用过去来预测未来，用到了程序的局部性嗷！！！</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210917184609.png" alt="image-20210917184608578"></p>
<p>效果非常不错嗷！！！</p>
<ul>
<li>如何实现？<ul>
<li>想法：时间戳（time stamp）</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210917184729.png" alt="image-20210917184728632"></p>
<p>但是这个算法放入实际的操作系统中，是非常困难的嗷！！！维护一张大表，还有可能出现溢出的情况，计算机负担非常重orz。玩一玩可以，不可行！！！</p>
<p>另外的想法：页码栈：</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210917185041.png" alt="image-20210917185041378"></p>
<p>也是和上面一样，多次修改，实现代价非常大嗷！！！</p>
<p>LRU准确实现用的少嗷！！！</p>
<ul>
<li>LRU的近似实现（最近没有使用） - 将时间计数变为是与否：</li>
</ul>
<p>就是我们上课讲的CLOCK算法嗷！！！（Clock Algorithm）</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210917185253.png" alt="image-20210917185252603"></p>
<p>SCR算法：Second Chance Replacement，这个R标志位甚至可以给MMU，让MMU查页表的时候就自动对于其进行修改嗷！！！</p>
<ul>
<li>Clock算法的分析和改造：</li>
</ul>
<p>如果缺页很少？？？如果缺页少，慢慢的从０变为１，一次全清为０，然后接下来不就是遍历换出，那就退化成了FIFO算法了嗷！！！</p>
<p>原因：指针转的太慢了，记录了太长时间的历史信息</p>
<p>解决方法：定时清除R位置。再来一个扫描指针清除为0，这样就可以表达：从清除为0到现在这一段时间都没有使用嗷！！！（最近最少使用！！！<code>准确来说是最近没有使用orz</code>）</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210917190122.png" alt="image-20210917190121968"></p>
<ul>
<li>策略有了，还需要解决问题，给进程分配多少个页框呢？</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210917190724.png" alt="image-20210917190724580"></p>
<p><code>工作集</code>的概念嗷！！！也可以动态分配嘛！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210917191114.png" alt="image-20210917191112964"></p>
<p>虚拟 -&gt; 段页 -&gt; 程序 -&gt; 进程</p>
<h1 id="第五章（IO）："><a href="#第五章（IO）：" class="headerlink" title="第五章（IO）："></a>第五章（IO）：</h1><h2 id="IO与显示器："><a href="#IO与显示器：" class="headerlink" title="IO与显示器："></a>IO与显示器：</h2><ul>
<li>外设是如何工作的？</li>
</ul>
<p>例如显示器，有一个显卡，我们给显卡中的寄存器中写入对应的内容。硬件的控制器就会根据寄存器中的内容来实际操作硬件嗷！！！</p>
<ol>
<li>使用外设无非就是往控制器发指令嘛！！！本质上就是一条<strong>OUT</strong>指令嗷！！！</li>
<li>外设工作完成之后，CPU进行<strong>中断处理</strong>后续的东西就成了嗷！！！</li>
<li>为了让使用外设简单，要形成一种统一的视图——<strong>文件视图</strong>，这样会比较方便啊！！！</li>
</ol>
<ul>
<li>实际操作外设的形式：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210918092318.png" alt="image-20210918092318137"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210918092427.png" alt="image-20210918092426061"></p>
<h3 id="printf的故事："><a href="#printf的故事：" class="headerlink" title="printf的故事："></a>printf的故事：</h3><ul>
<li>从printf开始嗷！！！</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210918092701.png" alt="image-20210918092700718"></p>
<p>这里就获取到了打印机所对应的文件，并且得到了这个文件的inode结点嗷！！！</p>
<ul>
<li>filp从哪里来？</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210918092855.png" alt="image-20210918092855167"></p>
<p>很显然，这里是从fork中所创建的嗷！！！</p>
<p>所有进程的PCB都是从父进程拷贝而来的，这里为了探究一开始这个文件是谁创建的，显然要从shell进行分析嗷</p>
<ul>
<li>open系统调用完成了什么？</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210918093414.png" alt="image-20210918093413035"></p>
<ul>
<li>open完成，真正向屏幕输出！！！</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210918093618.png" alt="image-20210918093617488"></p>
<p>注意哈，<code>rw_char</code>中传入的第一个参数是Write嗷，这代表着这是一个写操作嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210918094136.png" alt="image-20210918094135721"></p>
<ul>
<li>tty_write：</li>
</ul>
<p>真正准备往设备里面写了，tty -&gt; write_q，本质上就是往输出队列中写入相应的信息。如果队列满了，就应该sleep嗷，<code>sleep_if_full</code>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210918094527.png" alt="image-20210918094526951"></p>
<ul>
<li>tty-&gt;write真的向屏幕输出啦！！！</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210918094823.png" alt="image-20210918094822511"></p>
<p>下面这里实际写入屏幕实际上将数据放入了al，将数据属性放入ah，然后将构造好的ax放入pos，这个pos就是显卡的寄存器嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210918095058.png" alt="image-20210918095057880"></p>
<p>说白了这个out就是这里的内嵌汇编mov嗷！！！</p>
<p>这里是一个循环嗷！！！不断把数据写出到屏幕上嗷！！！</p>
<ul>
<li>设备驱动怎么写？</li>
</ul>
<p>写出核心的Out指令，注册在表上，创建对应的dev文件，也和表对应起来，就完成了设备驱动的编写嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210918095527.png" alt="image-20210918095526522"></p>
<p>操作系统初始化的时候起始我们见过这个90000，初始化鼠标的时候，其实我们都见过这个90000嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210918095644.png" alt="image-20210918095643381"></p>
<ul>
<li>整个流程整理：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210918095815.png" alt="image-20210918095814599"></p>
<h2 id="键盘："><a href="#键盘：" class="headerlink" title="键盘："></a>键盘：</h2><ul>
<li>键盘的故事从哪里开始？<ul>
<li>按下键盘就会触发系统中断嗷！！！</li>
<li>从键盘中断（中断初始化开始嗷！！！）</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210920125018.png" alt="image-20210920125002102"></p>
<p>根据系统码查表，进行不同的操作嗷！！！</p>
<ul>
<li>处理扫描码<code>key_table + eax*4</code></li>
</ul>
<p>key_table是一个函数数组，根据读取的标号去寻找并使用对应的函数嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210920125339.png" alt="image-20210920125338937"></p>
<p>注意这里，我们将读取出来的数据放在了key_map中嗷！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210920125411.png" alt="image-20210920125411076"></p>
<p>注意一下这里哦，这里读取到了对应的ascii码之后，就放到了对应的队列中，就是缓冲区嘛，和之前一样的嗷！！！<code>call put_queue</code>就是将其放入缓冲区中嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210920125851.png" alt="image-20210920125851517"></p>
<ul>
<li>目前还差什么呀？</li>
</ul>
<p>回显！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210920125952.png" alt="image-20210920125951682"></p>
<ul>
<li>键盘处理流程：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210920130046.png" alt="image-20210920130046661"></p>
<p>read_q到secondary无非就是对于读入的字符进行一些类似于转义之类的处理哇，供计算机方便使用嘛，比如转成ascii码嗷！！！</p>
<ul>
<li>统一的文件视图：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210920130243.png" alt="image-20210920130243604"></p>
<p>问题：按下<code>F12</code>，让ls的输出为*，怎么办？调用的处理函数改成我们自己的函数就行嗷！！！</p>
<h1 id="磁盘管理："><a href="#磁盘管理：" class="headerlink" title="磁盘管理："></a>磁盘管理：</h1><h2 id="生磁盘的使用："><a href="#生磁盘的使用：" class="headerlink" title="生磁盘的使用："></a>生磁盘的使用：</h2><ul>
<li>磁盘结构：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210920130717.png" alt="image-20210920130716491"></p>
<ul>
<li>基本工作过程：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210920130811.png" alt="image-20210920130810735"></p>
<ul>
<li>核心就是算出寻道，旋转和传输的距离（三个参数）然后搭配OUT和IN就完成了整个过程嗷！！！</li>
<li>太复杂了orz，所以引出了第一层抽象：<ul>
<li>只用给盘块号，磁盘自动计算出CHS（cyl , head , sec），磁盘自动找到对应的位置嗷！！！</li>
<li>编址转换：一维block号到三维实际磁盘结构</li>
</ul>
</li>
<li>下面的一些知识：</li>
</ul>
<p>注意，这里程序传入的是block盘块号，经过磁盘驱动，转换为了对应的磁道，扇区和位置嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210920134317.png" alt="image-20210920134316877"></p>
<p>加快速度：一条磁道读完了，怎样最快读下一条磁道呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210920134957.png" alt="image-20210920134956272"></p>
<ul>
<li>程序输出block：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210920135843.png" alt="image-20210920135842490"></p>
<p><code>req-&gt;sector = bh-&gt;b_blocknr &lt;&lt; 1;</code></p>
<p>这个东西左移越多读取越快，一次读的越多，干的活越多，虽然浪费可能越多，但是效率就越高嗷！！！</p>
<ul>
<li>第二层抽象（多个进程通过队列使用磁盘）：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210920140455.png" alt="image-20210920140454986"></p>
<p>寻道时间是主要矛盾，让寻道时间越短越好嗷！！！</p>
<ul>
<li><p>算法：</p>
<ul>
<li>FCFS磁盘调度算法：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210920140750.png" alt="image-20210920140750552"></p>
<ul>
<li>SSTF磁盘调度：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210920140815.png" alt="image-20210920140815143"></p>
<p>存在饥饿现象</p>
<ul>
<li>SCAN磁盘调度：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210920140940.png" alt="image-20210920140940047"></p>
<ul>
<li>C-SCAN算法：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210920141013.png" alt="image-20210920141013498"></p>
<p>磁头复位非常快嗷！！！这种方法就十分公平嗷！！！</p>
</li>
<li><p>多个磁盘共同使用磁盘要产生请求放在请求队列中，然后在磁盘中断的时候，从请求中取出内容，换算为CHS，再发给磁盘控制器嗷！！！</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210920141655.png" alt="image-20210920141653795"></p>
<ul>
<li>使用整理：</li>
</ul>
<p><img src="C:\Users\Alexander\AppData\Roaming\Typora\typora-user-images\image-20210920142210196.png" alt="image-20210920142210196"></p>
<h2 id="从生磁盘到文件："><a href="#从生磁盘到文件：" class="headerlink" title="从生磁盘到文件："></a>从生磁盘到文件：</h2><ul>
<li>对于磁盘使用的第三层抽象：<ul>
<li>文件</li>
<li>用户眼里的文件是什么样子？<ul>
<li>文件本身就是一堆字符序列而已（字符流）</li>
<li>磁盘上的文件无非就是建立一个从<strong>字符流到盘块的映射</strong>嗷！！！（从<strong>文件得到盘块号</strong>）</li>
</ul>
</li>
</ul>
</li>
<li>示意图：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210922185434.png" alt="image-20210922185433812"></p>
<p>操作系统会从200-212帮助我们找到对应的盘块，然后修改其中的内容，再写回盘块中嗷！！！</p>
<p>连续结构存放文件需要存放什么？第一块儿的块号，存在FCB中，File Control Block。这个东西只要给了计算机，计算机根据你修改的位置，除以每一个盘块的默认大小，就知道具体的偏移量，这个时候我们只要直到起始位置，就能定位到磁盘上的对应位置！！！因此FCB中只要提供初始盘块号就行嗷！！！</p>
<ul>
<li><p>文件 -&gt; 表 -&gt; 盘块号（抽象实质）</p>
</li>
<li><p>再思考？连续可行吗？不可行，类似于word，越来越多，万一没空间了呢？（整块儿重新分配再挪动，非常耗时orz），或者没有连续的地址空间分配怎么办呢？</p>
</li>
<li><p>链式结构！！！</p>
<ul>
<li>如果一个连一个呢？非常麻烦，一个一个找也太惨了orz。</li>
</ul>
</li>
<li><p>索引架构（Index，Inode的思想）</p>
<ul>
<li>索引结构下的映射表：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210922191436.png" alt="image-20210922191435725"></p>
<ul>
<li>把索引放一起，就很方便嗷！！！</li>
<li>把inode中的文件对应的索引块填入FCB中，非常方便嗷！！！</li>
</ul>
</li>
<li><p>多级索引（实际系统中使用的！！！）</p>
</li>
</ul>
<p>Inode结点嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210922191807.png" alt="image-20210922191807071"></p>
<p>注意一下，这个Inode结点指向的黄色的都是实际上的盘块号嗷！！！</p>
<p>非常机智的做法，非常灵活嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210922192023.png" alt="image-20210922192023308"></p>
<ul>
<li>题目：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210922192108.png" alt="image-20210922192108088"></p>
<p>由于词霸中的内容固定的，如果采用索引，还需要用额外的空间来存储索引，索引还需要时间，肯定没有顺序快啊！！！顺序其实是最快的，链式是顺序失效的情况下，较为有效的管理方法嗷，索引，inode都是为了提高索引的效率，减少索引的次数，但是本质上，顺序就访问了一次内存，还不需要多余的空间，当然是最好的嗷！！！！！</p>
<h2 id="文件使用磁盘的实现："><a href="#文件使用磁盘的实现：" class="headerlink" title="文件使用磁盘的实现："></a>文件使用磁盘的实现：</h2><ul>
<li><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210922193052.png" alt="image-20210922193052237"></li>
</ul>
<p>fd文件描述符 -&gt; file_write到inode中嗷！！！</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210922193501.png" alt="image-20210922193500937"></li>
<li>file_write的实现：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210922193821.png" alt="image-20210922193819996"></p>
<ul>
<li>算出盘块号：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210922194517.png" alt="image-20210922194516339"></p>
<p>找到了对应的盘块号之后，就返回block，再对于block进行读写嗷！！！</p>
<ul>
<li>不同的i_mode：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210922194820.png" alt="image-20210922194820457"></p>
<p>如果是磁盘对应的话，我们就会拿磁盘进行操作。如果是其他的话，就会有不同的文件处理方式嗷！！！</p>
<ul>
<li>整个故事：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210922195225.png" alt="image-20210922195223794"></p>
<h1 id="第六章（文件系统）："><a href="#第六章（文件系统）：" class="headerlink" title="第六章（文件系统）："></a>第六章（文件系统）：</h1><h2 id="目录与文件系统："><a href="#目录与文件系统：" class="headerlink" title="目录与文件系统："></a>目录与文件系统：</h2><ul>
<li><p>第四层的抽象（抽象整个磁盘为文件系统）</p>
</li>
<li><p>故事的开始：</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210923094314.png" alt="image-20210923094313860"></p>
<p>目录树是典型的分治，如果K次划分，每个集合中的文件数为<code>O(logkN)</code>嗷！！！树状结构拓展性好，非常清晰，最常用嗷！！！</p>
<ul>
<li><p>目录：文件结合，实现目录成为了关键问题！！！</p>
</li>
<li><p>说白了就是对于FCB进行了一个管理嘛，给我一个路径，我就能够得到文件的FCB，得到inode，就能够操纵磁盘了嗷！！！</p>
</li>
<li><p>目录中应该有什么？</p>
<ul>
<li>本质上也是一个文件嗷！！！</li>
<li>目录中存放其中所有文件的FCB信息，这不就找到了所有的文件吗？可以吗？可以！高效吗？不高效，一一匹配效率高吗？？？！！！</li>
<li>目录中实际上应该存放文件的名字（用于匹配文件），匹配上之后，我要能够找到FCB（存放FCB的指针呗！！！，这里的指针本质上是对应的磁盘中的某个盘块嗷！！！）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210923102116.png" alt="image-20210923102116052"></p>
</li>
<li><p>存放模型：</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210923095951.png" alt="image-20210923095951161"></p>
<p>可以看出来，粉红色的就是根目录，根目录中存放的就是默认第一层下的一些数据信息嗷！！！</p>
<ul>
<li>那文件系统的根目录存在哪里呢？</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210923100557.png" alt="image-20210923100555795"></p>
<p>磁盘的mount实际上就是把超级块读进来，把根目录mount进来嗷！！！根据根目录，就能够读取到下一层的目录，并且继续向下索引到我们需要的文件嗷！！！</p>
<ul>
<li>整体流程：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210923101615.png" alt="image-20210923101614946"></p>
<h2 id="目录解析代码实现："><a href="#目录解析代码实现：" class="headerlink" title="目录解析代码实现："></a>目录解析代码实现：</h2><ul>
<li>将open弄明白嗷！！！</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210923162706.png" alt="image-20210923162706107"></p>
<ul>
<li>get_dir</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210923163012.png" alt="image-20210923163011522"></p>
<p>current -&gt; root是从前面自举的过程中就初始话好了的嗷！！！</p>
<ul>
<li>目录解析 – 从根目录开始</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210923163348.png" alt="image-20210923163347456"></p>
<ul>
<li>iget函数：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210923163840.png" alt="image-20210923163840241"></p>
<ul>
<li>find_entry：找到目录项</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210923163940.png" alt="image-20210923163939450"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210923164021.png" alt="image-20210923164020944"></p>
<ul>
<li><p>过程：</p>
<ol>
<li>根据超级块和引导块的大小，找到根目录的inode所在的盘块的位置。使用iget函数，将对应的盘块中的内容读取出来。（根的inode）</li>
<li>根据FCB（inode），读取出对应的内容，将接下来的目录和读取出来的文件内容进行比对，一直while，直到找到你需要的文件嗷！！！</li>
</ol>
<p>FCB中存储的就是当前结点的名字和其对应的inode结点所对应的盘块，读取到了inode之后，根据inode就能够找到根目录中对应的内容。</p>
</li>
</ul>
<h1 id="操作系统整体轮廓："><a href="#操作系统整体轮廓：" class="headerlink" title="操作系统整体轮廓："></a>操作系统整体轮廓：</h1><ol>
<li>多进程视图，交替进行，使CPU充分忙碌</li>
<li>内存管理</li>
<li>外设管理</li>
<li>磁盘管理 -&gt; 文件系统</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210923165011.png" alt="image-20210923165010125"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/31/%E6%B7%B1%E5%85%A5%E5%AD%A6%E4%B9%A0-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" data-id="cl6gepmgw008ee0jqdz4p9n7m" data-title="操作系统深入学习" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%A7%E4%B8%89%E8%87%AA%E5%AD%A6/" rel="tag">大三自学</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-SpringBoot高级" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/30/SpringBoot%E9%AB%98%E7%BA%A7/" class="article-date">
  <time class="dt-published" datetime="2021-08-30T11:20:23.000Z" itemprop="datePublished">2021-08-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/30/SpringBoot%E9%AB%98%E7%BA%A7/">SpringBoot高级</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="雷神SpringBoot高级部分"><a href="#雷神SpringBoot高级部分" class="headerlink" title="雷神SpringBoot高级部分"></a>雷神SpringBoot高级部分</h1>
        
          <p class="article-more-link">
            <a href="/2021/08/30/SpringBoot%E9%AB%98%E7%BA%A7/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/30/SpringBoot%E9%AB%98%E7%BA%A7/" data-id="cl6gepmg0003fe0jq9xny8vao" data-title="SpringBoot高级" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag">后端</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-kubernetes学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/08/26/kubernetes%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2021-08-26T07:23:44.000Z" itemprop="datePublished">2021-08-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/08/26/kubernetes%E5%AD%A6%E4%B9%A0/">Kubernetes学习</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="终于来到了K8S这个部分相应知识的讲解嗷！！！"><a href="#终于来到了K8S这个部分相应知识的讲解嗷！！！" class="headerlink" title="终于来到了K8S这个部分相应知识的讲解嗷！！！"></a>终于来到了K8S这个部分相应知识的讲解嗷！！！</h1><ul>
<li>课程介绍：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210826152922.png" alt="image-20210826152922417"></p>
<h1 id="K8S基本概念："><a href="#K8S基本概念：" class="headerlink" title="K8S基本概念："></a>K8S基本概念：</h1><h2 id="K8S概述和特性"><a href="#K8S概述和特性" class="headerlink" title="K8S概述和特性"></a>K8S概述和特性</h2><ul>
<li><p>概述：</p>
<ul>
<li>容器化集群管理系统，是Google开源的一个容器编排引擎，支持自动化的部署。</li>
<li>使用k8s进行容器化应用部署</li>
<li>使用k8s利于应用拓展</li>
<li>目标：让容器化应用更加简洁和高效</li>
</ul>
</li>
<li><p>特性：</p>
<ul>
<li>自动装箱：<ul>
<li>基于容器对应用运行环境的资源配置要求自动部署应用容器。</li>
</ul>
</li>
<li>自我修复：<ul>
<li>容器失败会自动重启</li>
<li>部署的结点有问题的时候，会自动重新部署和重新调度</li>
<li>未通过监控检查的时候，会关闭此容器。直到正常运行，才会对外提供服务。</li>
</ul>
</li>
<li>水平拓展：<ul>
<li>流量来了之后动态拓展</li>
</ul>
</li>
<li>服务发现：<ul>
<li>对外提供统一入口</li>
<li>对内负载均衡，动态分配嗷！！！</li>
</ul>
</li>
<li>滚动更新：<ul>
<li>根据应用的变化，对于应用容器运行的应用，进行一次性或者批量式的更新。</li>
</ul>
</li>
<li>版本回退：<ul>
<li>可以根据应用部署情况，对于应用容器进行的应用，进行历史版本的即时回退。</li>
</ul>
</li>
<li>密钥和配置管理：<ul>
<li>类似于热部署</li>
</ul>
</li>
<li>自动编排：<ul>
<li>自动实现存储系统的挂载以及应用，对于数据持久化非常重要。</li>
</ul>
</li>
<li>批处理：<ul>
<li>一次性任务，定时任务，满足批量数据处理和分析的场景嗷！！！</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="K8S架构组件"><a href="#K8S架构组件" class="headerlink" title="K8S架构组件"></a>K8S架构组件</h2><p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210826155416.png" alt="image-20210826155221671"></p>
<ol>
<li>Master和Worker：</li>
</ol>
<ul>
<li>和Nginx里面那个类似哦，Master是主控结点，Worker是工作结点。</li>
<li>Master组件：<ul>
<li>API Server：集群统一入口，以restful方式，交给etcd存储</li>
<li>Scheduler：选择Worker Node结点应用部署</li>
<li>Controller-Manager：处理集群中常规后台任务，一个资源对应一个控制器</li>
<li>etcd：存储系统，保存集群相关数据</li>
</ul>
</li>
<li>Worker组件：<ul>
<li>kubelet: Master派到Worker节点的代表，管理工作节点容器</li>
<li>kube-proxy: 提供网络代理，实现负载均衡等功能。</li>
</ul>
</li>
</ul>
<h2 id="K8S核心概念"><a href="#K8S核心概念" class="headerlink" title="K8S核心概念"></a>K8S核心概念</h2><h3 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h3><ul>
<li>最小部署单元</li>
</ul>
<blockquote>
<ul>
<li>一个Pod中可以有很多个容器，它是一组单元的集合</li>
<li>最小单元不是一个容器，而是一个Pod嗷！</li>
<li>一个Pod中的容器是共享网络的</li>
<li>生命周期是短暂的</li>
</ul>
</blockquote>
<h3 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h3><ul>
<li>确保预期的pod副本的数量</li>
</ul>
<blockquote>
<ul>
<li>无状态应用部署<ul>
<li>没有任何约定</li>
<li>直接拿容器来使用</li>
</ul>
</li>
<li>有状态应用部署<ul>
<li>有一定的条件</li>
<li>依赖于存储或需要特定网络IP</li>
</ul>
</li>
</ul>
</blockquote>
<ul>
<li>确保所有的node都运行同一个Pod，一次性任务和定时任务</li>
</ul>
<h3 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h3><ul>
<li>定义一组pod的访问规则</li>
<li>Service统一部署，Controller来创建pod，pod是最小部署单元。</li>
</ul>
<h1 id="搭建K8S集群："><a href="#搭建K8S集群：" class="headerlink" title="搭建K8S集群："></a>搭建K8S集群：</h1><h2 id="K8S环境平台规划"><a href="#K8S环境平台规划" class="headerlink" title="K8S环境平台规划"></a>K8S环境平台规划</h2><ul>
<li>单Master集群：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210826165740.png" alt="image-20210826165740642"></p>
<ul>
<li>多Master集群：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210826170053.png" alt="image-20210826170053372"></p>
<h2 id="服务器硬件配置要求"><a href="#服务器硬件配置要求" class="headerlink" title="服务器硬件配置要求"></a>服务器硬件配置要求</h2><p>master：2核 , 4G , 20G</p>
<p>worker：4核 , 8G , 40G</p>
<p>生产环境：要求更高嗷！！！</p>
<h2 id="搭建K8S集群部署方式"><a href="#搭建K8S集群部署方式" class="headerlink" title="搭建K8S集群部署方式"></a>搭建K8S集群部署方式</h2><ol>
<li>kubeadm</li>
</ol>
<blockquote>
<p>K8S部署工具，提供kubeadm init和kubeadm join，用于快速部署K8S集群</p>
<p>非常简单嗷！！！有点像Swarm嗷！！！</p>
</blockquote>
<ol start="2">
<li>二进制包</li>
</ol>
<blockquote>
<p>手动部署每个组件，组成K8S集群嗷！！！</p>
<p>可以清晰看到每一步是怎么做到的嗷！！！</p>
</blockquote>
<h2 id="实操："><a href="#实操：" class="headerlink" title="实操："></a>实操：</h2><h3 id="Kubeadm集群搭建："><a href="#Kubeadm集群搭建：" class="headerlink" title="Kubeadm集群搭建："></a>Kubeadm集群搭建：</h3><ul>
<li>基本要求：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210826173042.png" alt="image-20210826173026783"></p>
<ol>
<li>安装三台虚拟机，安装CentOS7。</li>
</ol>
<p>下面的操作可以发送到所有会话，直接在所有会话中操作嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210826173437.png" alt="image-20210826173437046"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210826173502.png" alt="image-20210826173501669"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210826173658.png" alt="image-20210826173657885"></p>
<ol start="2">
<li>所有结点安装Docker &#x2F; Kubeadm &#x2F; Kubelet</li>
</ol>
<ul>
<li>docker：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210826173911.png" alt="image-20210826173911308"></p>
<ul>
<li>阿里云yum软件源：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210826174032.png" alt="image-20210826174031806"></p>
<ul>
<li>安装对应的东西：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210826174157.png" alt="image-20210826174157323"></p>
<ul>
<li>Master部署：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210826174237.png" alt="image-20210826174237619"></p>
<ul>
<li>加入Node：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210826174933.png" alt="image-20210826174933351"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210826175034.png" alt="image-20210826175034332"></p>
<ul>
<li>上面那一段是初始化主结点！！！</li>
<li>下面这一段是在Worker中运行，将Worker添加注册到主节点中用到的嗷！！！</li>
<li>后面还有网络配置等一大堆的，建议看视频加课件嗷！！！</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827085448.png" alt="image-20210827085447881"></p>
<h3 id="二进制集群搭建："><a href="#二进制集群搭建：" class="headerlink" title="二进制集群搭建："></a>二进制集群搭建：</h3><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1GT4y1A756?p=10&spm_id_from=pageDriver">二进制集群搭建相关知识嗷！！！</a></p>
<ul>
<li>基本要求：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210826173042.png" alt="image-20210826173026783"></p>
<ol>
<li>创建多台虚拟机，安装Linux操作系统</li>
<li>操作系统初始化</li>
<li>为etcd和apiserver自签证书</li>
</ol>
<ul>
<li>自签证书：<ul>
<li><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827090246.png" alt="image-20210827090245778"></li>
</ul>
</li>
</ul>
<p>自签证书准备：</p>
<ul>
<li>cfssl证书生成工具</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827090344.png" alt="image-20210827090344670"></p>
<ol start="4">
<li><p>部署etcd集群</p>
</li>
<li><p>部署master组件</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827090530.png" alt="image-20210827090521462"></p>
<ol start="6">
<li>部署Node组件</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827090530.png" alt="image-20210827090522956"></p>
<ol start="7">
<li>部署集群网络</li>
</ol>
<ul>
<li>老师讲的挺糊的，二进制这里先跳过去，后面再进行补充嗷！！！</li>
</ul>
<h1 id="Kubectl："><a href="#Kubectl：" class="headerlink" title="Kubectl："></a>Kubectl：</h1><ul>
<li>集群管理的命令行工具嗷！！！</li>
<li>语法格式：<code>kubectl [command] [type] [name] [flags]</code></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827095917.png" alt="image-20210827095917745"></p>
<ul>
<li><code>kubectl + --help</code>可以查看所有的命令嗷！！！</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827102816.png" alt="image-20210827102816349"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827102844.png" alt="image-20210827102843999"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827102908.png" alt="image-20210827102908370"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827102922.png" alt="image-20210827102922364"></p>
<h2 id="目前用到的命令："><a href="#目前用到的命令：" class="headerlink" title="目前用到的命令："></a>目前用到的命令：</h2><ol>
<li><code>kubectl create deployment nginx --image=nginx</code></li>
<li><code>kubectl expose deployment nginx --port=80 --type=NodePort</code></li>
<li><code>kubectl get port,svc</code></li>
</ol>
<p>port是段都的信息，svc里面就包括了上面指定的开放端口的映射信息嗷！！！</p>
<ol start="4">
<li><code>kubectl get nodes</code></li>
</ol>
<p>获取所有结点的信息嗷！</p>
<ol start="5">
<li><code>kubectl get cs</code></li>
</ol>
<p>显示基本的状态</p>
<ol start="6">
<li><code>kubectl apply -f + yaml文件</code></li>
</ol>
<p>刚刚用于部署网络嗷！！！</p>
<h1 id="资源编排："><a href="#资源编排：" class="headerlink" title="资源编排："></a>资源编排：</h1><ul>
<li>实际开发的过程中，会把相应的配置记录在配置文件yaml中。叫做资源清单文件或资源编排文件。</li>
<li>Yaml文件：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827103832.png" alt="image-20210827103832789"></p>
<ul>
<li>Yaml文件详解：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827104019.png" alt="image-20210827104018767"></p>
<p>Yaml文件的组成部分：</p>
<ul>
<li>控制器定义</li>
<li>被控制对象</li>
</ul>
<p>常用字段含义：</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827104619.png" alt="image-20210827104619431"></li>
<li>如何快速编写yaml文件：<ol>
<li>使用kubectl create生成yaml文件</li>
<li>使用kubectl get命令导出yaml文件</li>
</ol>
</li>
</ul>
<ol>
<li>kubectl create：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827174309.png" alt="image-20210827174309484"></p>
<p>直接输出到yaml文件中：</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827174351.png" alt="image-20210827174351326"></p>
<ol start="2">
<li>kubectl get：</li>
</ol>
<ul>
<li>适用于已经部署好的项目，将配置文件导出出来嗷！！！</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827174621.png" alt="image-20210827174620867"></p>
<p>系版本的–export已经弃用了嗷！！！</p>
<p><code>-o yaml &gt; 1.yaml</code>就可以，–export可以不用了嗷！！！</p>
<h1 id="Pod："><a href="#Pod：" class="headerlink" title="Pod："></a>Pod：</h1><h2 id="概述和存在意义："><a href="#概述和存在意义：" class="headerlink" title="概述和存在意义："></a>概述和存在意义：</h2><ul>
<li>基本概念：<ul>
<li>K8s中创建和管理的最小单元，部署的最小单元</li>
<li>K8s不会直接处理容器，而是直接处理Pod。</li>
<li>Pod由一个或者多个container构成嗷！！！</li>
<li>一个Pod容器共享网络</li>
<li>Pod是短暂存在的嗷！</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827185620.png" alt="image-20210827185620421"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827185641.png" alt="image-20210827185641059"></p>
<ul>
<li>存在意义：</li>
</ul>
<ol>
<li>创建容器使用Docker，一个docker对应一个容器，一个容器有进程，一个容器运行一个应用程序。</li>
<li>Pod是多进程设计，运行多个应用程序。</li>
</ol>
<ul>
<li>一个pod有多个容器，一个容器里面运行一个应用程序。</li>
</ul>
<ol start="3">
<li>Pod存在为了亲密性应用</li>
</ol>
<ul>
<li>两个应用之间要进行交互</li>
<li>网络之间的调用</li>
<li>两个应用需要频繁进行调用</li>
</ul>
<h2 id="实现机制："><a href="#实现机制：" class="headerlink" title="实现机制："></a>实现机制：</h2><ol>
<li>共享网络</li>
<li>共享存储</li>
</ol>
<ul>
<li>容器本身之间是相互隔离的嗷！！！通过Linux中的Namespace和group进行隔离的嗷！！！</li>
<li>共享网络的前提条件：容器在同一个Namespace下面嗷！！！</li>
<li>Pod实现共享网络的机制：</li>
</ul>
<ol>
<li>创建一个默认的根容器（Pause容器），又被称为info容器</li>
<li>后面创建的docker容器会逐个加入到info容器中嗷！！！</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827194459.png" alt="image-20210827194459456"></p>
<ul>
<li>通过Pause容器，把其他业务容器加入到Pause容器中，让所有容器业务在同一个名称空间中，可以实现网络共享。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827194830.png" alt="image-20210827194829852"></p>
<ul>
<li><p>共享存储：</p>
<ul>
<li>数据持久化：<ul>
<li>日志数据</li>
<li>业务数据</li>
</ul>
</li>
<li><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827200341.png" alt="image-20210827200341170"></li>
</ul>
<p>Volume数据卷的概念，使用数据卷进行持久化存储。</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827202855.png" alt="image-20210827202855285"></li>
</ul>
</li>
</ul>
<h2 id="镜像拉取策略："><a href="#镜像拉取策略：" class="headerlink" title="镜像拉取策略："></a>镜像拉取策略：</h2><p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827203258.png" alt="image-20210827203258176"></p>
<h2 id="资源限制："><a href="#资源限制：" class="headerlink" title="资源限制："></a>资源限制：</h2><p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827204211.png" alt="image-20210827204211428"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827204320.png" alt="image-20210827204320259"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827204507.png" alt="image-20210827204506927"></p>
<h2 id="Pod重启机制："><a href="#Pod重启机制：" class="headerlink" title="Pod重启机制："></a>Pod重启机制：</h2><ul>
<li><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827204648.png" alt="image-20210827204648137"></li>
<li><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827204824.png" alt="image-20210827204824567"></li>
</ul>
<p>批量任务就可以用Never等，有不同的用法嗷！！！</p>
<h2 id="健康检查："><a href="#健康检查：" class="headerlink" title="健康检查："></a>健康检查：</h2><ul>
<li>通过容器检查 —&gt; 应用层健康检查</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827205152.png" alt="image-20210827205152089"></p>
<ul>
<li>健康检查的策略：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827205301.png" alt="image-20210827205301480"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827205354.png" alt="image-20210827205354611"></p>
<h2 id="调度策略："><a href="#调度策略：" class="headerlink" title="调度策略："></a>调度策略：</h2><ul>
<li>时序图：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827210104.png" alt="image-20210827210104034"></p>
<ul>
<li><p>每一步都要经过API Server，每一步的数据都写入到etcd，通过监控的方式，完成一步接一步的执行嗷！！！</p>
</li>
<li><p>影响调用的属性：</p>
<ol>
<li>Pod资源限制对于Pod调用产生影响</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827211222.png" alt="image-20210827211222380"></p>
<ol start="2">
<li>结点选择器标签影响Pod调度</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827211310.png" alt="image-20210827211310247"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827211418.png" alt="image-20210827211417955"></p>
<p>要采用上面这种措施，首先要对于结点创建标签<code>kubectl label node node1 env_role=dev</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827211718.png" alt="image-20210827211718172"></p>
<ol start="3">
<li>结点的亲和性影响Pod调度</li>
</ol>
<p>nodeAffinity和之前nodeSelector基本一样的，根据节点上标签约束来决定将Pod调度到某些节点上嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827212055.png" alt="image-20210827212055187"></p>
<p>支持的常用的操作符号：</p>
<ul>
<li>In NotIn Exists Gt Lt DoesNotExists</li>
<li>反亲和性：和亲和性刚好相反嗷！！！</li>
</ul>
<ol start="4">
<li>污点和污点容忍：</li>
</ol>
<ul>
<li>nodeSelector和nodeAffinity：Pod调度到某些节点上，Pod属性，调度的时候实现</li>
<li>Taint污点：节点不做普通分配调度，是节点属性嗷！</li>
<li>应用场景：专用节点，配置特点硬件节点，基于Taint驱逐</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210827214725.png" alt="image-20210827214725188"></p>
<p>这里的Key的名字没有特殊的要求嗷，可以随便取嗷！！！</p>
<ul>
<li>删除污点：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829091637.png" alt="image-20210829091432792"></p>
<ul>
<li>污点容忍：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829091655.png" alt="image-20210829091655646"></p>
<p>容忍污点，使得某个节点即使有污点也有可能被调度嗷！！！</p>
</li>
</ul>
<h1 id="Controller："><a href="#Controller：" class="headerlink" title="Controller："></a>Controller：</h1><h2 id="什么是Controller"><a href="#什么是Controller" class="headerlink" title="什么是Controller"></a>什么是Controller</h2><ul>
<li>实际存在的，管理和运行实际的对象。</li>
<li>Controller是集群上管理和运行容器的对象</li>
</ul>
<h2 id="Pod和Controller之间的关系"><a href="#Pod和Controller之间的关系" class="headerlink" title="Pod和Controller之间的关系"></a>Pod和Controller之间的关系</h2><ul>
<li>Pod是通过Controller来实际上实现应用的运维的，比如伸缩，滚动升级等等。</li>
<li>Pod和Controller之间通过Label建立关系嗷！！！</li>
<li>控制器也可被称为工作负载（WorkLoad）嗷。</li>
<li>两者之间的运维管理：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829092242.png" alt="image-20210829092242059"></p>
<p>Selector嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829102134.png" alt="image-20210829102134436"></p>
<h2 id="Deployment控制器应用场景"><a href="#Deployment控制器应用场景" class="headerlink" title="Deployment控制器应用场景"></a>Deployment控制器应用场景</h2><ul>
<li>部署无状态应用嗷！！！</li>
<li>管理Pod和RepliccaSet</li>
<li>部署，滚动升级等功能</li>
<li>应用场景：<ul>
<li>Web服务</li>
<li>微服务</li>
</ul>
</li>
</ul>
<h2 id="yaml文件字段说明"><a href="#yaml文件字段说明" class="headerlink" title="yaml文件字段说明"></a>yaml文件字段说明</h2><ul>
<li>命令行不可复现 -&gt; 命令行变为Yaml</li>
<li><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829102200.png" alt="image-20210829102200400"></li>
<li>使用yaml文件进行部署：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829102240.png" alt="image-20210829102240319"></p>
<h2 id="Deployment控制器部署应用"><a href="#Deployment控制器部署应用" class="headerlink" title="Deployment控制器部署应用"></a>Deployment控制器部署应用</h2><ul>
<li><p>步骤：</p>
<ol>
<li>导出Yaml文件：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829102340.png" alt="image-20210829102340153"></p>
<ol start="2">
<li>使用Yaml进行部署：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829102405.png" alt="image-20210829102405236"></p>
<ol start="3">
<li>对外暴露端口（发布）：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829102530.png" alt="image-20210829102530630"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829102611.png" alt="image-20210829102611292"></p>
<p>本质上这里还是通过Yaml来部署的，熟悉了之后，可以直接编写Yaml中的参数，对其进行操作和部署嗷！！！执行第二个步骤，就可以实现我们的部署工作了嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829102842.png" alt="image-20210829102841918"></p>
<p>80是容器内暴露的端口，30048是所有的结点，对外暴露的端口。就是相当于Docker中的端口映射的概念嘛！！！</p>
</li>
</ul>
<h2 id="升级回滚"><a href="#升级回滚" class="headerlink" title="升级回滚"></a>升级回滚</h2><ul>
<li>指定版本的配置：</li>
<li><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829103956.png" alt="image-20210829103956299"></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829103903.png" alt="image-20210829103902899"></p>
<ul>
<li>如果我要升级Nginx的版本呢？</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829104149.png" alt="image-20210829104149578"></p>
<ul>
<li>升级的原理和过程：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829104332.png" alt="image-20210829104332318"></p>
<p>1.14正常运行，同时去下载1.15，下载完成并且成功运行之后，再去把1.14给替换掉。这就是升级的整个流程嗷！！！保证升级过程中，五福不会终端嗷！！！</p>
<ul>
<li>查看升级是否成功：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829104512.png" alt="image-20210829104511926"></p>
<ul>
<li>回滚版本如何操作呢？</li>
</ul>
<ol>
<li>查看历史版本：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829104605.png" alt="image-20210829104605072"></p>
<p>第一个是1.14，第二个就是1.15</p>
<ol start="2">
<li>还原（回滚）版本：</li>
</ol>
<ul>
<li>回滚到上一个版本：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829104712.png" alt="image-20210829104712466"></p>
<ul>
<li>回滚到指定版本：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829104831.png" alt="image-20210829104830670"></p>
<h2 id="弹性伸缩"><a href="#弹性伸缩" class="headerlink" title="弹性伸缩"></a>弹性伸缩</h2><p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829104919.png" alt="image-20210829104919152"></p>
<h1 id="Service："><a href="#Service：" class="headerlink" title="Service："></a>Service：</h1><h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><ul>
<li>定义一组Pod的访问规则嗷！！！</li>
</ul>
<ol>
<li>Service存在的意义：</li>
</ol>
<ul>
<li>防止Pod失联（服务发现）</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829105124.png" alt="image-20210829105124253"></p>
<p>Pod每次重启，IP都会变化的，所以Pod的生命周期是短暂的嗷！！！因此虽然通过Ip可以相互调用，由于Ip不可靠，不予以采用嗷！！！</p>
<ul>
<li>说白了就是Nacos！！！服务注册中心嘛！！！</li>
</ul>
<ol start="2">
<li>定义一组Pod的访问策略：</li>
</ol>
<ul>
<li>负载均衡！！！</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829105542.png" alt="image-20210829105541773"></p>
<h2 id="Pod和Service的关系："><a href="#Pod和Service的关系：" class="headerlink" title="Pod和Service的关系："></a>Pod和Service的关系：</h2><ul>
<li>如何建立关系？</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829105811.png" alt="image-20210829105810639"></p>
<h2 id="Service的三种类型："><a href="#Service的三种类型：" class="headerlink" title="Service的三种类型："></a>Service的三种类型：</h2><ul>
<li><p>类型：</p>
<ol>
<li>ClusterIP：集群内部访问</li>
<li>NodePort：对外访问应用使用</li>
<li>LoadBalancer：对外访问应用使用，公有云也可以使用嗷！</li>
</ol>
</li>
<li><p><code>kubectl get svc</code>：svc是对外暴露端口，这里就是查询每个端口的暴露情况orz。</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829110142.png" alt="image-20210829110142408"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829110248.png" alt="image-20210829110247676"></p>
<ul>
<li>跑起来之后的结果：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829110333.png" alt="image-20210829110332924"></p>
<p>注意字母的大小写哈！！！、</p>
<ul>
<li>Node一般内网部署应用，外网一般不能够访问到。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829111121.png" alt="image-20210829111120898"></p>
<h1 id="Controller补充："><a href="#Controller补充：" class="headerlink" title="Controller补充："></a>Controller补充：</h1><h2 id="部署无状态应用："><a href="#部署无状态应用：" class="headerlink" title="部署无状态应用："></a>部署无状态应用：</h2><ul>
<li>无状态特点：<ul>
<li>其实认为Pod都是一样的，因为没有状态嘛</li>
<li>没有顺序要求嗷！！！</li>
<li>不用考虑我在哪个Node上运行</li>
<li>随意进行伸缩和拓展</li>
</ul>
</li>
<li>有状态：<ul>
<li>上面因素都需要考虑到</li>
<li>让每个Pod都是独立的，保持Pod的启动顺序和唯一性</li>
<li>唯一的标识符进行区分，持久存储</li>
<li>有序的，比如Mysql主从等</li>
</ul>
</li>
</ul>
<h2 id="部署有状态应用："><a href="#部署有状态应用：" class="headerlink" title="部署有状态应用："></a>部署有状态应用：</h2><ul>
<li>无头service</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829112954.png" alt="image-20210829112954170"></p>
<ul>
<li>ClusterIP：None</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829113123.png" alt="image-20210829113123442"></p>
<p>下面这个Kind，里面是StatefulSet嗷，注意一下嗷！</p>
<ul>
<li><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829113025.png" alt="image-20210829113024879"></li>
<li>查看Pod：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829113539.png" alt="image-20210829113538783"></p>
<p>每个都是唯一的名称嗷！！！</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829113627.png" alt="image-20210829113626795"></p>
<p>None就代表这是一个无头的服务嗷！！！</p>
<ul>
<li>summary：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829113842.png" alt="image-20210829113841918"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210829113858.png" alt="image-20210829113857427"></p>
<h2 id="所有Node运行同一个Pod："><a href="#所有Node运行同一个Pod：" class="headerlink" title="所有Node运行同一个Pod："></a>所有Node运行同一个Pod：</h2><ul>
<li>部署守护进程DaemonSet</li>
</ul>
<p>每个node上面运行一个pod，新加入的node也同样运行在一个pod里面嗷！！！</p>
<p>例子：</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210830164410.png" alt="image-20210830164403320"></p>
<p>Yaml文件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210830164929.png" alt="image-20210830164928922"></p>
<h2 id="Job（一次性任务）："><a href="#Job（一次性任务）：" class="headerlink" title="Job（一次性任务）："></a>Job（一次性任务）：</h2><p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210830165206.png" alt="image-20210830165205933"></p>
<p>这里的Kind为Job嗷，是Job才为一次性任务。</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210830165642.png" alt="image-20210830165641957"></p>
<h2 id="CronJob（定时任务）："><a href="#CronJob（定时任务）：" class="headerlink" title="CronJob（定时任务）："></a>CronJob（定时任务）：</h2><p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210830165735.png" alt="image-20210830165735467"></p>
<ul>
<li>每隔一分钟重启一次嗷！！！</li>
<li>启动定时任务：<code>kubectl apply -f cronjob.yaml</code></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210830170012.png" alt="image-20210830170012503"></p>
<h1 id="配置管理："><a href="#配置管理：" class="headerlink" title="配置管理："></a>配置管理：</h1><h2 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h2><ul>
<li><p>作用：加密数据加载到etcd里面，让Pod容器以挂载Volume方式进行访问。</p>
</li>
<li><p>场景：凭证</p>
</li>
<li><p>场景：</p>
<ol>
<li>创建secret加密数据（以Base64编码为例子）：</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210830170303.png" alt="image-20210830170303052"></p>
<ol start="2">
<li><p>挂载数据卷：</p>
<ul>
<li>以变量形式挂载：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210830170523.png" alt="image-20210830170523737"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210830170623.png" alt="image-20210830170623197"></p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210830170754.png" alt="image-20210830170754577"></p>
<ul>
<li>以Volume的形式挂载到Pod中：</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210830171206.png" alt="image-20210830171206721"></p>
</li>
</ol>
</li>
</ul>
<h2 id="ConfigMap："><a href="#ConfigMap：" class="headerlink" title="ConfigMap："></a>ConfigMap：</h2><ul>
<li><p>作用：存储不加密的数据到etcd中，让Pod以变量或者Volume的形式挂载到容器中。</p>
</li>
<li><p>场景：</p>
<ul>
<li>配置文件</li>
</ul>
</li>
<li><p>步骤：</p>
<ol>
<li>创建配置文件：</li>
</ol>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/08/26/kubernetes%E5%AD%A6%E4%B9%A0/" data-id="cl6gepmg7004ge0jq3i7l9x7y" data-title="Kubernetes学习" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag">后端</a></li></ul>

    </footer>
  </div>
  
</article>



  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/3/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/2021%E5%B9%B4%E7%BE%8E%E8%B5%9B/">2021年美赛</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/2021%E5%B9%B4%E7%BE%8E%E8%B5%9B/Python/">Python</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%A8%E5%8A%9B%E7%BB%93%E7%82%B9%E5%90%8E%E7%AB%AF/">动力结点后端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%A8%E5%8A%9B%E7%BB%93%E7%82%B9%E5%90%8E%E7%AB%AF%E8%AF%BE%E7%A8%8B/">动力结点后端课程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%87%AA%E5%AD%A6%E5%86%85%E5%AE%B9%E6%88%96%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/">自学内容或课程作业</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Database/" rel="tag">Database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Skills/" rel="tag">Skills</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/introduction/" rel="tag">introduction</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/" rel="tag">云服务器与项目部署</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag">后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E4%B8%80%E5%AD%A6%E4%B9%A0/" rel="tag">大一学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E4%B8%89%E8%87%AA%E5%AD%A6/" rel="tag">大三自学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E4%BA%8C%E8%87%AA%E5%AD%A6/" rel="tag">大二自学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BE%8E%E8%B5%9B/" rel="tag">美赛</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/" rel="tag">论文精读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%AB/" rel="tag">读书分享</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B5%84%E6%BA%90%E7%A6%8F%E5%88%A9%EF%BC%81%EF%BC%81%EF%BC%81/" rel="tag">资源福利！！！</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Database/" style="font-size: 12.22px;">Database</a> <a href="/tags/Python/" style="font-size: 16.67px;">Python</a> <a href="/tags/Skills/" style="font-size: 10px;">Skills</a> <a href="/tags/introduction/" style="font-size: 11.11px;">introduction</a> <a href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/" style="font-size: 12.22px;">云服务器与项目部署</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15.56px;">前端</a> <a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 18.89px;">后端</a> <a href="/tags/%E5%A4%A7%E4%B8%80%E5%AD%A6%E4%B9%A0/" style="font-size: 14.44px;">大一学习</a> <a href="/tags/%E5%A4%A7%E4%B8%89%E8%87%AA%E5%AD%A6/" style="font-size: 17.78px;">大三自学</a> <a href="/tags/%E5%A4%A7%E4%BA%8C%E8%87%AA%E5%AD%A6/" style="font-size: 15.56px;">大二自学</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 11.11px;">机器学习</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E7%BE%8E%E8%B5%9B/" style="font-size: 20px;">美赛</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 13.33px;">计算机网络</a> <a href="/tags/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/" style="font-size: 10px;">论文精读</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%AB/" style="font-size: 10px;">读书分享</a> <a href="/tags/%E8%B5%84%E6%BA%90%E7%A6%8F%E5%88%A9%EF%BC%81%EF%BC%81%EF%BC%81/" style="font-size: 10px;">资源福利！！！</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/01/16/ML%E5%85%A5%E9%97%A8/">ML入门</a>
          </li>
        
          <li>
            <a href="/2021/12/28/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A03/">大数据分析与智能计算期末复习3</a>
          </li>
        
          <li>
            <a href="/2021/12/24/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A02/">大数据分析与智能计算期末复习2</a>
          </li>
        
          <li>
            <a href="/2021/12/20/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">大数据分析与智能计算期末复习</a>
          </li>
        
          <li>
            <a href="/2021/12/13/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AF%BE%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">系统架构课程期末复习</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>