<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>MySQL学习 | 兔の博客</title><meta name="author" content="Alexander Liu"><meta name="copyright" content="Alexander Liu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="这是对于老杜动力节点相关MySQL课程的学习，个人觉得非常棒，讲的很透彻，担忧一部分的内容由于业务接触少，没有详细介绍，在这个学期的数据库课程里应该会提到，那个时候再学嗷！！！">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL学习">
<meta property="og:url" content="http://example.com/2021/03/09/mysql-xue-xi/index.html">
<meta property="og:site_name" content="兔の博客">
<meta property="og:description" content="这是对于老杜动力节点相关MySQL课程的学习，个人觉得非常棒，讲的很透彻，担忧一部分的内容由于业务接触少，没有详细介绍，在这个学期的数据库课程里应该会提到，那个时候再学嗷！！！">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2021-03-09T11:40:26.000Z">
<meta property="article:modified_time" content="2021-04-03T01:57:57.000Z">
<meta property="article:author" content="Alexander Liu">
<meta property="article:tag" content="后端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/03/09/mysql-xue-xi/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'MySQL学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-04-03 09:57:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="兔の博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">75</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">兔の博客</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">MySQL学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-03-09T11:40:26.000Z" title="发表于 2021-03-09 19:40:26">2021-03-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-04-03T01:57:57.000Z" title="更新于 2021-04-03 09:57:57">2021-04-03</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%8A%A8%E5%8A%9B%E7%BB%93%E7%82%B9%E5%90%8E%E7%AB%AF%E8%AF%BE%E7%A8%8B/">动力结点后端课程</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="MySQL学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="这是对于老杜动力节点相关MySQL课程的学习，个人觉得非常棒，讲的很透彻，担忧一部分的内容由于业务接触少，没有详细介绍，在这个学期的数据库课程里应该会提到，那个时候再学嗷！！！"><a href="#这是对于老杜动力节点相关MySQL课程的学习，个人觉得非常棒，讲的很透彻，担忧一部分的内容由于业务接触少，没有详细介绍，在这个学期的数据库课程里应该会提到，那个时候再学嗷！！！" class="headerlink" title="这是对于老杜动力节点相关MySQL课程的学习，个人觉得非常棒，讲的很透彻，担忧一部分的内容由于业务接触少，没有详细介绍，在这个学期的数据库课程里应该会提到，那个时候再学嗷！！！"></a>这是对于老杜动力节点相关MySQL课程的学习，个人觉得非常棒，讲的很透彻，担忧一部分的内容由于业务接触少，没有详细介绍，在这个学期的数据库课程里应该会提到，那个时候再学嗷！！！</h1><span id="more"></span>





<h1 id="数据库概念"><a href="#数据库概念" class="headerlink" title="数据库概念"></a>数据库概念</h1><h2 id="数据库是啥"><a href="#数据库是啥" class="headerlink" title="数据库是啥"></a>数据库是啥</h2><ul>
<li>序列化和反序列化可以的，也可以存成文件。但是复杂，也不够便利</li>
<li>底层还是流来处理，只是现在更加高级，不用写流了，直接用sql语句就能完成高层数据库的调用。</li>
</ul>
<h2 id="数据库的安装与登陆"><a href="#数据库的安装与登陆" class="headerlink" title="数据库的安装与登陆"></a>数据库的安装与登陆</h2><ul>
<li>有一个比较好的安装教程</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/37152572">Mysql安装教程</a></p>
<ul>
<li>关于新版的installer的一些使用：</li>
</ul>
<p>由于我下载的时候选择出了一些问题，下载了很多我不需要的东西，后面才发现这个东西很好用。即使用下载好的installer打开后可以进行进一步的配置。</p>
<p><img src="https://gitee.com/alexs-rabbit//blog/raw/master/20210303112714.png" alt="image-20210303112714373"></p>
<p>左边是已经安装好的mysql相关的产品，右边可以选择添加，调整或者删除对应的产品，也可以进行升级，Quick Action里面的Reconfigure可以帮助你快速的调整Mysql的配置。</p>
<ul>
<li>当配置完成环境变量之后：</li>
</ul>
<p><img src="https://gitee.com/alexs-rabbit//blog/raw/master/20210308174233.png" alt="image-20210308174226353"></p>
<p>用cmd登陆mysql , -u表示登陆的账号， -p表示password ，输入完成就可以登陆mysql。</p>
<p><img src="https://gitee.com/alexs-rabbit//blog/raw/master/20210303113119.png" alt="image-20210303113119884"></p>
<p>下面这种也可以的，这种方式可以保护你的密码。</p>
<ul>
<li>服务端口为3306 ， 以及可以在本电脑-&gt;管理中来调整一些类似于开机自动启动的设置。</li>
</ul>
<h3 id="卸载MySQL（血的教训）"><a href="#卸载MySQL（血的教训）" class="headerlink" title="卸载MySQL（血的教训）"></a>卸载MySQL（血的教训）</h3><ul>
<li><strong>卸载mysql有点复杂</strong>，除了在安装包中（就是下载的时候下载的那个msi）中可以remove安装的mysql产品之外，<code>C:\Program Files\MySQL和C:\ProgramData\MySQL和C:\Program Files (x86)\MySQL</code>都要干掉，下次下载才能顺利。</li>
</ul>
<h2 id="SQL与DB与DBMS的关系"><a href="#SQL与DB与DBMS的关系" class="headerlink" title="SQL与DB与DBMS的关系"></a>SQL与DB与DBMS的关系</h2><ul>
<li>SQL也是高级语言，由程序员来写。执行之前也需要进行编译。</li>
<li>SQL由DBMS来执行</li>
<li>DBMS通过执行SQL语句来操作DB中的数据。</li>
<li>说白了MySQL是用来管理数据库的。</li>
</ul>
<h1 id="MySQL语句学习（CRUD）"><a href="#MySQL语句学习（CRUD）" class="headerlink" title="MySQL语句学习（CRUD）"></a>MySQL语句学习（CRUD）</h1><h3 id="语句类型分类"><a href="#语句类型分类" class="headerlink" title="语句类型分类"></a>语句类型分类</h3><pre><code>- DQL ：查询语句 (所有的select有关的)
- DML：数据操作语言（对于数据进行增删改：insert , delete , update）
- DDL：数据定义语言  （对于表结构进行增删改：drop , create , outer）
- TCL：事务控制语言（这里的T为Transaction：roll back之类的）
- DCL：数据控制语言（授权以及撤销权限。）
</code></pre>
<ul>
<li>表的结构是很少动的，因为动表的结构的成本太高了。</li>
<li>导入数据</li>
</ul>
<h3 id="数据实操"><a href="#数据实操" class="headerlink" title="数据实操"></a>数据实操</h3><ul>
<li><p>用cmd或者mysql自带的cmd登录</p>
</li>
<li><p>查看数据库: show databases; （这个不是sql语言，是mysql命令）</p>
</li>
<li><p>创建数据库：create database liututu;（命令）</p>
</li>
<li><p>使用数据库：use liututu; （命令）</p>
</li>
<li><p>查看表格：show tables; （命令）</p>
</li>
<li><p>初始化数据：这里很难实践，如果有.sql为后缀的资源（这种文件被称为sql脚本，其中编写了大量的sql语句，其实本质就是文本文件哈哈哈哈哈哈）的话，可以用：source+资源路径; 来初始化数据表。sql脚本中的数据量太大的时候无法打开，使用source命令完成初始化。</p>
</li>
<li><p>删除数据库： drop databases test;  （sql语言）</p>
</li>
<li><p>查表的结构：desc+表名; </p>
<p><img src="https://gitee.com/alexs-rabbit//blog/raw/master/20210303172517.png" alt="image-20210303172510103"></p>
</li>
<li><p>查看某个表中的数据：select * from table-name</p>
</li>
</ul>
<h3 id="MySQL常用命令"><a href="#MySQL常用命令" class="headerlink" title="MySQL常用命令"></a>MySQL常用命令</h3><ul>
<li>create database …;</li>
<li>查询当前使用的数据库：<ul>
<li>select database();</li>
<li>select version();(查看当前数据库的版本)</li>
<li>实在不知道你可以直接先show databases; 然后再use嘛！！！</li>
</ul>
</li>
<li>结束一条写错的语句，直接加\c可以实现</li>
<li>推出mysql可以用exit</li>
<li>show tables from 表名</li>
<li>desc + 表名</li>
<li>查看创建表的语句： show create table 表名;</li>
</ul>
<h3 id="SQL语句学习"><a href="#SQL语句学习" class="headerlink" title="SQL语句学习"></a>SQL语句学习</h3><h4 id="DQL："><a href="#DQL：" class="headerlink" title="DQL："></a>DQL：</h4><h5 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h5><ul>
<li><p><strong>最基本用法</strong></p>
<p>select 字段名1，字段名2，… from 表名; 不记得表里有哪些东西就先用desc + 表名。大小写都可以，换行也可以，打上分号才才行。</p>
<p>e.g.</p>
<ol>
<li>select ename , sal * 12 from tmp;   (表中字段可以参与数学运算)</li>
<li>select ename , sal * 12 as yearsal from tmp;   （表中字段可以重命名，如果要用中文，要用引号，例如 as ‘年薪’）</li>
<li>这里单双引号都可以，建议单引号。双引号在别的SQL语言里面不一定可以识别，但在Mysql里面可以，为了避免问题，还是用单引号。标准sql语句中，字符串要用单引号括起来。</li>
<li>as关键字可以省略。</li>
<li>查询全部字段:  select * from temp; 私下可以，但是java程序中，实际开发中不要写。这个方式的效率太低了，会影响产品的性能。</li>
</ol>
</li>
<li><p><strong>条件查询</strong>：</p>
<ol>
<li><p>select 字段名1，字段名2，… from 表名 where 条件; 执行顺序是先from , 然后where , 最后select。 e.g. select sal from emp where ename=’SMITH’。另外提醒一下，在mysql中，string就是varchar , 字符串使用单引号括起来。</p>
</li>
<li><p>在sql中，&lt;&gt;就是!=，此外sql中!=也是可以使用的，&lt;&gt;的意思是大于或者小于的，类似于&gt;=表示大于后者等于的</p>
</li>
<li><p>select ename, sal from emp where sal &gt;= 1100 and sal&lt;=3000; ， 等价于 select ename, sal from emp where sal between 1100 and 3000 ; between必须左小右大，表示的是闭区间。</p>
</li>
<li><p>between字符串也是可以的，和计组中学的一样的，可以理解为左闭右开。</p>
</li>
<li><p>is NULL和0是不一样的，当一个位置为空时，要使用is null或者is not null去选出对应的选项。用 =null 是错的，没有这种用法哦。</p>
<p><strong>这里非常重要，NULL表示任何值，所以首先不能用=，其次，不能用in的语法去进行匹配，任何值都可以匹配上NULL，所以在后面的练习题中，要匹配都要搭配is not null来一起使用。</strong></p>
</li>
<li><p>and 和 or 洒洒水啦，很简单的 ， 复杂的话就加括号，永远的神！！！不然的话，and的优先级会大于or ，就可能会gg。</p>
</li>
<li><p>in等同于or , usage: <code>select ename,job from emp where job='salesman' or job='manager'</code>和<code>select ename,job from emp where job in ('salesman','manager')</code>，有点类似于python的感觉。<code>select ename,job from emp where sal in (1000,5000)</code>，in里面对应的不是区间，是确定的多个值！！！！！！not in就是去反面，不在这几个值之中。</p>
</li>
</ol>
</li>
<li><p><strong>模糊查询</strong>：</p>
<p>关键字为like，类似的意思，就是模糊查询</p>
<p>模糊查询必须掌握的特殊符号：%和_</p>
<p>%代表任意多个字符，_代表任意一个字符</p>
<ol>
<li>select ename from emp where ename like ‘%o%’查询名字中有o的</li>
<li>找出名字中第三个为A的，select ename from emp where ename like ‘__A%’</li>
<li>找出名字中有下划线的, select ename from emp where ename like <code>'%\_%'</code></li>
</ol>
</li>
<li><p><strong>排序</strong></p>
<p>关键词为order by</p>
</li>
</ul>
<ol>
<li><p>select ename , sal from emp order by sal; 默认为升序排序，怎么指定升序或者降序？asc表示升序，desc表示降序select ename , sal from emp order by sal desc;</p>
</li>
<li><p>搞心态！！！</p>
<p><img src="https://gitee.com/alexs-rabbit//blog/raw/master/20210303204034.png" alt="image-20210303204033854"></p>
</li>
</ol>
<p>​			按照从左到右顺序来排序，后面的可能都用不上哦。</p>
<pre><code>3. 还可以用select * from emp order by 1 ， 表示按照第1列排序，但是这种方式不够健壮，所以不推荐用这个。

4. 综合使用：select ename , job , sal from emp where job = 'SALESMAN' order by sal desc; 

5. 顺序： from -&gt; where -&gt; select -&gt; order by
</code></pre>
<ul>
<li><p><strong>分组函数</strong>：</p>
<p>count , sum , avg , max , min五个分组函数，count为计数，找出个数</p>
<ol>
<li>select sum(sal) from emp</li>
<li>select max(sal) from emp</li>
<li>select avg(sal) from emp</li>
<li>select count(ename) from emp / select count(*) from emp;</li>
</ol>
<p>分组函数一共五个，都是对于一组数据进行处理的，又叫做多行处理函数。</p>
<ul>
<li>分组函数会自动忽略NULL哦，如果你在对于含有null的列操作的话，那些对应的null的行会被忽略掉</li>
<li>分组函数都会自动忽略null</li>
</ul>
</li>
<li><p><strong>单行处理函数</strong>：</p>
<ol>
<li>有null参与的运算最终的结果也是null，所有数据库都是这样规定的。但是发现sum出问题了！！！！sum函数把null忽略了。但是但是但是！！！(800+null)/2的值也是Null哦！！！</li>
<li>ifnull()为空值处理函数，可能为null的数据被当作什么处理</li>
<li>select ename,ifnull(comm,0) as comm from emp</li>
<li>select enames,(sal+ifnull(comm,0)) as comm from emp</li>
<li>这么叫这个函数，是因为，进去多少行出来多少行，是对于每一行处理的。而多行处理函数则是多对一这种形式哦。</li>
</ol>
</li>
<li><p><strong>特殊的一些规则和用法</strong>：</p>
<ol>
<li><p>找出工资高于平均工资的员工：select ename from emp where sal &gt; avg(sal)  ， 会报错，显示无效使用了分组函数。<strong>SQL语句中有一个规则，分组语句不可以直接出现在where后面！！！</strong></p>
</li>
<li><p>这儿就要改！！！</p>
<p>select avg(sal) from emp;</p>
<p>select ename , sal from emp where sal &gt; 2073.214286</p>
<p>=========================&gt;</p>
<p>select ename , sal from emp where sal &gt; (select avg(sal) from emp) ;   这个是子查询！！！select语句的嵌套</p>
</li>
<li><p>select sum(comm) from emp where comm is not null 没有必要这么写，分组函数自动忽略null</p>
</li>
<li><p>select count(*) from emp; 统计总记录条数，select count(sal) from emp; 记录的是salary的不为null的数据的条数。 两者的区别使用的时候要注意。</p>
</li>
<li><p>分组函数可以组合使用。select count(*) , avg(sal) from emp;</p>
</li>
<li><p>mysql中，指令是不区分大小写的，但是数据是有大小写的哦，数据的大小写是有区分的。</p>
</li>
<li><p>as是用来重命名的，如果后面为英文不用单引号，如果是中文就要用字符串的形式括起来啦！</p>
</li>
</ol>
</li>
<li><p><strong>group by 和 having</strong>:</p>
<p>group by：按照某个字段或者某些字段进行分组</p>
<p>having：对于分组之后的数据进行再次过滤</p>
<ol>
<li><p>找出每个岗位的最高薪资： select max(sal) from emp group by job , mention: 分组函数一般都会和group by 联合使用。</p>
</li>
<li><p><strong>正是因为上面那五个分组函数，很多情况都是与group by一起使用，并且都是在group by以后执行，因此叫分组函数。当一条sql语句没有group by 的话，整张表会自成一组，也是默认要group by的！！！</strong>（先分组，后执行）</p>
</li>
<li><p>分组函数不能用于where后面，<strong>因为先执行where，然后才执行group by , 最后才执行分组函数</strong>，因此在后面执行不了啊兄dei。（where的时候还没分组，你上哪儿用分组函数啊？？？）</p>
</li>
<li><p>```sql<br>select	5<br>…<br>from	1<br>…<br>where	2<br>…<br>group by	3 //之后才能用分组函数<br>…<br>having	4<br>…<br>order by	6<br>…</p>
<pre class="line-numbers language-none"><code class="language-none">
     指令执行顺序

  5. 记住：where后面绝对不能用分组函数！！！！！嵌套的话可以哦！！！！！！

  6. select ename , max(sal) , job from emp group by job;   这个不行的哈，明显有问题，因为这个ename没有参与分组啊！！！Mysql不报错但是结果没有意义，oracle会报错，这个有隐患的，不要用嗷！！！

  7. 得出结论，group by 出现的话，前面只能跟分组函数和参与分组的字段，别的都不能跟着。

  8. 找出每个部门，不同工作岗位的最高薪资：select deptno , job , max(sal) from emp group by deptno,job ;

  9. 找出每个部门的最高薪资，要求显示薪资大于2900的数据： 

     select max(sal) , deptno from emp group by deptno having max(sal) &gt; 20 -- having是用于group by之后进行信息过滤的。这里用where好一点，不然的话分组了，找了最大值，后面又扔了效率就低了。where在having之前和分组之前执行的，先把没必要的扔了，效率就高了。

     

     select max(sal) , deptno from emp where sal&gt;2900 group by deptno; //这个和上面相比效率高一些

     这里是   对于所有数据不经过分组处理就使用where，对于分组处理前的数据进行筛选是可以用where的！！！

  10. 找出部门的平均薪资，要求显示薪资大于2000的数据

      select deptno , avg(sal) from emp group by deptno having avg(sal) &gt; 2000; 这样就只能用having , 因为where后面不能接avg！！！这里是对于所有数据分组处理后，对于处理后的数据做筛选，这个时候where就失效了，就只能用having了。

  11. having是group by的搭档，是对于group by后的数据进行处理的。没有group by是不能用having的。

- **sql的处理**：

  1. select	5
     	...
     from	1
     	...
     where	2
     	...
     group by	3 //之后才能用分组函数
     	...
     having	4
     	...
     order by	6
     	...
  2. 上面这个顺序编程的时候是不能变的，执行就是先从表中取出，然后用where筛选第一次，分组后，再筛选一次，取出来，排序，执行时这个循序。

- **去除重复记录**：

  1. select **distinct** job from emp;
  2. select ename , **distinct** job from emp;这个是错的，distinct只能出现在所有字段的最前方。表示联合去除重复的记录，将多个字段联合起来去重。
  3. 统计岗位的数量，select count(distinct(job)) from emp;





##### 两表连接

- **连接查询**：

  1. 多张表联合查询出最终的结果，一个业务会对应多张表，数据会有冗余，数据库中尽量不出现重复的数据。

2. 分类：

   - 根据语法出现的年代划分：

     - SQL92
       - SQL99 （这个才是比较新的语法）

   - 根据表的链接方式来划分：

     - 内连接：

       - 等值连接
         - 非等值连接

       - 自连接

     - 外连接：

       - 左外连接（左连接）
         - 右外连接（右连接）

     - 全连接（这个不讲，很少用）
  3. 笛卡尔积现象（笛卡尔乘积现象） e.g.  select ename , dname from emp , dept;  结果是两个表数量的乘积，这个就仅仅是简单的排列组合。定义：当两张表进行连接查询的时候，没有限制，则结果是两张表记录条数的乘积。

  4. 关于表的别名：`select e.ename,d.dname from emp e, dept d;`，这样就可以取别名，方便一些。这儿的意思是e.ename和d.dname要粘贴在一起，进行匹配，这就是原理。
  5. 如何避免？条件过滤！！！这种方式不会减少匹配的次数，只会减少显示的有效记录而已，底层是一样实现的，还是要一一匹配然后去判断。e.g. select e.ename , d.dname from emp e, dept d where e.deptno = d.deptno。匹配次数还是54次，这个是sql 92语法，已经out了，以后不用了。



###### 内连接：

1. 等值连接：
   - 特点：条件是等量关系。
   - SQL92: `e.g.select e.ename , d.dname from emp e, dept d where e.deptno = d.deptno。`
   - SQL99:`e.g.select e.ename , d.dname from emp e join dept d on e.deptno = d.deptno`
   - 99语法：`select ... from ... join ... on ... where ...`，表的连接和连接后的数据过滤分开来了，结构更加清晰一些，表的连接和后面的where分离了。
   - 由于on的条件是等号，因此叫做等值连接，这里的join前面其实少了一个inner , 表示的应该是inner join。带上Inner可读性好一些
2. 非等值连接：
   - 特点：找出每个员工的工资等级：
   - 找出所有员工的工资等级： select e.ename , e.sal , s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;
   - 逸豪的想法：本质上可以先表拼接，然后再去根据行之间数据的关系去构造非等值连接。
3. 自连接：
   - 特点：一张表看作两张表。自己连接自己
   - 找出员工和他的领导！！！select e.ename as ename , e.mgr  as managerId, s.ename as boss from emp e join emp s on e.mgr = s.empno; 本质就是分别用两个别名表示一样的表即可看作两张表来使用嗷QAQ！！！
   - 记得起别名！！！
   - summary: 这儿要记一下，其实可以看做从A表拿一条data , 从B表拿一条data，根据每一行中某些数据的大小关系，判定要不要取出来。

###### 外连接：

​	什么是内连接？

把A和B表能够匹配上的记录查询出来，这就是内连接。

​	什么是外连接？

AB两张表中一张是主表，一张是附表。当附表中的数据没和主表匹配上，附表会自动生成NULL与之匹配。A是主角，B是附表。

1. 左连接

   - 左边的表是主表

   - 找出每个员工的上级领导！！！`e.g.select e.ename '员工' , s.ename '领导' from emp e left join emp s on e.mgr = s.empno; `

2. 右连接

   - 右边的表是主表
   - 找出每个员工的上级领导！！！`e.g.select e.ename '员工' , s.ename '领导' from emp e right join emp s on e.mgr = s.empno; `
   - summary: 左连接就是左边是主表，右连接右边是主表，同理，outer时可以省略的。能省略是因为重点不在这两个单词，有的话可读性会更好嗷！！！
   - 例题，找出哪个部门没有员工：显然部门是主表嗷！！！`e.g. select e.* , d.* from emp e right join dept d on e.deptno  = d.deptno on e.empno is NULL;`

###### 全连接：

- 情况比较特殊，应用场景较少，业务场景也较少，有兴趣的话自己自学。



##### 多表查询

- 找出每一个员工的部门名称以及工资等级
- 规则： `from A join B on ... join C on ...`（表示A和B先进行连接，连接后的结果再和C连接 ）`select e.ename , d.dname , s.grade from emp e join dept d on e.deptno = d.deptno join salgrade s on e.sal between s.losal and s.hisal;`
- 又有一个例子：找出每一个员工的部门名称，工资等级以及上级领导。`select e.ename , d.dname , s.grade , el.ename '领导' from emp e join dept d on e.deptno = d.deptno join salgrade s on e.sal between s.losal and s.hisal left join emp el on e.mgr= el.empno;`表可以认为从左往右不断迭代的，因此要注意不同的表之间的inner和outer的关系嗷呜！！！



##### 子查询

select里面嵌套select语句，子查询可以出现在：`select...(select) from ...(select) where ...(select)`

- 找出高于平均薪资的员工信息：(where后面加select)

  - 第一步： select  avg(sal) from emp;
  - 第二步：select * from emp where sal &gt; 2073.214286
  - 合并：select * from emp where sal &gt; (select avg(sal) from emp);

- 找出每个部门平均薪水的等级：(from后面加入select)

  - 第一步：select deptno , avg(sal) as avgsal group by deptno;

  - 第二步：

    ```sql
    select
    	t.* , s.grade
    from 
    	(select deptno , avg(sal) as avgsal group by deptno) t
    join salgrade
    	s
    on
    	t.avgsal between s.losal and s.hisal;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
</li>
<li><p>找出每个部门平均的薪水等级：(from后面加入select)</p>
<ul>
<li><p>第一步：<code>select e.ename ,  e.sal , s.grade from emp e join salgrade s on s.losal and s.hisal;</code></p>
</li>
<li><p>第二步：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> 
e<span class="token punctuation">.</span>ename <span class="token punctuation">,</span>  e<span class="token punctuation">.</span>sal <span class="token punctuation">,</span> s<span class="token punctuation">.</span>grade <span class="token punctuation">,</span> <span class="token function">avg</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>grade<span class="token punctuation">)</span>
<span class="token keyword">from</span> 
emp e 
<span class="token keyword">join</span> 
salgrade s 
<span class="token keyword">on</span>
e<span class="token punctuation">.</span>sal <span class="token operator">between</span> s<span class="token punctuation">.</span>losal <span class="token operator">and</span> s<span class="token punctuation">.</span>hisal
<span class="token keyword">group</span> <span class="token keyword">by</span>
e<span class="token punctuation">.</span>deptno<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>找出每个员工所在的部门名称，要求显示员工名和部门名：(select后面接上select):</p>
<ul>
<li><code>select e.ename,e.deptno,(select d.dname from dept d where e.deptno = d.deptno) as dname from emp e;</code></li>
</ul>
</li>
</ul>
<h5 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h5><ul>
<li><p>可以将查询结果相加</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> ename <span class="token punctuation">,</span> job <span class="token keyword">from</span> emp <span class="token keyword">where</span> job <span class="token operator">=</span> <span class="token string">'MANAGER'</span>
<span class="token keyword">union</span>
<span class="token keyword">select</span> ename <span class="token punctuation">,</span> job <span class="token keyword">from</span> emp <span class="token keyword">where</span> job <span class="token operator">=</span> <span class="token string">'SALESMAN'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>可以将毫不相关的结果从下往下拼接起来。</p>
</li>
</ul>
<h5 id="limit-mysql中特有的"><a href="#limit-mysql中特有的" class="headerlink" title="limit(mysql中特有的)"></a><strong>limit(mysql中特有的)</strong></h5><ul>
<li>分页查询用得到</li>
<li>limit取结果集中的部分数据，</li>
<li>语法: limit startIndex , length 分别表示起始位置，表示取几个。<code>e.g. select ename , sal from emp order by sal desc limit 0,5;</code>先排序，再取5个，也可以直接写limit 5; limit是最后才执行的</li>
</ul>
<h5 id="通用标准分页sql"><a href="#通用标准分页sql" class="headerlink" title="通用标准分页sql"></a>通用标准分页sql</h5><ul>
<li><p>例如 ，每页显示三条记录：<code>一页： 0,3  二页：3,3 三页：6,3 四页：9,3</code>，所以可以看出来，对于第n页有 (pageNo - 1) *pagesize , pageSize</p>
</li>
<li><p>java代码：</p>
<pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">int</span> pageNo <span class="token operator">=</span> <span class="token number">2</span>
<span class="token keyword">int</span> pageSize <span class="token operator">=</span> <span class="token number">10</span>

limit <span class="token number">10</span> <span class="token punctuation">,</span> <span class="token number">10</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<h4 id="DDL："><a href="#DDL：" class="headerlink" title="DDL："></a>DDL：</h4><ul>
<li><p>creat</p>
<ul>
<li>创建表格的语句格式：</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> Tabel_Name<span class="token punctuation">(</span>
	Field1 Type1<span class="token punctuation">,</span>
	Field2 Type2<span class="token punctuation">,</span>
	<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>数据类型：</p>
<ul>
<li><p>int（对应java中的int）</p>
</li>
<li><p>bigint   长整型（对应java中的long）</p>
</li>
<li><p>float    浮点型（对应java中的float double）</p>
</li>
<li><p>char     定长字符串（对应java中的String）</p>
</li>
<li><p>varchar     可变长字符串（最多存255个字符，对应java中的StringBuffer/StringBuilder）</p>
</li>
<li><p>date     日期类型（存储日期，对应java.sql.Date类型）</p>
</li>
<li><p>blob     二进制大对象（存储图片，视频等流媒体信息，Binary Large Object，对应java中的Object）</p>
</li>
<li><p>clob     字符大对象（存储大文本，例如 可以储存4G的字符串，Character Large Object对应java中的object）</p>
<p>……</p>
</li>
</ul>
</li>
<li><p>char和varchar如何选择？明显看长度的关系啦！！！例如Name字段，如果少于Char，没问题，多余Char，爆了。Varchar比char智能一点，Varchar只要不超过限定的范围，底层是可以自动根据你输入的数据来分配空间的。Char的话，分配的空间就定死了。比如一个数据类型的长度始终是固定的，例如生日啊，男女性别啊，就用char , 其他不定的情况就用varchar, 例如简介啊，姓名啊之类的。char的效率比varchar要高嗷！！！</p>
</li>
<li><p>clob和blob怎么使用，大文本用CLOB，图片啊之类的数据必须使用BLOB，Java中必须使用IO流才能写入BLOB。图片啊之类的如果大的话就别放在db里面了嗷！</p>
</li>
<li><p>表名再数据库中一般建议以t_或者tbl_开始。</p>
</li>
<li><p>举个例子：创建学生表   学号：bigint , 姓名：varchar , 班级编号：int</p>
</li>
</ul>
<p>性别：char ,  生日：char</p>
</li>
</ul>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> t_student<span class="token punctuation">(</span>
	<span class="token keyword">no</span> <span class="token keyword">bigint</span><span class="token punctuation">,</span>
	names <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	sex <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	classno <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	birth <span class="token keyword">char</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>create另一种用法：（表的复制）</p>
<ul>
<li><code>create table emp as select emp.ename from emp;</code></li>
<li>create table 表名 as select语句，将查询结果当作表创建出来</li>
</ul>
</li>
<li><p>删除表格：</p>
<ul>
<li>drop table 表名;</li>
<li>drop table if exits 表名; 如果表存在的话就把表删掉。</li>
</ul>
</li>
<li><p>alter table 表名 rename to 新表名 ， 表的重命名</p>
</li>
<li><p>对于表的结构的修改这里暂时不讲了，因为实际开发过程中用的比较少，即使修改也可以使用工具，出现在java代码中的数据只有增删改查操作(CRUD) —-&gt; Create Retrieve Update Delete</p>
</li>
</ul>
<h4 id="DML："><a href="#DML：" class="headerlink" title="DML："></a>DML：</h4><ul>
<li><p>insert</p>
<p>写法一：</p>
<ul>
<li><code>insert into t_student values(1, 'Jack', 'o','高三二班,'1996-10-12')</code></li>
</ul>
<p>写法二：</p>
<ul>
<li><code>insert into t_student(name) values('ZhangSan')</code>，这个东西实际上，会自动把他补上</li>
<li>列的数量必须和给予数据的数量相同，字段省略不写的话，后面的顺序和数量就要和默认表的一样的。</li>
</ul>
<p>写法三：</p>
<ul>
<li><code>insert into t_student(no,name) values(2,'兔子'),(3,'乐乐') </code></li>
</ul>
</li>
<li><p>insert</p>
<ul>
<li><code>insert into tbl1 select * from dept;</code>这个不一定可以哦，列数相同才对的上哦。将查询结果当作数据插入到表里。</li>
</ul>
</li>
<li><p>update</p>
<ul>
<li>用于修改条件的时候使用的</li>
<li>update 表名 set 字段1=值1 , … where 条件; 如果不写条件的话就是整整一张表都要更新哦！这里多个条件的设置是用“，”哦，不是用and呢！！！</li>
<li>更新所有记录：<code>update dept1 set loc = 'x' , dname = 'y'</code></li>
</ul>
</li>
<li><p>delete</p>
<ul>
<li>用于删除数据</li>
<li>没有条件会全部删除</li>
<li><code>delete from dept1 where deptno=10;</code></li>
<li>全部删除：delete from dept1;</li>
<li>执行语句比较慢，而且不释放空间，可以回滚，这个是可以追溯的。如果要删的快而且删的彻底的话。</li>
<li>truncate table 表名;  表被截断，不可回滚，彻底丢失。这个是把表截断，只留下表头，其他彻底删除。</li>
</ul>
</li>
</ul>
<h1 id="创建表加入约束"><a href="#创建表加入约束" class="headerlink" title="创建表加入约束"></a>创建表加入约束</h1><ul>
<li>什么是约束：例如数据不能重复，数据不能为空之类的，约束的目的在于保证表中的数据的合法性，有效性，完整性</li>
<li>种类：<ul>
<li>非空约束(not null)：约束的字段不能为Null</li>
<li>唯一约束(unique)：约束的字段不能重复</li>
<li>主键约束(primary key)：约束的字段不能为NULL，也不能重复</li>
<li>外键约束(foreign key)：</li>
<li>检查约束(check)：Oracle中有check约束 , mysql目前不支持该约束</li>
</ul>
</li>
</ul>
<h2 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h2><ul>
<li>一个例子：<ul>
<li><code>create table t_user(id int, username varchar(255) not null, password varchar(255));</code></li>
<li>这个只能加在字段后面，是不可以作为表级约束的。</li>
</ul>
</li>
</ul>
<h2 id="唯一性约束"><a href="#唯一性约束" class="headerlink" title="唯一性约束"></a>唯一性约束</h2><ul>
<li><p>unique , 修饰的字段具有唯一性，不能重复，但可以为NULL，NULL和NULL是不一样的，可以重复。</p>
</li>
<li><pre><code class="sql">create table t_user(
    id int,
    username varchar(255) unique
)
<pre class="line-numbers language-none"><code class="language-none">
- 注意一下，唯一性是可以为NULL的，给多个列添加unique

- 此外，在insert中，可以选择插入的字段，其余的字段会用系统初始的默认值，如果在create表的时候，在字段后面给予了自定义的默认值，则默认的值为你定义的默认值。

- 给多个列加unique:

  - ```sql
    create table t_user(
    	id int,
    	username varchar(255),
    	usercode varchar(255),
    	unique(usercode,username)
    );//这个是两个数据联合起来添加一个约束，就是说这两个不能同时相同<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><pre><code class="sql">create table t_user(	
    id int,
    username varchar(255) unique,
    usercode varchar(255) unique
);//这个是对于两个字段分别添加约束，每一个都不能重
<pre class="line-numbers language-none"><code class="language-none">
- 这里就有两个概念，上面一个是列级约束，上面第二个是表级约束。

- 非空约束只能在字段后面加，往后面加是没有表级约束的。



## 主键约束

- ```sql
  create table t_user(	
  	id int primary key, // 列级约束
  	username varchar(255) unique,
  	usercode varchar(255) unique
  );//主键字段不能为空，也不能重复<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p>主键相关的术语：</p>
<ul>
<li>主键字段</li>
<li>主键值</li>
<li>主键约束</li>
</ul>
</li>
<li><p>作用：</p>
<ul>
<li><p>sql设计三范式中有要求，要求任何一张表都有主键</p>
</li>
<li><p>主键的作用是啥？</p>
<ul>
<li>主键是一行的唯一标识，就像身份证号码一样，只要主键值不一样，就可以认为两条记录完全不一样。</li>
</ul>
</li>
<li><p>主键的分类：</p>
<ul>
<li>按照主键字段和数据量：<ul>
<li>单一主键（常用到的）</li>
<li>复合主键（不常用，违背三范式，多个字段联合起来添加一个主键约束）</li>
</ul>
</li>
<li>根据主键性质来划分：<ul>
<li>自然主键（推荐，这种方式和业务无任何挂钩，推荐）</li>
<li>业务主键：最好主键和其他值不挂钩，比如说id和身份证分开，不用身份证做主键。不然业务一旦发生改变的时候，主键可能也跟着发生变化，但是有时候可能没有办法变化，这就很尴尬。</li>
</ul>
</li>
</ul>
</li>
<li><p>一个表中主键约束只能有一个</p>
</li>
<li><p>使用标记约束定义主键：</p>
<ul>
<li>```sql<br>create table t_user(<br>id int,<br>username varchar(255),<br>primary key(id)<br>);<pre class="line-numbers language-none"><code class="language-none">
- ```sql
  create table t_user(
  	id int,
  	username varchar(255),
  	primary key(id,username)
  );<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p>mysql提供主键值自增：</p>
<ul>
<li>```mysql<br>create table t_user(<br>id int primary key auto_increment,   //id字段自动维护一个自增的字段，从1开始，以1自增<br>username varchar(255)<br>);<pre class="line-numbers language-none"><code class="language-none">
  - Oracle中也提供了一个自增机制，叫做sequence（序列）

## 外键约束

- 相关术语：

  - 外键约束：foreign key
  - 外键字段：添加有外键约束的字段
  - 外键值：外键字段中的每一个值

- 业务背景：

  - 设计数据表，用来维护学生和搬家的信息

  - 做法和想法：

    - 放在一张表中（缺点是冗余）
    - 放在两张表中（班级表和学生表）

  - 比如上面两张表要关联起来，我们就需要外键，不加外键约束的话可以随便写，而如果添加了外键的话，写的值就有一定的范围的。

  - t_student中的classno字段引用t_class表中的cno地段，此时t_student表叫做组表，t_class表叫做父表。删除数据的时候先删除子表再删除父表，创建或者添加数据的时候，先添加父表再添加子表。两张表之间有明显的依赖关系。

  - ```sql
    create table t_class(
    	cno int,
    	cname varchar(255),
    	primary key(cno)
    );
    
    create table t_student(
    	sno int primary key auto_increment,
    	sname varchar(255),
        classno int,
        primary key(sno),
    	foreign key(classno) references t_class(cno)
    );
    
    //先插入父表数据，再插入子表数据
    insert into t_class values(101,'xxxxxxxxx');
    insert into t_class values(102,'yyyyyyyyy');
    insert into t_student values('zs1',101);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>外键值可以为NULL？</p>
<ul>
<li><code>insert into t_student(sno,sname) values(6,'zs6')</code></li>
<li>外键可以为NULL</li>
</ul>
</li>
<li><p>外键字段引用别的表的字段的时候，被引用的字段必须是主键否？不一定，但是对应的字段必须要是唯一的。不然对应的外键说不清对应的是哪一个，一般情况下都是要对应主键的，不对应的话至少要有unique约束</p>
</li>
</ul>
<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><ul>
<li><p>描述的表的存储方式，例如InnoDB , <code>ENGINE=InnoDB</code>等</p>
</li>
<li><p>完整的建表语句还要加上engine的，例如</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>t_x<span class="token punctuation">`</span></span><span class="token punctuation">(</span>
	<span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span>
<span class="token punctuation">)</span>ENGINR<span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf<span class="token operator">-</span><span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>mention: 在mysql中，凡是自己定义的标识符都是可以使用飘号括起来的，最好别用，不是通用的。</p>
<p>建表的时候使用的引擎是InnoDB，默认的字体为utf-8</p>
</li>
<li><p>what is engine? 这个名字只有在mysql中存在，oracle中则有对应的机制，但是不叫存储引擎。每一个存储引擎都有自己的优缺点。</p>
</li>
<li><p>查看当前mysql支持的存储引擎，<code>show engines \G;</code></p>
</li>
<li><p>经典的存储引擎有：</p>
<ul>
<li>InnoDB：<ul>
<li>是数据库的默认引擎</li>
<li>优缺点：<ul>
<li>优点：支持事务，行级锁，外键。数据存储比较安全。表的结构存储在xxx.frm文件中。在mysql数据库崩溃后自动恢复。支持级联删除，级联更新（父级会影响所有的孩子，开发的时候比较少用）。事务，安全，重量级。</li>
<li>缺点：处理速度不是最快的</li>
</ul>
</li>
</ul>
</li>
<li>MyISAM：<ul>
<li>之前最常用的存储引擎</li>
<li>采用三个文件表示每个表：<ul>
<li>格式文件</li>
<li>数据文件</li>
<li>索引文件</li>
</ul>
</li>
<li>优缺点：<ul>
<li>优点：可被压缩，节省存储空间。可压缩，可转换形式，节省空间。</li>
<li>缺点：不支持事务</li>
</ul>
</li>
</ul>
</li>
<li>Memory:<ul>
<li>优缺点：<ul>
<li>缺点：<ul>
<li>不支持事务</li>
<li>数据容易丢失，数据和索引都是在内存当中</li>
<li>不能包含TEXT和BLOB</li>
<li>断电后数据就丢失了。</li>
</ul>
</li>
<li>有点：<ul>
<li>搜索速度最快</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="事务（Transaction）概述："><a href="#事务（Transaction）概述：" class="headerlink" title="事务（Transaction）概述："></a>事务（Transaction）概述：</h1><ul>
<li>一个事务是一个完整的业务逻辑单元，不可再分。（相当于原子操作！！！和操作系统就连上了，本质上实现了线程同步！！！）</li>
<li>例如：从银行转账，从A账户转B账户10000元，那有转入和转出两条语句。想要保证上面两条操作同时成功或者同时失败，就要使用数据库的“事务机制”。</li>
<li>只有DML语句才有事务，其他的语句和事务都没关系，因为只有这三条语句才和数据操作有关。事务时为了保证数据的<strong>完整性，安全性</strong>。</li>
<li>假设所有的业务都能使用一条DML解决，那就不需要事务了。只有需要多个DML操作组合成一个事物的时候，才需要事务操作。通常一个事务多条DML才需要操作。</li>
<li>本质相当于将多条DML语句打包成原子操作！！！</li>
<li>原理，how to control ？<ul>
<li>开启事务机制：<ul>
<li>执行insert，先执行保存到操作历史中，不会操作硬盘上的数据</li>
<li>执行update，先执行保存到操作历史中，不会操作硬盘上的数据</li>
<li>执行delete，先执行保存到操作历史中，不会操作硬盘上的数据</li>
<li>最后提交或者回滚事务：（本质就是操作绑定嘛！！！）<ul>
<li>提交：将历史操作更改同步到硬盘文件当中，并将历史操作清空。（成功）</li>
<li>回滚：直接清空历史记录，不同步到硬盘当中。（失败）</li>
</ul>
</li>
<li>提交事务：commit , 回滚事务：rollback</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="TCL"><a href="#TCL" class="headerlink" title="TCL:"></a>TCL:</h3><ul>
<li>commit-提交</li>
<li>rollback-回滚</li>
<li>savepoint: 保存点，可以滚到某一个点，相当于保存游戏进度。</li>
</ul>
<h3 id="事务的特性："><a href="#事务的特性：" class="headerlink" title="事务的特性："></a>事务的特性：</h3><ul>
<li>原子性：事务是最小的工作单元，不可再分。(A)</li>
<li>一致性：事务必须保证多条DML语句同时成功或者同时失败。(C)</li>
<li>隔离性：事务A与事务B之间具有隔离。（隔离级别的概念，级别不一样，影响效果不同。）(I)</li>
<li>持久性：持久性说的是数据最终必须持久化到硬盘文件中，事务才算成功的结束。(D)</li>
</ul>
<h3 id="事务的隔离性："><a href="#事务的隔离性：" class="headerlink" title="事务的隔离性："></a>事务的隔离性：</h3><ul>
<li><p>隔离级别：</p>
<ul>
<li>理论上包括四个：<ul>
<li>第一级别：读未提交(read uncommitted)：别人未提交的事务的我们当前事务能够读到。存在脏读（Dirty Read）现象，读到了脏的数据。</li>
<li>第二级别：读已提交(read committed)：对方提交的事务我们才能读到。解决了脏读的问题，但是存在不可重复读的现象，别人改了我的数据的话，每次读到的都是最新的数据，出来的结果是不一样的。</li>
<li>第三级别：可重复读(repeatable read)：解决了不可重复读的问题。但是存在的问题是，读取到的数据是幻象。每次读的数据都是备份数据，所以都是相同的，存在读的是假数据的问题。</li>
<li>第四级别：序列化读/串行化读(serializable)，解决了所有问题。但是效率低，需要事务排队。</li>
</ul>
</li>
<li>mysql默认是第三级别，oracle默认是第二级别。</li>
</ul>
</li>
<li><p>mysql事务默认是自动提交的，就是执行一条DML，自动提交一次。</p>
</li>
<li><p>how to close自动提交：</p>
<ul>
<li><p>start transaction ;  //这个会开启事务，关闭自动提交机制。</p>
</li>
<li><p>演示：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">drop</span> <span class="token keyword">table</span> <span class="token keyword">if</span> <span class="token keyword">exists</span> t_user<span class="token punctuation">;</span>
<span class="token keyword">create</span> <span class="token keyword">table</span> t_user<span class="token punctuation">(</span>
	id <span class="token keyword">int</span> <span class="token keyword">primary</span> <span class="token keyword">key</span> <span class="token keyword">auto_increment</span><span class="token punctuation">,</span>
    username <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">255</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">rollback</span><span class="token punctuation">;</span> <span class="token comment">//这个是回不去的，自动提交了。。。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>感觉有点像git的使用！！！</p>
</li>
<li><p>rollback等命令执行完之后，事务就结束了，如果还要写事务，还记得要加start transaction，这个就类似于开启git功能？？？</p>
</li>
</ul>
</li>
<li><p>savepoint name; 设置保存点，再输入rollback name; ， 这就可以滚回提交点了。</p>
</li>
<li><p>更改隔离级别：<code>set global transaction isolation level read uncommitted;</code>其他的用法都是一样的，只是后面改个名字而已。</p>
</li>
<li><p>查看事务的全局隔离级别：<code> select @@global.transaction_isolation;</code></p>
</li>
<li><p>可以同时打开两个终端显示操作来演示嗷！！！每种都有自己各自符合的方式嗷！！！</p>
</li>
</ul>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><ul>
<li><p>什么是索引，有什么用：</p>
<ul>
<li>相当于一本书的目录，通过目录可以快速找到对应的资源。数据库方面，一张表的查询有两种方式：<ul>
<li>全表扫描</li>
<li>根据索引检索（效率很高）</li>
</ul>
</li>
<li>第二种由于缩小了扫描的范围，因此可以提高检索的效率。索引虽然效率高，但是不能随意添加索引，因为索引是数据库中的数据，也是有维护成本的。</li>
<li>索引是给某一个字段，或者说某些字段添加索引。</li>
</ul>
</li>
<li><p>什么时候考虑添加索引呢？</p>
<ul>
<li>数据量庞大。（根据客户的要求，根据线上的环境）</li>
<li>该字段很少的DML操作。（因为字段进行修改操作，索引也需要维护）</li>
<li>该字段经常出现在where子句中。（经常根据哪个字段查询）</li>
</ul>
</li>
<li><p>注意：主键和具有unique约束的字段会自动添加索引。</p>
</li>
<li><p>普通的select语句，where后面的操作都是全表扫描</p>
</li>
<li><p><code>explain select ...</code>这个后面跟着会显示类似于type之类的信息。可以查看mysql中语句的执行计划</p>
</li>
</ul>
<h2 id="添加索引："><a href="#添加索引：" class="headerlink" title="添加索引："></a>添加索引：</h2><ul>
<li><code>craete index emp_sal_index on emp(sal);</code></li>
<li>底层用的是B-Tree数据结构，查询效率很高。</li>
<li>再去查看查询的条数之类的，发现明显变少</li>
<li><code>create index index_name on table_name(字段);</code></li>
</ul>
<h2 id="删除索引："><a href="#删除索引：" class="headerlink" title="删除索引："></a>删除索引：</h2><ul>
<li><code>drop index index_name on table_name;</code></li>
</ul>
<h2 id="底层数据结构："><a href="#底层数据结构：" class="headerlink" title="底层数据结构："></a>底层数据结构：</h2><ul>
<li>B+Tree</li>
<li>底层原理：<ul>
<li>当字段上没有索引的时候，全表扫描，效率较低</li>
<li>处理：<ul>
<li>首先，索引会对于记录进行排序</li>
<li>接下来，会在硬盘文件或内存（不同的引擎不同）生成索引对象</li>
<li>然后，索引会分区，例如人名的话，就会用名字字母分区，储存为B+树。</li>
</ul>
</li>
<li>select的时候，首先查看ename字段有没有对应的索引，如果有的话，根据索引对于数据进行定位，缩短了扫描的数量，很快定位到了。oracle中物理地址就是rowid。这个树中，还携带了物理地址，根据索引对应的物理地址，拿到物理地址对应的对象，不走表了，直接根据地址拿到数据。（二分查找）</li>
</ul>
</li>
<li>索引不是万能的</li>
<li>总结：B Tree缩小了扫描范围，底层索引进行了排序，分区，索引携带“物理地址”。通过索引检索到数据，获得关联的物理地址，通过物理地址，定位表中的数据，效率是最高的。</li>
</ul>
<h2 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h2><ul>
<li>单一索引：单个字段添加索引</li>
<li>复合索引：多个字段联合添加索引</li>
<li>主键索引：主键自动添加索引</li>
<li>唯一索引：有unique约束的字段自动添加索引</li>
</ul>
<h2 id="索引失效："><a href="#索引失效：" class="headerlink" title="索引失效："></a>索引失效：</h2><ul>
<li>模糊查询的时候，例如通配符，”%A%”没办法用B树去索引，第一个尽量不要使百分号。这样会造成索引失效。</li>
</ul>
<h1 id="视图-view"><a href="#视图-view" class="headerlink" title="视图(view)"></a>视图(view)</h1><ul>
<li>what is view?<ul>
<li>站在不同的角度去看到数据</li>
</ul>
</li>
<li>how to create / delete view?<ul>
<li>create view view_name as select empno,ename from emp; </li>
<li>对于视图的增删改查，会影响到原表的数据，但是是通过视图来实现的。（不是直接操作原表）</li>
<li>只有DQL语句才能创建视图，但是对于视图可以CRUD操作。</li>
</ul>
</li>
<li>为啥要引入视图呢？<ul>
<li>保密，只给你部门的数据，甚至重命名，对应的数据也可以不给你的，但是对于视图的操作，可以直接作用到原表上。</li>
<li>视图可以隐藏表的实现细节，适用于保密级别较高的系统。</li>
</ul>
</li>
</ul>
<h1 id="数据库的数据的导入导出"><a href="#数据库的数据的导入导出" class="headerlink" title="数据库的数据的导入导出"></a>数据库的数据的导入导出</h1><ul>
<li>DBA命令：导入，导出（被封）</li>
</ul>
<h2 id="导出数据："><a href="#导出数据：" class="headerlink" title="导出数据："></a>导出数据：</h2><p>Windows中的dos命令窗口：</p>
<ul>
<li><code>mysqldump sql-name&gt;某个盘\test.sql -uroot -ppassword</code></li>
</ul>
<h2 id="导入数据："><a href="#导入数据：" class="headerlink" title="导入数据："></a>导入数据：</h2><ul>
<li>create database …;</li>
<li>use databasename;</li>
<li>source sql文件</li>
</ul>
<h2 id="导出指定表："><a href="#导出指定表：" class="headerlink" title="导出指定表："></a>导出指定表：</h2><ul>
<li><code>mysqldump databaseName tableName&gt;.sql文件 -uroot -ppassword</code></li>
</ul>
<h1 id="数据库设计三范式"><a href="#数据库设计三范式" class="headerlink" title="数据库设计三范式"></a>数据库设计三范式</h1><ul>
<li><p>what?</p>
<ul>
<li>设计表的依据，这么设计不会出现冗余</li>
</ul>
</li>
<li><p>是哪些？</p>
<ol>
<li>任何一张表都应该有主键，并且每一个字段的原子性不可再分。</li>
<li>在一范式基础上，所有非主键字段必须完全依赖主键，<strong>不能产生部分依赖</strong>。（有可能出现数据冗余，不推荐复合主键）。</li>
<li>在二范式基础上，所有非主键关系直接依赖主键字段，<strong>不能产生传递依赖</strong>。（例如班级和班级序号，这就产生了传递依赖，传递依赖本质就是出现了数据冗余。）</li>
</ol>
</li>
<li><p>两条口诀：</p>
<ul>
<li>多对多，三张表，关系表，两外键。</li>
<li>一对多，两张表，多的表，加外键。</li>
</ul>
</li>
<li><p>实际开发中，以满足客户需求为主，有的时候会拿冗余换执行速度。</p>
</li>
<li><p>一对一如何设计？？？</p>
<ul>
<li>有可能有两张表，例如用户信息，可以把详细信息拆分为用户名，密码，与详细信息表。</li>
<li>两种设计方案：<ul>
<li>主键共享：<ul>
<li>pk+fk：保证了一对一</li>
</ul>
</li>
<li>外键唯一：<ul>
<li>fk+unique约束：保证了一对一</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="练习题："><a href="#练习题：" class="headerlink" title="练习题："></a>练习题：</h1><ol>
<li><p>取出每个部门最高薪水的人员名称</p>
<ul>
<li><p>第一，取得每个部门的最高薪水</p>
<ul>
<li><code>select deptno , max(sal) as maxsal from emp group by deptno;</code></li>
</ul>
</li>
<li><p>第二，通过以上的表取出最高薪水的人员名称：</p>
<ul>
<li>```sql<br>select e.ename , t.*<br>from<br>emp e<br>join<br>(select deptno , max(sal) as maxsal from emp group by deptno) t<br>on<br>e.sal = t.maxsal and e.deptno = t.deptno;<pre class="line-numbers language-none"><code class="language-none">
2. 哪些人的薪水在部门平均薪水之上

   - 第一，求出每个部门的平均薪水：

     - `select deptno , avg(sal) from emp group by deptno;`

   - 通过以上的零食表构建关系，找出高于平均工资的人:

     - ```sql
       select e.deptno , e.ename , e.sal , t.avgsal from emp e
       join 
       (select deptno , avg(sal) avgsal from emp group by deptno) t
       on
       e.deptno = t.deptno and e.sal &gt; t.avgsal;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>取得部门中所有人的平均的薪水等级</strong></p>
<ul>
<li><p>第一，求出所有人的薪水等级</p>
<ul>
<li><pre><code class="sql">select 
e.deptno , avg(t.grade)
from 
emp e
join 
salgrade t
on
e.sal &gt; t.losal and e.sal &lt; t.hisal
group by
e.deptno;
<pre class="line-numbers language-none"><code class="language-none">       
     
   - 第二，这儿连接成一张表之后就很方便可以继续group by，没有必要再当成一张临时表去操作啦！

   - ![image-20210310172059646](https://i.loli.net/2021/03/10/MIJV8LYKbk1sTwn.png)

4. 不用组函数(Max)，取得最高薪水（给出两种方式）

   - 第一种：`select ename,sal from emp order by sal desc limit 1;`(降序排序+limit取出第一个)
   - 第二种：用max
   - 第三种：表的自连接：`select distinct a.sal from emp a join emp b on a.sal &lt; b.sal;`(只要b表中存在比a表中大的工资，都会被找出来！！！然后distinct，换句话说，没被找出来的，就是最大工资！！！)`select sal from emp where sal not in (select distinct a.sal as hehe from emp a join emp b on a.sal &lt; b.sal);` 这儿也说明，和一列比较是和每一个值分别比较，尤其是in和not in这种，和列名无关。
   
5. 取得平均薪水最高的部门的部门编号

   - 取得部门的平均薪水,  然后降序选第一个 ， 用limit求出最大值：

     - `select deptno , avg(sal) as avgsal from emp group by deptno order by avgsal desc limit 1;`
     - 作为临时表查找最高的avg(sal)

   - ```sql
     (select deptno , avg(sal) as avgsal from emp group by deptno) t //找出每个部门平均薪资<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p><code>select max(avgsal) from (select deptno , avg(sal) as avgsal from emp group by deptno) t;</code>//找出最大值</p>
</li>
<li><p><code>select deptno,avg(sal) as avgsal from emp group by deptno having avgsal = (select max(avgsal) from (select deptno , avg(sal) as avgsal from emp group by deptno) t);</code>//使用分组后过滤。</p>
</li>
</ul>
</li>
<li><p>查出平均工资表后用自连接就直接找的呀，一个的avgsal = 第二个的max(avgsal)</p>
</li>
</ul>
</li>
<li><p>取出平均薪水最高的部门名称</p>
<ul>
<li><pre><code class="sql">select 
e.deptno , avg(e.sal) as avgsal ,d.dname
from 
emp e 
join 
dept d
on
e.deptno = d.deptno
group by 
deptno 
order by 
avgsal 
desc 
limit 1;
<pre class="line-numbers language-none"><code class="language-none">
7. 求平均薪水等级最低的部门的部门名称

   - 求出每个部门的平均薪水等级：

     - ```sql
       select
       e.deptno , avg(s.grade) as avggrade
       from
       emp e
       join
       salgrade s
       on
       e.sal &gt; s.losal and e.sal &lt; s.hisal
       group by
       e.deptno
       order by
       avggrade asc
       limit
       1;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p>上面就是答案，表连接实际上只是把表补全了而已，from…和join…on实际上就是一个新的表了，根据新的表，我们对于deptno进行分组，求出平均薪资。<strong>对于avg(sal)进行排序，然后取出最小值。</strong></p>
</li>
<li><p>如果多个值的话，可能就要用having avg(sal) = ***，这种形式来过滤出最小值。</p>
</li>
</ul>
</li>
<li><p>取得比普通员工的最高薪水还要高的领导人的姓名</p>
<ul>
<li>找出普通员工（员工编号没有在mgr字段里面）<ul>
<li><code>select * from emp where empno not in (select distinct mgr from emp where mgr is not null);</code></li>
<li>not in使用过程中，记得排除掉里面的NULL</li>
<li>distinct在select后面才能使用</li>
<li>not in后面和一列比较，这一列要先用select提取出来，有点像固定搭配的感觉。</li>
</ul>
</li>
<li>找出普通员工的最高薪水<ul>
<li><code>select max(sal) from emp where empno not in (select distinct mgr from emp where mgr is not null);</code></li>
</ul>
</li>
<li>找出薪资高于1600的<ul>
<li><code>select * from emp where sal &gt; (select max(sal) from emp where empno not in (select distinct mgr from emp where mgr is not null));</code></li>
</ul>
</li>
<li>！！！比普通员工最高薪水还要高的领导，比普通员工最高薪水还要高的一定不是普通员工。</li>
</ul>
</li>
<li><p>取得薪水最高的前五名普通员工</p>
<ul>
<li><p>先取出员工：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span>
emp
<span class="token keyword">where</span>
empno 
<span class="token operator">not</span> <span class="token operator">in</span>
<span class="token punctuation">(</span><span class="token keyword">select</span> mgr <span class="token keyword">from</span> emp <span class="token keyword">where</span> mgr <span class="token operator">is</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>取出薪资最高的前五名：</p>
<pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> sal <span class="token punctuation">,</span> ename <span class="token keyword">from</span>
emp
<span class="token keyword">where</span>
empno 
<span class="token operator">not</span> <span class="token operator">in</span>
<span class="token punctuation">(</span><span class="token keyword">select</span> mgr <span class="token keyword">from</span> emp <span class="token keyword">where</span> mgr <span class="token operator">is</span> <span class="token operator">not</span> <span class="token boolean">null</span><span class="token punctuation">)</span>
<span class="token keyword">order</span> <span class="token keyword">by</span>
sal
<span class="token keyword">desc</span>
<span class="token keyword">limit</span> <span class="token number">5</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>取出薪水最高的第六到第十名员工</p>
<ul>
<li><pre><code class="sql">select 
sal , ename
from
emp
order by
sal
desc
limit 5,5;
</code></pre>
</li>
<li><p>这儿注意下，limit后面是没有括号的，而且下表是从0开始的，5在这里表示第六个数。</p>
</li>
</ul>
</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Alexander Liu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/03/09/mysql-xue-xi/">http://example.com/2021/03/09/mysql-xue-xi/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">兔の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%90%8E%E7%AB%AF/">后端</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/03/13/chu-shi-java-fan-she-ji-zhi/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">初识Java反射机制</div></div></a></div><div class="next-post pull-right"><a href="/2021/03/01/maven-xue-xi/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Maven学习</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/08/19/docker-jin-jie/" title="Docker进阶"><img class="cover" src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210819205713.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-19</div><div class="title">Docker进阶</div></div></a></div><div><a href="/2021/05/19/docker-xue-xi/" title="Docker学习"><img class="cover" src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210819205713.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-19</div><div class="title">Docker学习</div></div></a></div><div><a href="/2021/08/25/elasticsearch-xue-xi/" title="ElasticSearch学习"><img class="cover" src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210825185001.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-25</div><div class="title">ElasticSearch学习</div></div></a></div><div><a href="/2021/03/16/jdbc-xue-xi/" title="JDBC学习"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-16</div><div class="title">JDBC学习</div></div></a></div><div><a href="/2021/04/21/jsp-xue-xi/" title="JSP学习"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-21</div><div class="title">JSP学习</div></div></a></div><div><a href="/2021/02/20/java-fu-xi/" title="Java大二上所学内容"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-20</div><div class="title">Java大二上所学内容</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Alexander Liu</div><div class="author-info__description">欢迎来到兔子的小窝，这里是兔子的一些笔记分享</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">75</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">15</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%99%E6%98%AF%E5%AF%B9%E4%BA%8E%E8%80%81%E6%9D%9C%E5%8A%A8%E5%8A%9B%E8%8A%82%E7%82%B9%E7%9B%B8%E5%85%B3MySQL%E8%AF%BE%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%8C%E4%B8%AA%E4%BA%BA%E8%A7%89%E5%BE%97%E9%9D%9E%E5%B8%B8%E6%A3%92%EF%BC%8C%E8%AE%B2%E7%9A%84%E5%BE%88%E9%80%8F%E5%BD%BB%EF%BC%8C%E6%8B%85%E5%BF%A7%E4%B8%80%E9%83%A8%E5%88%86%E7%9A%84%E5%86%85%E5%AE%B9%E7%94%B1%E4%BA%8E%E4%B8%9A%E5%8A%A1%E6%8E%A5%E8%A7%A6%E5%B0%91%EF%BC%8C%E6%B2%A1%E6%9C%89%E8%AF%A6%E7%BB%86%E4%BB%8B%E7%BB%8D%EF%BC%8C%E5%9C%A8%E8%BF%99%E4%B8%AA%E5%AD%A6%E6%9C%9F%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E7%A8%8B%E9%87%8C%E5%BA%94%E8%AF%A5%E4%BC%9A%E6%8F%90%E5%88%B0%EF%BC%8C%E9%82%A3%E4%B8%AA%E6%97%B6%E5%80%99%E5%86%8D%E5%AD%A6%E5%97%B7%EF%BC%81%EF%BC%81%EF%BC%81"><span class="toc-number">1.</span> <span class="toc-text">这是对于老杜动力节点相关MySQL课程的学习，个人觉得非常棒，讲的很透彻，担忧一部分的内容由于业务接触少，没有详细介绍，在这个学期的数据库课程里应该会提到，那个时候再学嗷！！！</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5"><span class="toc-number">2.</span> <span class="toc-text">数据库概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%98%AF%E5%95%A5"><span class="toc-number">2.1.</span> <span class="toc-text">数据库是啥</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%99%BB%E9%99%86"><span class="toc-number">2.2.</span> <span class="toc-text">数据库的安装与登陆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%B8%E8%BD%BDMySQL%EF%BC%88%E8%A1%80%E7%9A%84%E6%95%99%E8%AE%AD%EF%BC%89"><span class="toc-number">2.2.1.</span> <span class="toc-text">卸载MySQL（血的教训）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL%E4%B8%8EDB%E4%B8%8EDBMS%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">2.3.</span> <span class="toc-text">SQL与DB与DBMS的关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MySQL%E8%AF%AD%E5%8F%A5%E5%AD%A6%E4%B9%A0%EF%BC%88CRUD%EF%BC%89"><span class="toc-number">3.</span> <span class="toc-text">MySQL语句学习（CRUD）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%AD%E5%8F%A5%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB"><span class="toc-number">3.0.1.</span> <span class="toc-text">语句类型分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AE%9E%E6%93%8D"><span class="toc-number">3.0.2.</span> <span class="toc-text">数据实操</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MySQL%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">3.0.3.</span> <span class="toc-text">MySQL常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL%E8%AF%AD%E5%8F%A5%E5%AD%A6%E4%B9%A0"><span class="toc-number">3.0.4.</span> <span class="toc-text">SQL语句学习</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DQL%EF%BC%9A"><span class="toc-number">3.0.4.1.</span> <span class="toc-text">DQL：</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E8%A1%A8%E6%9F%A5%E8%AF%A2"><span class="toc-number">3.0.4.1.1.</span> <span class="toc-text">单表查询</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Union"><span class="toc-number">3.0.4.1.2.</span> <span class="toc-text">Union</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#limit-mysql%E4%B8%AD%E7%89%B9%E6%9C%89%E7%9A%84"><span class="toc-number">3.0.4.1.3.</span> <span class="toc-text">limit(mysql中特有的)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E6%A0%87%E5%87%86%E5%88%86%E9%A1%B5sql"><span class="toc-number">3.0.4.1.4.</span> <span class="toc-text">通用标准分页sql</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DDL%EF%BC%9A"><span class="toc-number">3.0.4.2.</span> <span class="toc-text">DDL：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DML%EF%BC%9A"><span class="toc-number">3.0.4.3.</span> <span class="toc-text">DML：</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E8%A1%A8%E5%8A%A0%E5%85%A5%E7%BA%A6%E6%9D%9F"><span class="toc-number">4.</span> <span class="toc-text">创建表加入约束</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E7%A9%BA%E7%BA%A6%E6%9D%9F"><span class="toc-number">4.1.</span> <span class="toc-text">非空约束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%94%AF%E4%B8%80%E6%80%A7%E7%BA%A6%E6%9D%9F"><span class="toc-number">4.2.</span> <span class="toc-text">唯一性约束</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E"><span class="toc-number">5.</span> <span class="toc-text">存储引擎</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%EF%BC%88Transaction%EF%BC%89%E6%A6%82%E8%BF%B0%EF%BC%9A"><span class="toc-number">6.</span> <span class="toc-text">事务（Transaction）概述：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCL"><span class="toc-number">6.0.1.</span> <span class="toc-text">TCL:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-number">6.0.2.</span> <span class="toc-text">事务的特性：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E6%80%A7%EF%BC%9A"><span class="toc-number">6.0.3.</span> <span class="toc-text">事务的隔离性：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">7.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B7%BB%E5%8A%A0%E7%B4%A2%E5%BC%95%EF%BC%9A"><span class="toc-number">7.1.</span> <span class="toc-text">添加索引：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%B4%A2%E5%BC%95%EF%BC%9A"><span class="toc-number">7.2.</span> <span class="toc-text">删除索引：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">7.3.</span> <span class="toc-text">底层数据结构：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B1%BB%EF%BC%9A"><span class="toc-number">7.4.</span> <span class="toc-text">分类：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88%EF%BC%9A"><span class="toc-number">7.5.</span> <span class="toc-text">索引失效：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%A7%86%E5%9B%BE-view"><span class="toc-number">8.</span> <span class="toc-text">视图(view)</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AF%BC%E5%85%A5%E5%AF%BC%E5%87%BA"><span class="toc-number">9.</span> <span class="toc-text">数据库的数据的导入导出</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E6%95%B0%E6%8D%AE%EF%BC%9A"><span class="toc-number">9.1.</span> <span class="toc-text">导出数据：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%85%A5%E6%95%B0%E6%8D%AE%EF%BC%9A"><span class="toc-number">9.2.</span> <span class="toc-text">导入数据：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%87%BA%E6%8C%87%E5%AE%9A%E8%A1%A8%EF%BC%9A"><span class="toc-number">9.3.</span> <span class="toc-text">导出指定表：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1%E4%B8%89%E8%8C%83%E5%BC%8F"><span class="toc-number">10.</span> <span class="toc-text">数据库设计三范式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E9%A2%98%EF%BC%9A"><span class="toc-number">11.</span> <span class="toc-text">练习题：</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/12/07/cao-zuo-xi-tong-gai-shu/" title="1. 南京大学操作系统概述"><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202212071136497.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="1. 南京大学操作系统概述"/></a><div class="content"><a class="title" href="/2022/12/07/cao-zuo-xi-tong-gai-shu/" title="1. 南京大学操作系统概述">1. 南京大学操作系统概述</a><time datetime="2022-12-07T03:35:42.000Z" title="发表于 2022-12-07 11:35:42">2022-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/05/cpu-cache-xue-xi/" title="CPU Cache 学习"><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202212051319709.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPU Cache 学习"/></a><div class="content"><a class="title" href="/2022/12/05/cpu-cache-xue-xi/" title="CPU Cache 学习">CPU Cache 学习</a><time datetime="2022-12-05T04:14:46.000Z" title="发表于 2022-12-05 12:14:46">2022-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/16/ml-ru-men/" title="ML入门"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ML入门"/></a><div class="content"><a class="title" href="/2022/01/16/ml-ru-men/" title="ML入门">ML入门</a><time datetime="2022-01-16T11:11:14.000Z" title="发表于 2022-01-16 19:11:14">2022-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/28/da-shu-ju-fen-xi-yu-zhi-neng-ji-suan-qi-mo-fu-xi-3/" title="大数据分析与智能计算期末复习3"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="大数据分析与智能计算期末复习3"/></a><div class="content"><a class="title" href="/2021/12/28/da-shu-ju-fen-xi-yu-zhi-neng-ji-suan-qi-mo-fu-xi-3/" title="大数据分析与智能计算期末复习3">大数据分析与智能计算期末复习3</a><time datetime="2021-12-28T14:05:22.000Z" title="发表于 2021-12-28 22:05:22">2021-12-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/24/da-shu-ju-fen-xi-yu-zhi-neng-ji-suan-qi-mo-fu-xi-2/" title="大数据分析与智能计算期末复习2"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="大数据分析与智能计算期末复习2"/></a><div class="content"><a class="title" href="/2021/12/24/da-shu-ju-fen-xi-yu-zhi-neng-ji-suan-qi-mo-fu-xi-2/" title="大数据分析与智能计算期末复习2">大数据分析与智能计算期末复习2</a><time datetime="2021-12-24T07:59:54.000Z" title="发表于 2021-12-24 15:59:54">2021-12-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Alexander Liu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>