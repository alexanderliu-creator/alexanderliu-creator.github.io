<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>MySQL学习 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="这是对于老杜动力节点相关MySQL课程的学习，个人觉得非常棒，讲的很透彻，担忧一部分的内容由于业务接触少，没有详细介绍，在这个学期的数据库课程里应该会提到，那个时候再学嗷！！！">
<meta property="og:type" content="article">
<meta property="og:title" content="MySQL学习">
<meta property="og:url" content="http://example.com/2021/03/09/MySQL%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="这是对于老杜动力节点相关MySQL课程的学习，个人觉得非常棒，讲的很透彻，担忧一部分的内容由于业务接触少，没有详细介绍，在这个学期的数据库课程里应该会提到，那个时候再学嗷！！！">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://gitee.com/alexs-rabbit//blog/raw/master/20210303112714.png">
<meta property="og:image" content="https://gitee.com/alexs-rabbit//blog/raw/master/20210308174233.png">
<meta property="og:image" content="https://gitee.com/alexs-rabbit//blog/raw/master/20210303113119.png">
<meta property="og:image" content="https://gitee.com/alexs-rabbit//blog/raw/master/20210303172517.png">
<meta property="og:image" content="https://gitee.com/alexs-rabbit//blog/raw/master/20210303204034.png">
<meta property="article:published_time" content="2021-03-09T11:40:26.000Z">
<meta property="article:modified_time" content="2021-04-03T01:57:57.000Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="后端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gitee.com/alexs-rabbit//blog/raw/master/20210303112714.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-MySQL学习" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/03/09/MySQL%E5%AD%A6%E4%B9%A0/" class="article-date">
  <time class="dt-published" datetime="2021-03-09T11:40:26.000Z" itemprop="datePublished">2021-03-09</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E5%8A%A8%E5%8A%9B%E7%BB%93%E7%82%B9%E5%90%8E%E7%AB%AF%E8%AF%BE%E7%A8%8B/">动力结点后端课程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      MySQL学习
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h1 id="这是对于老杜动力节点相关MySQL课程的学习，个人觉得非常棒，讲的很透彻，担忧一部分的内容由于业务接触少，没有详细介绍，在这个学期的数据库课程里应该会提到，那个时候再学嗷！！！"><a href="#这是对于老杜动力节点相关MySQL课程的学习，个人觉得非常棒，讲的很透彻，担忧一部分的内容由于业务接触少，没有详细介绍，在这个学期的数据库课程里应该会提到，那个时候再学嗷！！！" class="headerlink" title="这是对于老杜动力节点相关MySQL课程的学习，个人觉得非常棒，讲的很透彻，担忧一部分的内容由于业务接触少，没有详细介绍，在这个学期的数据库课程里应该会提到，那个时候再学嗷！！！"></a>这是对于老杜动力节点相关MySQL课程的学习，个人觉得非常棒，讲的很透彻，担忧一部分的内容由于业务接触少，没有详细介绍，在这个学期的数据库课程里应该会提到，那个时候再学嗷！！！</h1><span id="more"></span>





<h1 id="数据库概念"><a href="#数据库概念" class="headerlink" title="数据库概念"></a>数据库概念</h1><h2 id="数据库是啥"><a href="#数据库是啥" class="headerlink" title="数据库是啥"></a>数据库是啥</h2><ul>
<li>序列化和反序列化可以的，也可以存成文件。但是复杂，也不够便利</li>
<li>底层还是流来处理，只是现在更加高级，不用写流了，直接用sql语句就能完成高层数据库的调用。</li>
</ul>
<h2 id="数据库的安装与登陆"><a href="#数据库的安装与登陆" class="headerlink" title="数据库的安装与登陆"></a>数据库的安装与登陆</h2><ul>
<li>有一个比较好的安装教程</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/37152572">Mysql安装教程</a></p>
<ul>
<li>关于新版的installer的一些使用：</li>
</ul>
<p>由于我下载的时候选择出了一些问题，下载了很多我不需要的东西，后面才发现这个东西很好用。即使用下载好的installer打开后可以进行进一步的配置。</p>
<p><img src="https://gitee.com/alexs-rabbit//blog/raw/master/20210303112714.png" alt="image-20210303112714373"></p>
<p>左边是已经安装好的mysql相关的产品，右边可以选择添加，调整或者删除对应的产品，也可以进行升级，Quick Action里面的Reconfigure可以帮助你快速的调整Mysql的配置。</p>
<ul>
<li>当配置完成环境变量之后：</li>
</ul>
<p><img src="https://gitee.com/alexs-rabbit//blog/raw/master/20210308174233.png" alt="image-20210308174226353"></p>
<p>用cmd登陆mysql , -u表示登陆的账号， -p表示password ，输入完成就可以登陆mysql。</p>
<p><img src="https://gitee.com/alexs-rabbit//blog/raw/master/20210303113119.png" alt="image-20210303113119884"></p>
<p>下面这种也可以的，这种方式可以保护你的密码。</p>
<ul>
<li>服务端口为3306 ， 以及可以在本电脑-&gt;管理中来调整一些类似于开机自动启动的设置。</li>
</ul>
<h3 id="卸载MySQL（血的教训）"><a href="#卸载MySQL（血的教训）" class="headerlink" title="卸载MySQL（血的教训）"></a>卸载MySQL（血的教训）</h3><ul>
<li><strong>卸载mysql有点复杂</strong>，除了在安装包中（就是下载的时候下载的那个msi）中可以remove安装的mysql产品之外，<code>C:\Program Files\MySQL和C:\ProgramData\MySQL和C:\Program Files (x86)\MySQL</code>都要干掉，下次下载才能顺利。</li>
</ul>
<h2 id="SQL与DB与DBMS的关系"><a href="#SQL与DB与DBMS的关系" class="headerlink" title="SQL与DB与DBMS的关系"></a>SQL与DB与DBMS的关系</h2><ul>
<li>SQL也是高级语言，由程序员来写。执行之前也需要进行编译。</li>
<li>SQL由DBMS来执行</li>
<li>DBMS通过执行SQL语句来操作DB中的数据。</li>
<li>说白了MySQL是用来管理数据库的。</li>
</ul>
<h1 id="MySQL语句学习（CRUD）"><a href="#MySQL语句学习（CRUD）" class="headerlink" title="MySQL语句学习（CRUD）"></a>MySQL语句学习（CRUD）</h1><h3 id="语句类型分类"><a href="#语句类型分类" class="headerlink" title="语句类型分类"></a>语句类型分类</h3><pre><code>- DQL ：查询语句 (所有的select有关的)
- DML：数据操作语言（对于数据进行增删改：insert , delete , update）
- DDL：数据定义语言  （对于表结构进行增删改：drop , create , outer）
- TCL：事务控制语言（这里的T为Transaction：roll back之类的）
- DCL：数据控制语言（授权以及撤销权限。）
</code></pre>
<ul>
<li>表的结构是很少动的，因为动表的结构的成本太高了。</li>
<li>导入数据</li>
</ul>
<h3 id="数据实操"><a href="#数据实操" class="headerlink" title="数据实操"></a>数据实操</h3><ul>
<li><p>用cmd或者mysql自带的cmd登录</p>
</li>
<li><p>查看数据库: show databases; （这个不是sql语言，是mysql命令）</p>
</li>
<li><p>创建数据库：create database liututu;（命令）</p>
</li>
<li><p>使用数据库：use liututu; （命令）</p>
</li>
<li><p>查看表格：show tables; （命令）</p>
</li>
<li><p>初始化数据：这里很难实践，如果有.sql为后缀的资源（这种文件被称为sql脚本，其中编写了大量的sql语句，其实本质就是文本文件哈哈哈哈哈哈）的话，可以用：source+资源路径; 来初始化数据表。sql脚本中的数据量太大的时候无法打开，使用source命令完成初始化。</p>
</li>
<li><p>删除数据库： drop databases test;  （sql语言）</p>
</li>
<li><p>查表的结构：desc+表名; </p>
<p><img src="https://gitee.com/alexs-rabbit//blog/raw/master/20210303172517.png" alt="image-20210303172510103"></p>
</li>
<li><p>查看某个表中的数据：select * from table-name</p>
</li>
</ul>
<h3 id="MySQL常用命令"><a href="#MySQL常用命令" class="headerlink" title="MySQL常用命令"></a>MySQL常用命令</h3><ul>
<li>create database …;</li>
<li>查询当前使用的数据库：<ul>
<li>select database();</li>
<li>select version();(查看当前数据库的版本)</li>
<li>实在不知道你可以直接先show databases; 然后再use嘛！！！</li>
</ul>
</li>
<li>结束一条写错的语句，直接加\c可以实现</li>
<li>推出mysql可以用exit</li>
<li>show tables from 表名</li>
<li>desc + 表名</li>
<li>查看创建表的语句： show create table 表名;</li>
</ul>
<h3 id="SQL语句学习"><a href="#SQL语句学习" class="headerlink" title="SQL语句学习"></a>SQL语句学习</h3><h4 id="DQL："><a href="#DQL：" class="headerlink" title="DQL："></a>DQL：</h4><h5 id="单表查询"><a href="#单表查询" class="headerlink" title="单表查询"></a>单表查询</h5><ul>
<li><p><strong>最基本用法</strong></p>
<p>select 字段名1，字段名2，… from 表名; 不记得表里有哪些东西就先用desc + 表名。大小写都可以，换行也可以，打上分号才才行。</p>
<p>e.g.</p>
<ol>
<li>select ename , sal * 12 from tmp;   (表中字段可以参与数学运算)</li>
<li>select ename , sal * 12 as yearsal from tmp;   （表中字段可以重命名，如果要用中文，要用引号，例如 as ‘年薪’）</li>
<li>这里单双引号都可以，建议单引号。双引号在别的SQL语言里面不一定可以识别，但在Mysql里面可以，为了避免问题，还是用单引号。标准sql语句中，字符串要用单引号括起来。</li>
<li>as关键字可以省略。</li>
<li>查询全部字段:  select * from temp; 私下可以，但是java程序中，实际开发中不要写。这个方式的效率太低了，会影响产品的性能。</li>
</ol>
</li>
<li><p><strong>条件查询</strong>：</p>
<ol>
<li><p>select 字段名1，字段名2，… from 表名 where 条件; 执行顺序是先from , 然后where , 最后select。 e.g. select sal from emp where ename&#x3D;’SMITH’。另外提醒一下，在mysql中，string就是varchar , 字符串使用单引号括起来。</p>
</li>
<li><p>在sql中，&lt;&gt;就是!&#x3D;，此外sql中!&#x3D;也是可以使用的，&lt;&gt;的意思是大于或者小于的，类似于&gt;&#x3D;表示大于后者等于的</p>
</li>
<li><p>select ename, sal from emp where sal &gt;&#x3D; 1100 and sal&lt;&#x3D;3000; ， 等价于 select ename, sal from emp where sal between 1100 and 3000 ; between必须左小右大，表示的是闭区间。</p>
</li>
<li><p>between字符串也是可以的，和计组中学的一样的，可以理解为左闭右开。</p>
</li>
<li><p>is NULL和0是不一样的，当一个位置为空时，要使用is null或者is not null去选出对应的选项。用 &#x3D;null 是错的，没有这种用法哦。</p>
<p><strong>这里非常重要，NULL表示任何值，所以首先不能用&#x3D;，其次，不能用in的语法去进行匹配，任何值都可以匹配上NULL，所以在后面的练习题中，要匹配都要搭配is not null来一起使用。</strong></p>
</li>
<li><p>and 和 or 洒洒水啦，很简单的 ， 复杂的话就加括号，永远的神！！！不然的话，and的优先级会大于or ，就可能会gg。</p>
</li>
<li><p>in等同于or , usage: <code>select ename,job from emp where job=&#39;salesman&#39; or job=&#39;manager&#39;</code>和<code>select ename,job from emp where job in (&#39;salesman&#39;,&#39;manager&#39;)</code>，有点类似于python的感觉。<code>select ename,job from emp where sal in (1000,5000)</code>，in里面对应的不是区间，是确定的多个值！！！！！！not in就是去反面，不在这几个值之中。</p>
</li>
</ol>
</li>
<li><p><strong>模糊查询</strong>：</p>
<p>关键字为like，类似的意思，就是模糊查询</p>
<p>模糊查询必须掌握的特殊符号：%和_</p>
<p>%代表任意多个字符，_代表任意一个字符</p>
<ol>
<li>select ename from emp where ename like ‘%o%’查询名字中有o的</li>
<li>找出名字中第三个为A的，select ename from emp where ename like ‘__A%’</li>
<li>找出名字中有下划线的, select ename from emp where ename like <code>&#39;%\_%&#39;</code></li>
</ol>
</li>
<li><p><strong>排序</strong></p>
<p>关键词为order by</p>
</li>
</ul>
<ol>
<li><p>select ename , sal from emp order by sal; 默认为升序排序，怎么指定升序或者降序？asc表示升序，desc表示降序select ename , sal from emp order by sal desc;</p>
</li>
<li><p>搞心态！！！</p>
<p><img src="https://gitee.com/alexs-rabbit//blog/raw/master/20210303204034.png" alt="image-20210303204033854"></p>
</li>
</ol>
<p>​			按照从左到右顺序来排序，后面的可能都用不上哦。</p>
<pre><code>3. 还可以用select * from emp order by 1 ， 表示按照第1列排序，但是这种方式不够健壮，所以不推荐用这个。

4. 综合使用：select ename , job , sal from emp where job = &#39;SALESMAN&#39; order by sal desc; 

5. 顺序： from -&gt; where -&gt; select -&gt; order by
</code></pre>
<ul>
<li><p><strong>分组函数</strong>：</p>
<p>count , sum , avg , max , min五个分组函数，count为计数，找出个数</p>
<ol>
<li>select sum(sal) from emp</li>
<li>select max(sal) from emp</li>
<li>select avg(sal) from emp</li>
<li>select count(ename) from emp &#x2F; select count(*) from emp;</li>
</ol>
<p>分组函数一共五个，都是对于一组数据进行处理的，又叫做多行处理函数。</p>
<ul>
<li>分组函数会自动忽略NULL哦，如果你在对于含有null的列操作的话，那些对应的null的行会被忽略掉</li>
<li>分组函数都会自动忽略null</li>
</ul>
</li>
<li><p><strong>单行处理函数</strong>：</p>
<ol>
<li>有null参与的运算最终的结果也是null，所有数据库都是这样规定的。但是发现sum出问题了！！！！sum函数把null忽略了。但是但是但是！！！(800+null)&#x2F;2的值也是Null哦！！！</li>
<li>ifnull()为空值处理函数，可能为null的数据被当作什么处理</li>
<li>select ename,ifnull(comm,0) as comm from emp</li>
<li>select enames,(sal+ifnull(comm,0)) as comm from emp</li>
<li>这么叫这个函数，是因为，进去多少行出来多少行，是对于每一行处理的。而多行处理函数则是多对一这种形式哦。</li>
</ol>
</li>
<li><p><strong>特殊的一些规则和用法</strong>：</p>
<ol>
<li><p>找出工资高于平均工资的员工：select ename from emp where sal &gt; avg(sal)  ， 会报错，显示无效使用了分组函数。<strong>SQL语句中有一个规则，分组语句不可以直接出现在where后面！！！</strong></p>
</li>
<li><p>这儿就要改！！！</p>
<p>select avg(sal) from emp;</p>
<p>select ename , sal from emp where sal &gt; 2073.214286</p>
<p>&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;</p>
<p>select ename , sal from emp where sal &gt; (select avg(sal) from emp) ;   这个是子查询！！！select语句的嵌套</p>
</li>
<li><p>select sum(comm) from emp where comm is not null 没有必要这么写，分组函数自动忽略null</p>
</li>
<li><p>select count(*) from emp; 统计总记录条数，select count(sal) from emp; 记录的是salary的不为null的数据的条数。 两者的区别使用的时候要注意。</p>
</li>
<li><p>分组函数可以组合使用。select count(*) , avg(sal) from emp;</p>
</li>
<li><p>mysql中，指令是不区分大小写的，但是数据是有大小写的哦，数据的大小写是有区分的。</p>
</li>
<li><p>as是用来重命名的，如果后面为英文不用单引号，如果是中文就要用字符串的形式括起来啦！</p>
</li>
</ol>
</li>
<li><p><strong>group by 和 having</strong>:</p>
<p>group by：按照某个字段或者某些字段进行分组</p>
<p>having：对于分组之后的数据进行再次过滤</p>
<ol>
<li><p>找出每个岗位的最高薪资： select max(sal) from emp group by job , mention: 分组函数一般都会和group by 联合使用。</p>
</li>
<li><p><strong>正是因为上面那五个分组函数，很多情况都是与group by一起使用，并且都是在group by以后执行，因此叫分组函数。当一条sql语句没有group by 的话，整张表会自成一组，也是默认要group by的！！！</strong>（先分组，后执行）</p>
</li>
<li><p>分组函数不能用于where后面，<strong>因为先执行where，然后才执行group by , 最后才执行分组函数</strong>，因此在后面执行不了啊兄dei。（where的时候还没分组，你上哪儿用分组函数啊？？？）</p>
</li>
<li><p>&#96;&#96;&#96;sql<br>select	5<br>…<br>from	1<br>…<br>where	2<br>…<br>group by	3 &#x2F;&#x2F;之后才能用分组函数<br>…<br>having	4<br>…<br>order by	6<br>…</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">     指令执行顺序</span><br><span class="line"></span><br><span class="line">  5. 记住：where后面绝对不能用分组函数！！！！！嵌套的话可以哦！！！！！！</span><br><span class="line"></span><br><span class="line">  6. select ename , max(sal) , job from emp group by job;   这个不行的哈，明显有问题，因为这个ename没有参与分组啊！！！Mysql不报错但是结果没有意义，oracle会报错，这个有隐患的，不要用嗷！！！</span><br><span class="line"></span><br><span class="line">  7. 得出结论，group by 出现的话，前面只能跟分组函数和参与分组的字段，别的都不能跟着。</span><br><span class="line"></span><br><span class="line">  8. 找出每个部门，不同工作岗位的最高薪资：select deptno , job , max(sal) from emp group by deptno,job ;</span><br><span class="line"></span><br><span class="line">  9. 找出每个部门的最高薪资，要求显示薪资大于2900的数据： </span><br><span class="line"></span><br><span class="line">     select max(sal) , deptno from emp group by deptno having max(sal) &gt; 20 -- having是用于group by之后进行信息过滤的。这里用where好一点，不然的话分组了，找了最大值，后面又扔了效率就低了。where在having之前和分组之前执行的，先把没必要的扔了，效率就高了。</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"></span><br><span class="line">     select max(sal) , deptno from emp where sal&gt;2900 group by deptno; //这个和上面相比效率高一些</span><br><span class="line"></span><br><span class="line">     这里是   对于所有数据不经过分组处理就使用where，对于分组处理前的数据进行筛选是可以用where的！！！</span><br><span class="line"></span><br><span class="line">  10. 找出部门的平均薪资，要求显示薪资大于2000的数据</span><br><span class="line"></span><br><span class="line">      select deptno , avg(sal) from emp group by deptno having avg(sal) &gt; 2000; 这样就只能用having , 因为where后面不能接avg！！！这里是对于所有数据分组处理后，对于处理后的数据做筛选，这个时候where就失效了，就只能用having了。</span><br><span class="line"></span><br><span class="line">  11. having是group by的搭档，是对于group by后的数据进行处理的。没有group by是不能用having的。</span><br><span class="line"></span><br><span class="line">- **sql的处理**：</span><br><span class="line"></span><br><span class="line">  1. select	5</span><br><span class="line">     	...</span><br><span class="line">     from	1</span><br><span class="line">     	...</span><br><span class="line">     where	2</span><br><span class="line">     	...</span><br><span class="line">     group by	3 //之后才能用分组函数</span><br><span class="line">     	...</span><br><span class="line">     having	4</span><br><span class="line">     	...</span><br><span class="line">     order by	6</span><br><span class="line">     	...</span><br><span class="line">  2. 上面这个顺序编程的时候是不能变的，执行就是先从表中取出，然后用where筛选第一次，分组后，再筛选一次，取出来，排序，执行时这个循序。</span><br><span class="line"></span><br><span class="line">- **去除重复记录**：</span><br><span class="line"></span><br><span class="line">  1. select **distinct** job from emp;</span><br><span class="line">  2. select ename , **distinct** job from emp;这个是错的，distinct只能出现在所有字段的最前方。表示联合去除重复的记录，将多个字段联合起来去重。</span><br><span class="line">  3. 统计岗位的数量，select count(distinct(job)) from emp;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 两表连接</span><br><span class="line"></span><br><span class="line">- **连接查询**：</span><br><span class="line"></span><br><span class="line">  1. 多张表联合查询出最终的结果，一个业务会对应多张表，数据会有冗余，数据库中尽量不出现重复的数据。</span><br><span class="line"></span><br><span class="line">2. 分类：</span><br><span class="line"></span><br><span class="line">   - 根据语法出现的年代划分：</span><br><span class="line"></span><br><span class="line">     - SQL92</span><br><span class="line">       - SQL99 （这个才是比较新的语法）</span><br><span class="line"></span><br><span class="line">   - 根据表的链接方式来划分：</span><br><span class="line"></span><br><span class="line">     - 内连接：</span><br><span class="line"></span><br><span class="line">       - 等值连接</span><br><span class="line">         - 非等值连接</span><br><span class="line"></span><br><span class="line">       - 自连接</span><br><span class="line"></span><br><span class="line">     - 外连接：</span><br><span class="line"></span><br><span class="line">       - 左外连接（左连接）</span><br><span class="line">         - 右外连接（右连接）</span><br><span class="line"></span><br><span class="line">     - 全连接（这个不讲，很少用）</span><br><span class="line">  3. 笛卡尔积现象（笛卡尔乘积现象） e.g.  select ename , dname from emp , dept;  结果是两个表数量的乘积，这个就仅仅是简单的排列组合。定义：当两张表进行连接查询的时候，没有限制，则结果是两张表记录条数的乘积。</span><br><span class="line"></span><br><span class="line">  4. 关于表的别名：`select e.ename,d.dname from emp e, dept d;`，这样就可以取别名，方便一些。这儿的意思是e.ename和d.dname要粘贴在一起，进行匹配，这就是原理。</span><br><span class="line">  5. 如何避免？条件过滤！！！这种方式不会减少匹配的次数，只会减少显示的有效记录而已，底层是一样实现的，还是要一一匹配然后去判断。e.g. select e.ename , d.dname from emp e, dept d where e.deptno = d.deptno。匹配次数还是54次，这个是sql 92语法，已经out了，以后不用了。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">###### 内连接：</span><br><span class="line"></span><br><span class="line">1. 等值连接：</span><br><span class="line">   - 特点：条件是等量关系。</span><br><span class="line">   - SQL92: `e.g.select e.ename , d.dname from emp e, dept d where e.deptno = d.deptno。`</span><br><span class="line">   - SQL99:`e.g.select e.ename , d.dname from emp e join dept d on e.deptno = d.deptno`</span><br><span class="line">   - 99语法：`select ... from ... join ... on ... where ...`，表的连接和连接后的数据过滤分开来了，结构更加清晰一些，表的连接和后面的where分离了。</span><br><span class="line">   - 由于on的条件是等号，因此叫做等值连接，这里的join前面其实少了一个inner , 表示的应该是inner join。带上Inner可读性好一些</span><br><span class="line">2. 非等值连接：</span><br><span class="line">   - 特点：找出每个员工的工资等级：</span><br><span class="line">   - 找出所有员工的工资等级： select e.ename , e.sal , s.grade from emp e join salgrade s on e.sal between s.losal and s.hisal;</span><br><span class="line">   - 逸豪的想法：本质上可以先表拼接，然后再去根据行之间数据的关系去构造非等值连接。</span><br><span class="line">3. 自连接：</span><br><span class="line">   - 特点：一张表看作两张表。自己连接自己</span><br><span class="line">   - 找出员工和他的领导！！！select e.ename as ename , e.mgr  as managerId, s.ename as boss from emp e join emp s on e.mgr = s.empno; 本质就是分别用两个别名表示一样的表即可看作两张表来使用嗷QAQ！！！</span><br><span class="line">   - 记得起别名！！！</span><br><span class="line">   - summary: 这儿要记一下，其实可以看做从A表拿一条data , 从B表拿一条data，根据每一行中某些数据的大小关系，判定要不要取出来。</span><br><span class="line"></span><br><span class="line">###### 外连接：</span><br><span class="line"></span><br><span class="line">​	什么是内连接？</span><br><span class="line"></span><br><span class="line">把A和B表能够匹配上的记录查询出来，这就是内连接。</span><br><span class="line"></span><br><span class="line">​	什么是外连接？</span><br><span class="line"></span><br><span class="line">AB两张表中一张是主表，一张是附表。当附表中的数据没和主表匹配上，附表会自动生成NULL与之匹配。A是主角，B是附表。</span><br><span class="line"></span><br><span class="line">1. 左连接</span><br><span class="line"></span><br><span class="line">   - 左边的表是主表</span><br><span class="line"></span><br><span class="line">   - 找出每个员工的上级领导！！！`e.g.select e.ename &#x27;员工&#x27; , s.ename &#x27;领导&#x27; from emp e left join emp s on e.mgr = s.empno; `</span><br><span class="line"></span><br><span class="line">2. 右连接</span><br><span class="line"></span><br><span class="line">   - 右边的表是主表</span><br><span class="line">   - 找出每个员工的上级领导！！！`e.g.select e.ename &#x27;员工&#x27; , s.ename &#x27;领导&#x27; from emp e right join emp s on e.mgr = s.empno; `</span><br><span class="line">   - summary: 左连接就是左边是主表，右连接右边是主表，同理，outer时可以省略的。能省略是因为重点不在这两个单词，有的话可读性会更好嗷！！！</span><br><span class="line">   - 例题，找出哪个部门没有员工：显然部门是主表嗷！！！`e.g. select e.* , d.* from emp e right join dept d on e.deptno  = d.deptno on e.empno is NULL;`</span><br><span class="line"></span><br><span class="line">###### 全连接：</span><br><span class="line"></span><br><span class="line">- 情况比较特殊，应用场景较少，业务场景也较少，有兴趣的话自己自学。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 多表查询</span><br><span class="line"></span><br><span class="line">- 找出每一个员工的部门名称以及工资等级</span><br><span class="line">- 规则： `from A join B on ... join C on ...`（表示A和B先进行连接，连接后的结果再和C连接 ）`select e.ename , d.dname , s.grade from emp e join dept d on e.deptno = d.deptno join salgrade s on e.sal between s.losal and s.hisal;`</span><br><span class="line">- 又有一个例子：找出每一个员工的部门名称，工资等级以及上级领导。`select e.ename , d.dname , s.grade , el.ename &#x27;领导&#x27; from emp e join dept d on e.deptno = d.deptno join salgrade s on e.sal between s.losal and s.hisal left join emp el on e.mgr= el.empno;`表可以认为从左往右不断迭代的，因此要注意不同的表之间的inner和outer的关系嗷呜！！！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">##### 子查询</span><br><span class="line"></span><br><span class="line">select里面嵌套select语句，子查询可以出现在：`select...(select) from ...(select) where ...(select)`</span><br><span class="line"></span><br><span class="line">- 找出高于平均薪资的员工信息：(where后面加select)</span><br><span class="line"></span><br><span class="line">  - 第一步： select  avg(sal) from emp;</span><br><span class="line">  - 第二步：select * from emp where sal &gt; 2073.214286</span><br><span class="line">  - 合并：select * from emp where sal &gt; (select avg(sal) from emp);</span><br><span class="line"></span><br><span class="line">- 找出每个部门平均薪水的等级：(from后面加入select)</span><br><span class="line"></span><br><span class="line">  - 第一步：select deptno , avg(sal) as avgsal group by deptno;</span><br><span class="line"></span><br><span class="line">  - 第二步：</span><br><span class="line"></span><br><span class="line">    ```sql</span><br><span class="line">    select</span><br><span class="line">    	t.* , s.grade</span><br><span class="line">    from </span><br><span class="line">    	(select deptno , avg(sal) as avgsal group by deptno) t</span><br><span class="line">    join salgrade</span><br><span class="line">    	s</span><br><span class="line">    on</span><br><span class="line">    	t.avgsal between s.losal and s.hisal;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>找出每个部门平均的薪水等级：(from后面加入select)</p>
<ul>
<li><p>第一步：<code>select e.ename ,  e.sal , s.grade from emp e join salgrade s on s.losal and s.hisal;</code></p>
</li>
<li><p>第二步：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line">e.ename ,  e.sal , s.grade , <span class="built_in">avg</span>(s.grade)</span><br><span class="line"><span class="keyword">from</span> </span><br><span class="line">emp e </span><br><span class="line"><span class="keyword">join</span> </span><br><span class="line">salgrade s </span><br><span class="line"><span class="keyword">on</span></span><br><span class="line">e.sal <span class="keyword">between</span> s.losal <span class="keyword">and</span> s.hisal</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span></span><br><span class="line">e.deptno;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>找出每个员工所在的部门名称，要求显示员工名和部门名：(select后面接上select):</p>
<ul>
<li><code>select e.ename,e.deptno,(select d.dname from dept d where e.deptno = d.deptno) as dname from emp e;</code></li>
</ul>
</li>
</ul>
<h5 id="Union"><a href="#Union" class="headerlink" title="Union"></a>Union</h5><ul>
<li><p>可以将查询结果相加</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> ename , job <span class="keyword">from</span> emp <span class="keyword">where</span> job <span class="operator">=</span> <span class="string">&#x27;MANAGER&#x27;</span></span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> ename , job <span class="keyword">from</span> emp <span class="keyword">where</span> job <span class="operator">=</span> <span class="string">&#x27;SALESMAN&#x27;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>可以将毫不相关的结果从下往下拼接起来。</p>
</li>
</ul>
<h5 id="limit-mysql中特有的"><a href="#limit-mysql中特有的" class="headerlink" title="limit(mysql中特有的)"></a><strong>limit(mysql中特有的)</strong></h5><ul>
<li>分页查询用得到</li>
<li>limit取结果集中的部分数据，</li>
<li>语法: limit startIndex , length 分别表示起始位置，表示取几个。<code>e.g. select ename , sal from emp order by sal desc limit 0,5;</code>先排序，再取5个，也可以直接写limit 5; limit是最后才执行的</li>
</ul>
<h5 id="通用标准分页sql"><a href="#通用标准分页sql" class="headerlink" title="通用标准分页sql"></a>通用标准分页sql</h5><ul>
<li><p>例如 ，每页显示三条记录：<code>一页： 0,3  二页：3,3 三页：6,3 四页：9,3</code>，所以可以看出来，对于第n页有 (pageNo - 1) *pagesize , pageSize</p>
</li>
<li><p>java代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">pageNo</span> <span class="operator">=</span> <span class="number">2</span></span><br><span class="line"><span class="type">int</span> <span class="variable">pageSize</span> <span class="operator">=</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">limit <span class="number">10</span> , <span class="number">10</span></span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="DDL："><a href="#DDL：" class="headerlink" title="DDL："></a>DDL：</h4><ul>
<li><p>creat</p>
<ul>
<li>创建表格的语句格式：</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> Tabel_Name(</span><br><span class="line">	Field1 Type1,</span><br><span class="line">	Field2 Type2,</span><br><span class="line">	...</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li><p>数据类型：</p>
<ul>
<li><p>int（对应java中的int）</p>
</li>
<li><p>bigint   长整型（对应java中的long）</p>
</li>
<li><p>float    浮点型（对应java中的float double）</p>
</li>
<li><p>char     定长字符串（对应java中的String）</p>
</li>
<li><p>varchar     可变长字符串（最多存255个字符，对应java中的StringBuffer&#x2F;StringBuilder）</p>
</li>
<li><p>date     日期类型（存储日期，对应java.sql.Date类型）</p>
</li>
<li><p>blob     二进制大对象（存储图片，视频等流媒体信息，Binary Large Object，对应java中的Object）</p>
</li>
<li><p>clob     字符大对象（存储大文本，例如 可以储存4G的字符串，Character Large Object对应java中的object）</p>
<p>……</p>
</li>
</ul>
</li>
<li><p>char和varchar如何选择？明显看长度的关系啦！！！例如Name字段，如果少于Char，没问题，多余Char，爆了。Varchar比char智能一点，Varchar只要不超过限定的范围，底层是可以自动根据你输入的数据来分配空间的。Char的话，分配的空间就定死了。比如一个数据类型的长度始终是固定的，例如生日啊，男女性别啊，就用char , 其他不定的情况就用varchar, 例如简介啊，姓名啊之类的。char的效率比varchar要高嗷！！！</p>
</li>
<li><p>clob和blob怎么使用，大文本用CLOB，图片啊之类的数据必须使用BLOB，Java中必须使用IO流才能写入BLOB。图片啊之类的如果大的话就别放在db里面了嗷！</p>
</li>
<li><p>表名再数据库中一般建议以t_或者tbl_开始。</p>
</li>
<li><p>举个例子：创建学生表   学号：bigint , 姓名：varchar , 班级编号：int</p>
</li>
</ul>
<p>性别：char ,  生日：char</p>
</li>
</ul>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_student(</span><br><span class="line">	<span class="keyword">no</span> <span class="type">bigint</span>,</span><br><span class="line">	names <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">	sex <span class="type">char</span>(<span class="number">1</span>),</span><br><span class="line">	classno <span class="type">varchar</span>(<span class="number">255</span>),</span><br><span class="line">	birth <span class="type">char</span>(<span class="number">10</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>create另一种用法：（表的复制）</p>
<ul>
<li><code>create table emp as select emp.ename from emp;</code></li>
<li>create table 表名 as select语句，将查询结果当作表创建出来</li>
</ul>
</li>
<li><p>删除表格：</p>
<ul>
<li>drop table 表名;</li>
<li>drop table if exits 表名; 如果表存在的话就把表删掉。</li>
</ul>
</li>
<li><p>alter table 表名 rename to 新表名 ， 表的重命名</p>
</li>
<li><p>对于表的结构的修改这里暂时不讲了，因为实际开发过程中用的比较少，即使修改也可以使用工具，出现在java代码中的数据只有增删改查操作(CRUD) —-&gt; Create Retrieve Update Delete</p>
</li>
</ul>
<h4 id="DML："><a href="#DML：" class="headerlink" title="DML："></a>DML：</h4><ul>
<li><p>insert</p>
<p>写法一：</p>
<ul>
<li><code>insert into t_student values(1, &#39;Jack&#39;, &#39;o&#39;,&#39;高三二班,&#39;1996-10-12&#39;)</code></li>
</ul>
<p>写法二：</p>
<ul>
<li><code>insert into t_student(name) values(&#39;ZhangSan&#39;)</code>，这个东西实际上，会自动把他补上</li>
<li>列的数量必须和给予数据的数量相同，字段省略不写的话，后面的顺序和数量就要和默认表的一样的。</li>
</ul>
<p>写法三：</p>
<ul>
<li><code>insert into t_student(no,name) values(2,&#39;兔子&#39;),(3,&#39;乐乐&#39;) </code></li>
</ul>
</li>
<li><p>insert</p>
<ul>
<li><code>insert into tbl1 select * from dept;</code>这个不一定可以哦，列数相同才对的上哦。将查询结果当作数据插入到表里。</li>
</ul>
</li>
<li><p>update</p>
<ul>
<li>用于修改条件的时候使用的</li>
<li>update 表名 set 字段1&#x3D;值1 , … where 条件; 如果不写条件的话就是整整一张表都要更新哦！这里多个条件的设置是用“，”哦，不是用and呢！！！</li>
<li>更新所有记录：<code>update dept1 set loc = &#39;x&#39; , dname = &#39;y&#39;</code></li>
</ul>
</li>
<li><p>delete</p>
<ul>
<li>用于删除数据</li>
<li>没有条件会全部删除</li>
<li><code>delete from dept1 where deptno=10;</code></li>
<li>全部删除：delete from dept1;</li>
<li>执行语句比较慢，而且不释放空间，可以回滚，这个是可以追溯的。如果要删的快而且删的彻底的话。</li>
<li>truncate table 表名;  表被截断，不可回滚，彻底丢失。这个是把表截断，只留下表头，其他彻底删除。</li>
</ul>
</li>
</ul>
<h1 id="创建表加入约束"><a href="#创建表加入约束" class="headerlink" title="创建表加入约束"></a>创建表加入约束</h1><ul>
<li>什么是约束：例如数据不能重复，数据不能为空之类的，约束的目的在于保证表中的数据的合法性，有效性，完整性</li>
<li>种类：<ul>
<li>非空约束(not null)：约束的字段不能为Null</li>
<li>唯一约束(unique)：约束的字段不能重复</li>
<li>主键约束(primary key)：约束的字段不能为NULL，也不能重复</li>
<li>外键约束(foreign key)：</li>
<li>检查约束(check)：Oracle中有check约束 , mysql目前不支持该约束</li>
</ul>
</li>
</ul>
<h2 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h2><ul>
<li>一个例子：<ul>
<li><code>create table t_user(id int, username varchar(255) not null, password varchar(255));</code></li>
<li>这个只能加在字段后面，是不可以作为表级约束的。</li>
</ul>
</li>
</ul>
<h2 id="唯一性约束"><a href="#唯一性约束" class="headerlink" title="唯一性约束"></a>唯一性约束</h2><ul>
<li><p>unique , 修饰的字段具有唯一性，不能重复，但可以为NULL，NULL和NULL是不一样的，可以重复。</p>
</li>
<li><pre><code class="sql">create table t_user(
    id int,
    username varchar(255) unique
)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 注意一下，唯一性是可以为NULL的，给多个列添加unique</span><br><span class="line"></span><br><span class="line">- 此外，在insert中，可以选择插入的字段，其余的字段会用系统初始的默认值，如果在create表的时候，在字段后面给予了自定义的默认值，则默认的值为你定义的默认值。</span><br><span class="line"></span><br><span class="line">- 给多个列加unique:</span><br><span class="line"></span><br><span class="line">  - ```sql</span><br><span class="line">    create table t_user(</span><br><span class="line">    	id int,</span><br><span class="line">    	username varchar(255),</span><br><span class="line">    	usercode varchar(255),</span><br><span class="line">    	unique(usercode,username)</span><br><span class="line">    );//这个是两个数据联合起来添加一个约束，就是说这两个不能同时相同</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="sql">create table t_user(	
    id int,
    username varchar(255) unique,
    usercode varchar(255) unique
);//这个是对于两个字段分别添加约束，每一个都不能重
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 这里就有两个概念，上面一个是列级约束，上面第二个是表级约束。</span><br><span class="line"></span><br><span class="line">- 非空约束只能在字段后面加，往后面加是没有表级约束的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 主键约束</span><br><span class="line"></span><br><span class="line">- ```sql</span><br><span class="line">  create table t_user(	</span><br><span class="line">  	id int primary key, // 列级约束</span><br><span class="line">  	username varchar(255) unique,</span><br><span class="line">  	usercode varchar(255) unique</span><br><span class="line">  );//主键字段不能为空，也不能重复</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>主键相关的术语：</p>
<ul>
<li>主键字段</li>
<li>主键值</li>
<li>主键约束</li>
</ul>
</li>
<li><p>作用：</p>
<ul>
<li><p>sql设计三范式中有要求，要求任何一张表都有主键</p>
</li>
<li><p>主键的作用是啥？</p>
<ul>
<li>主键是一行的唯一标识，就像身份证号码一样，只要主键值不一样，就可以认为两条记录完全不一样。</li>
</ul>
</li>
<li><p>主键的分类：</p>
<ul>
<li>按照主键字段和数据量：<ul>
<li>单一主键（常用到的）</li>
<li>复合主键（不常用，违背三范式，多个字段联合起来添加一个主键约束）</li>
</ul>
</li>
<li>根据主键性质来划分：<ul>
<li>自然主键（推荐，这种方式和业务无任何挂钩，推荐）</li>
<li>业务主键：最好主键和其他值不挂钩，比如说id和身份证分开，不用身份证做主键。不然业务一旦发生改变的时候，主键可能也跟着发生变化，但是有时候可能没有办法变化，这就很尴尬。</li>
</ul>
</li>
</ul>
</li>
<li><p>一个表中主键约束只能有一个</p>
</li>
<li><p>使用标记约束定义主键：</p>
<ul>
<li>&#96;&#96;&#96;sql<br>create table t_user(<br>id int,<br>username varchar(255),<br>primary key(id)<br>);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```sql</span><br><span class="line">  create table t_user(</span><br><span class="line">  	id int,</span><br><span class="line">  	username varchar(255),</span><br><span class="line">  	primary key(id,username)</span><br><span class="line">  );</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>mysql提供主键值自增：</p>
<ul>
<li>&#96;&#96;&#96;mysql<br>create table t_user(<br>id int primary key auto_increment,   &#x2F;&#x2F;id字段自动维护一个自增的字段，从1开始，以1自增<br>username varchar(255)<br>);<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - Oracle中也提供了一个自增机制，叫做sequence（序列）</span><br><span class="line"></span><br><span class="line">## 外键约束</span><br><span class="line"></span><br><span class="line">- 相关术语：</span><br><span class="line"></span><br><span class="line">  - 外键约束：foreign key</span><br><span class="line">  - 外键字段：添加有外键约束的字段</span><br><span class="line">  - 外键值：外键字段中的每一个值</span><br><span class="line"></span><br><span class="line">- 业务背景：</span><br><span class="line"></span><br><span class="line">  - 设计数据表，用来维护学生和搬家的信息</span><br><span class="line"></span><br><span class="line">  - 做法和想法：</span><br><span class="line"></span><br><span class="line">    - 放在一张表中（缺点是冗余）</span><br><span class="line">    - 放在两张表中（班级表和学生表）</span><br><span class="line"></span><br><span class="line">  - 比如上面两张表要关联起来，我们就需要外键，不加外键约束的话可以随便写，而如果添加了外键的话，写的值就有一定的范围的。</span><br><span class="line"></span><br><span class="line">  - t_student中的classno字段引用t_class表中的cno地段，此时t_student表叫做组表，t_class表叫做父表。删除数据的时候先删除子表再删除父表，创建或者添加数据的时候，先添加父表再添加子表。两张表之间有明显的依赖关系。</span><br><span class="line"></span><br><span class="line">  - ```sql</span><br><span class="line">    create table t_class(</span><br><span class="line">    	cno int,</span><br><span class="line">    	cname varchar(255),</span><br><span class="line">    	primary key(cno)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    create table t_student(</span><br><span class="line">    	sno int primary key auto_increment,</span><br><span class="line">    	sname varchar(255),</span><br><span class="line">        classno int,</span><br><span class="line">        primary key(sno),</span><br><span class="line">    	foreign key(classno) references t_class(cno)</span><br><span class="line">    );</span><br><span class="line">    </span><br><span class="line">    //先插入父表数据，再插入子表数据</span><br><span class="line">    insert into t_class values(101,&#x27;xxxxxxxxx&#x27;);</span><br><span class="line">    insert into t_class values(102,&#x27;yyyyyyyyy&#x27;);</span><br><span class="line">    insert into t_student values(&#x27;zs1&#x27;,101);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>外键值可以为NULL？</p>
<ul>
<li><code>insert into t_student(sno,sname) values(6,&#39;zs6&#39;)</code></li>
<li>外键可以为NULL</li>
</ul>
</li>
<li><p>外键字段引用别的表的字段的时候，被引用的字段必须是主键否？不一定，但是对应的字段必须要是唯一的。不然对应的外键说不清对应的是哪一个，一般情况下都是要对应主键的，不对应的话至少要有unique约束</p>
</li>
</ul>
<h1 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h1><ul>
<li><p>描述的表的存储方式，例如InnoDB , <code>ENGINE=InnoDB</code>等</p>
</li>
<li><p>完整的建表语句还要加上engine的，例如</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `t_x`(</span><br><span class="line">	`id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">DEFAULT</span> <span class="keyword">NULL</span></span><br><span class="line">)ENGINR<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf<span class="number">-8</span></span><br></pre></td></tr></table></figure>

<p>mention: 在mysql中，凡是自己定义的标识符都是可以使用飘号括起来的，最好别用，不是通用的。</p>
<p>建表的时候使用的引擎是InnoDB，默认的字体为utf-8</p>
</li>
<li><p>what is engine? 这个名字只有在mysql中存在，oracle中则有对应的机制，但是不叫存储引擎。每一个存储引擎都有自己的优缺点。</p>
</li>
<li><p>查看当前mysql支持的存储引擎，<code>show engines \G;</code></p>
</li>
<li><p>经典的存储引擎有：</p>
<ul>
<li>InnoDB：<ul>
<li>是数据库的默认引擎</li>
<li>优缺点：<ul>
<li>优点：支持事务，行级锁，外键。数据存储比较安全。表的结构存储在xxx.frm文件中。在mysql数据库崩溃后自动恢复。支持级联删除，级联更新（父级会影响所有的孩子，开发的时候比较少用）。事务，安全，重量级。</li>
<li>缺点：处理速度不是最快的</li>
</ul>
</li>
</ul>
</li>
<li>MyISAM：<ul>
<li>之前最常用的存储引擎</li>
<li>采用三个文件表示每个表：<ul>
<li>格式文件</li>
<li>数据文件</li>
<li>索引文件</li>
</ul>
</li>
<li>优缺点：<ul>
<li>优点：可被压缩，节省存储空间。可压缩，可转换形式，节省空间。</li>
<li>缺点：不支持事务</li>
</ul>
</li>
</ul>
</li>
<li>Memory:<ul>
<li>优缺点：<ul>
<li>缺点：<ul>
<li>不支持事务</li>
<li>数据容易丢失，数据和索引都是在内存当中</li>
<li>不能包含TEXT和BLOB</li>
<li>断电后数据就丢失了。</li>
</ul>
</li>
<li>有点：<ul>
<li>搜索速度最快</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="事务（Transaction）概述："><a href="#事务（Transaction）概述：" class="headerlink" title="事务（Transaction）概述："></a>事务（Transaction）概述：</h1><ul>
<li>一个事务是一个完整的业务逻辑单元，不可再分。（相当于原子操作！！！和操作系统就连上了，本质上实现了线程同步！！！）</li>
<li>例如：从银行转账，从A账户转B账户10000元，那有转入和转出两条语句。想要保证上面两条操作同时成功或者同时失败，就要使用数据库的“事务机制”。</li>
<li>只有DML语句才有事务，其他的语句和事务都没关系，因为只有这三条语句才和数据操作有关。事务时为了保证数据的<strong>完整性，安全性</strong>。</li>
<li>假设所有的业务都能使用一条DML解决，那就不需要事务了。只有需要多个DML操作组合成一个事物的时候，才需要事务操作。通常一个事务多条DML才需要操作。</li>
<li>本质相当于将多条DML语句打包成原子操作！！！</li>
<li>原理，how to control ？<ul>
<li>开启事务机制：<ul>
<li>执行insert，先执行保存到操作历史中，不会操作硬盘上的数据</li>
<li>执行update，先执行保存到操作历史中，不会操作硬盘上的数据</li>
<li>执行delete，先执行保存到操作历史中，不会操作硬盘上的数据</li>
<li>最后提交或者回滚事务：（本质就是操作绑定嘛！！！）<ul>
<li>提交：将历史操作更改同步到硬盘文件当中，并将历史操作清空。（成功）</li>
<li>回滚：直接清空历史记录，不同步到硬盘当中。（失败）</li>
</ul>
</li>
<li>提交事务：commit , 回滚事务：rollback</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="TCL"><a href="#TCL" class="headerlink" title="TCL:"></a>TCL:</h3><ul>
<li>commit-提交</li>
<li>rollback-回滚</li>
<li>savepoint: 保存点，可以滚到某一个点，相当于保存游戏进度。</li>
</ul>
<h3 id="事务的特性："><a href="#事务的特性：" class="headerlink" title="事务的特性："></a>事务的特性：</h3><ul>
<li>原子性：事务是最小的工作单元，不可再分。(A)</li>
<li>一致性：事务必须保证多条DML语句同时成功或者同时失败。(C)</li>
<li>隔离性：事务A与事务B之间具有隔离。（隔离级别的概念，级别不一样，影响效果不同。）(I)</li>
<li>持久性：持久性说的是数据最终必须持久化到硬盘文件中，事务才算成功的结束。(D)</li>
</ul>
<h3 id="事务的隔离性："><a href="#事务的隔离性：" class="headerlink" title="事务的隔离性："></a>事务的隔离性：</h3><ul>
<li><p>隔离级别：</p>
<ul>
<li>理论上包括四个：<ul>
<li>第一级别：读未提交(read uncommitted)：别人未提交的事务的我们当前事务能够读到。存在脏读（Dirty Read）现象，读到了脏的数据。</li>
<li>第二级别：读已提交(read committed)：对方提交的事务我们才能读到。解决了脏读的问题，但是存在不可重复读的现象，别人改了我的数据的话，每次读到的都是最新的数据，出来的结果是不一样的。</li>
<li>第三级别：可重复读(repeatable read)：解决了不可重复读的问题。但是存在的问题是，读取到的数据是幻象。每次读的数据都是备份数据，所以都是相同的，存在读的是假数据的问题。</li>
<li>第四级别：序列化读&#x2F;串行化读(serializable)，解决了所有问题。但是效率低，需要事务排队。</li>
</ul>
</li>
<li>mysql默认是第三级别，oracle默认是第二级别。</li>
</ul>
</li>
<li><p>mysql事务默认是自动提交的，就是执行一条DML，自动提交一次。</p>
</li>
<li><p>how to close自动提交：</p>
<ul>
<li><p>start transaction ;  &#x2F;&#x2F;这个会开启事务，关闭自动提交机制。</p>
</li>
<li><p>演示：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> if <span class="keyword">exists</span> t_user;</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_user(</span><br><span class="line">	id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    username <span class="type">varchar</span>(<span class="number">255</span>)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">rollback</span>; <span class="operator">/</span><span class="operator">/</span>这个是回不去的，自动提交了。。。</span><br></pre></td></tr></table></figure>
</li>
<li><p>感觉有点像git的使用！！！</p>
</li>
<li><p>rollback等命令执行完之后，事务就结束了，如果还要写事务，还记得要加start transaction，这个就类似于开启git功能？？？</p>
</li>
</ul>
</li>
<li><p>savepoint name; 设置保存点，再输入rollback name; ， 这就可以滚回提交点了。</p>
</li>
<li><p>更改隔离级别：<code>set global transaction isolation level read uncommitted;</code>其他的用法都是一样的，只是后面改个名字而已。</p>
</li>
<li><p>查看事务的全局隔离级别：<code> select @@global.transaction_isolation;</code></p>
</li>
<li><p>可以同时打开两个终端显示操作来演示嗷！！！每种都有自己各自符合的方式嗷！！！</p>
</li>
</ul>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><ul>
<li><p>什么是索引，有什么用：</p>
<ul>
<li>相当于一本书的目录，通过目录可以快速找到对应的资源。数据库方面，一张表的查询有两种方式：<ul>
<li>全表扫描</li>
<li>根据索引检索（效率很高）</li>
</ul>
</li>
<li>第二种由于缩小了扫描的范围，因此可以提高检索的效率。索引虽然效率高，但是不能随意添加索引，因为索引是数据库中的数据，也是有维护成本的。</li>
<li>索引是给某一个字段，或者说某些字段添加索引。</li>
</ul>
</li>
<li><p>什么时候考虑添加索引呢？</p>
<ul>
<li>数据量庞大。（根据客户的要求，根据线上的环境）</li>
<li>该字段很少的DML操作。（因为字段进行修改操作，索引也需要维护）</li>
<li>该字段经常出现在where子句中。（经常根据哪个字段查询）</li>
</ul>
</li>
<li><p>注意：主键和具有unique约束的字段会自动添加索引。</p>
</li>
<li><p>普通的select语句，where后面的操作都是全表扫描</p>
</li>
<li><p><code>explain select ...</code>这个后面跟着会显示类似于type之类的信息。可以查看mysql中语句的执行计划</p>
</li>
</ul>
<h2 id="添加索引："><a href="#添加索引：" class="headerlink" title="添加索引："></a>添加索引：</h2><ul>
<li><code>craete index emp_sal_index on emp(sal);</code></li>
<li>底层用的是B-Tree数据结构，查询效率很高。</li>
<li>再去查看查询的条数之类的，发现明显变少</li>
<li><code>create index index_name on table_name(字段);</code></li>
</ul>
<h2 id="删除索引："><a href="#删除索引：" class="headerlink" title="删除索引："></a>删除索引：</h2><ul>
<li><code>drop index index_name on table_name;</code></li>
</ul>
<h2 id="底层数据结构："><a href="#底层数据结构：" class="headerlink" title="底层数据结构："></a>底层数据结构：</h2><ul>
<li>B+Tree</li>
<li>底层原理：<ul>
<li>当字段上没有索引的时候，全表扫描，效率较低</li>
<li>处理：<ul>
<li>首先，索引会对于记录进行排序</li>
<li>接下来，会在硬盘文件或内存（不同的引擎不同）生成索引对象</li>
<li>然后，索引会分区，例如人名的话，就会用名字字母分区，储存为B+树。</li>
</ul>
</li>
<li>select的时候，首先查看ename字段有没有对应的索引，如果有的话，根据索引对于数据进行定位，缩短了扫描的数量，很快定位到了。oracle中物理地址就是rowid。这个树中，还携带了物理地址，根据索引对应的物理地址，拿到物理地址对应的对象，不走表了，直接根据地址拿到数据。（二分查找）</li>
</ul>
</li>
<li>索引不是万能的</li>
<li>总结：B Tree缩小了扫描范围，底层索引进行了排序，分区，索引携带“物理地址”。通过索引检索到数据，获得关联的物理地址，通过物理地址，定位表中的数据，效率是最高的。</li>
</ul>
<h2 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h2><ul>
<li>单一索引：单个字段添加索引</li>
<li>复合索引：多个字段联合添加索引</li>
<li>主键索引：主键自动添加索引</li>
<li>唯一索引：有unique约束的字段自动添加索引</li>
</ul>
<h2 id="索引失效："><a href="#索引失效：" class="headerlink" title="索引失效："></a>索引失效：</h2><ul>
<li>模糊查询的时候，例如通配符，”%A%”没办法用B树去索引，第一个尽量不要使百分号。这样会造成索引失效。</li>
</ul>
<h1 id="视图-view"><a href="#视图-view" class="headerlink" title="视图(view)"></a>视图(view)</h1><ul>
<li>what is view?<ul>
<li>站在不同的角度去看到数据</li>
</ul>
</li>
<li>how to create &#x2F; delete view?<ul>
<li>create view view_name as select empno,ename from emp; </li>
<li>对于视图的增删改查，会影响到原表的数据，但是是通过视图来实现的。（不是直接操作原表）</li>
<li>只有DQL语句才能创建视图，但是对于视图可以CRUD操作。</li>
</ul>
</li>
<li>为啥要引入视图呢？<ul>
<li>保密，只给你部门的数据，甚至重命名，对应的数据也可以不给你的，但是对于视图的操作，可以直接作用到原表上。</li>
<li>视图可以隐藏表的实现细节，适用于保密级别较高的系统。</li>
</ul>
</li>
</ul>
<h1 id="数据库的数据的导入导出"><a href="#数据库的数据的导入导出" class="headerlink" title="数据库的数据的导入导出"></a>数据库的数据的导入导出</h1><ul>
<li>DBA命令：导入，导出（被封）</li>
</ul>
<h2 id="导出数据："><a href="#导出数据：" class="headerlink" title="导出数据："></a>导出数据：</h2><p>Windows中的dos命令窗口：</p>
<ul>
<li><code>mysqldump sql-name&gt;某个盘\test.sql -uroot -ppassword</code></li>
</ul>
<h2 id="导入数据："><a href="#导入数据：" class="headerlink" title="导入数据："></a>导入数据：</h2><ul>
<li>create database …;</li>
<li>use databasename;</li>
<li>source sql文件</li>
</ul>
<h2 id="导出指定表："><a href="#导出指定表：" class="headerlink" title="导出指定表："></a>导出指定表：</h2><ul>
<li><code>mysqldump databaseName tableName&gt;.sql文件 -uroot -ppassword</code></li>
</ul>
<h1 id="数据库设计三范式"><a href="#数据库设计三范式" class="headerlink" title="数据库设计三范式"></a>数据库设计三范式</h1><ul>
<li><p>what?</p>
<ul>
<li>设计表的依据，这么设计不会出现冗余</li>
</ul>
</li>
<li><p>是哪些？</p>
<ol>
<li>任何一张表都应该有主键，并且每一个字段的原子性不可再分。</li>
<li>在一范式基础上，所有非主键字段必须完全依赖主键，<strong>不能产生部分依赖</strong>。（有可能出现数据冗余，不推荐复合主键）。</li>
<li>在二范式基础上，所有非主键关系直接依赖主键字段，<strong>不能产生传递依赖</strong>。（例如班级和班级序号，这就产生了传递依赖，传递依赖本质就是出现了数据冗余。）</li>
</ol>
</li>
<li><p>两条口诀：</p>
<ul>
<li>多对多，三张表，关系表，两外键。</li>
<li>一对多，两张表，多的表，加外键。</li>
</ul>
</li>
<li><p>实际开发中，以满足客户需求为主，有的时候会拿冗余换执行速度。</p>
</li>
<li><p>一对一如何设计？？？</p>
<ul>
<li>有可能有两张表，例如用户信息，可以把详细信息拆分为用户名，密码，与详细信息表。</li>
<li>两种设计方案：<ul>
<li>主键共享：<ul>
<li>pk+fk：保证了一对一</li>
</ul>
</li>
<li>外键唯一：<ul>
<li>fk+unique约束：保证了一对一</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="练习题："><a href="#练习题：" class="headerlink" title="练习题："></a>练习题：</h1><ol>
<li><p>取出每个部门最高薪水的人员名称</p>
<ul>
<li><p>第一，取得每个部门的最高薪水</p>
<ul>
<li><code>select deptno , max(sal) as maxsal from emp group by deptno;</code></li>
</ul>
</li>
<li><p>第二，通过以上的表取出最高薪水的人员名称：</p>
<ul>
<li>&#96;&#96;&#96;sql<br>select e.ename , t.*<br>from<br>emp e<br>join<br>(select deptno , max(sal) as maxsal from emp group by deptno) t<br>on<br>e.sal &#x3D; t.maxsal and e.deptno &#x3D; t.deptno;<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. 哪些人的薪水在部门平均薪水之上</span><br><span class="line"></span><br><span class="line">   - 第一，求出每个部门的平均薪水：</span><br><span class="line"></span><br><span class="line">     - `select deptno , avg(sal) from emp group by deptno;`</span><br><span class="line"></span><br><span class="line">   - 通过以上的零食表构建关系，找出高于平均工资的人:</span><br><span class="line"></span><br><span class="line">     - ```sql</span><br><span class="line">       select e.deptno , e.ename , e.sal , t.avgsal from emp e</span><br><span class="line">       join </span><br><span class="line">       (select deptno , avg(sal) avgsal from emp group by deptno) t</span><br><span class="line">       on</span><br><span class="line">       e.deptno = t.deptno and e.sal &gt; t.avgsal;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>取得部门中所有人的平均的薪水等级</strong></p>
<ul>
<li><p>第一，求出所有人的薪水等级</p>
<ul>
<li><pre><code class="sql">select 
e.deptno , avg(t.grade)
from 
emp e
join 
salgrade t
on
e.sal &gt; t.losal and e.sal &lt; t.hisal
group by
e.deptno;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">       </span><br><span class="line">     </span><br><span class="line">   - 第二，这儿连接成一张表之后就很方便可以继续group by，没有必要再当成一张临时表去操作啦！</span><br><span class="line"></span><br><span class="line">   - ![image-20210310172059646](https://i.loli.net/2021/03/10/MIJV8LYKbk1sTwn.png)</span><br><span class="line"></span><br><span class="line">4. 不用组函数(Max)，取得最高薪水（给出两种方式）</span><br><span class="line"></span><br><span class="line">   - 第一种：`select ename,sal from emp order by sal desc limit 1;`(降序排序+limit取出第一个)</span><br><span class="line">   - 第二种：用max</span><br><span class="line">   - 第三种：表的自连接：`select distinct a.sal from emp a join emp b on a.sal &lt; b.sal;`(只要b表中存在比a表中大的工资，都会被找出来！！！然后distinct，换句话说，没被找出来的，就是最大工资！！！)`select sal from emp where sal not in (select distinct a.sal as hehe from emp a join emp b on a.sal &lt; b.sal);` 这儿也说明，和一列比较是和每一个值分别比较，尤其是in和not in这种，和列名无关。</span><br><span class="line">   </span><br><span class="line">5. 取得平均薪水最高的部门的部门编号</span><br><span class="line"></span><br><span class="line">   - 取得部门的平均薪水,  然后降序选第一个 ， 用limit求出最大值：</span><br><span class="line"></span><br><span class="line">     - `select deptno , avg(sal) as avgsal from emp group by deptno order by avgsal desc limit 1;`</span><br><span class="line">     - 作为临时表查找最高的avg(sal)</span><br><span class="line"></span><br><span class="line">   - ```sql</span><br><span class="line">     (select deptno , avg(sal) as avgsal from emp group by deptno) t //找出每个部门平均薪资</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><code>select max(avgsal) from (select deptno , avg(sal) as avgsal from emp group by deptno) t;</code>&#x2F;&#x2F;找出最大值</p>
</li>
<li><p><code>select deptno,avg(sal) as avgsal from emp group by deptno having avgsal = (select max(avgsal) from (select deptno , avg(sal) as avgsal from emp group by deptno) t);</code>&#x2F;&#x2F;使用分组后过滤。</p>
</li>
</ul>
</li>
<li><p>查出平均工资表后用自连接就直接找的呀，一个的avgsal &#x3D; 第二个的max(avgsal)</p>
</li>
</ul>
</li>
<li><p>取出平均薪水最高的部门名称</p>
<ul>
<li><pre><code class="sql">select 
e.deptno , avg(e.sal) as avgsal ,d.dname
from 
emp e 
join 
dept d
on
e.deptno = d.deptno
group by 
deptno 
order by 
avgsal 
desc 
limit 1;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">7. 求平均薪水等级最低的部门的部门名称</span><br><span class="line"></span><br><span class="line">   - 求出每个部门的平均薪水等级：</span><br><span class="line"></span><br><span class="line">     - ```sql</span><br><span class="line">       select</span><br><span class="line">       e.deptno , avg(s.grade) as avggrade</span><br><span class="line">       from</span><br><span class="line">       emp e</span><br><span class="line">       join</span><br><span class="line">       salgrade s</span><br><span class="line">       on</span><br><span class="line">       e.sal &gt; s.losal and e.sal &lt; s.hisal</span><br><span class="line">       group by</span><br><span class="line">       e.deptno</span><br><span class="line">       order by</span><br><span class="line">       avggrade asc</span><br><span class="line">       limit</span><br><span class="line">       1;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>上面就是答案，表连接实际上只是把表补全了而已，from…和join…on实际上就是一个新的表了，根据新的表，我们对于deptno进行分组，求出平均薪资。<strong>对于avg(sal)进行排序，然后取出最小值。</strong></p>
</li>
<li><p>如果多个值的话，可能就要用having avg(sal) &#x3D; ***，这种形式来过滤出最小值。</p>
</li>
</ul>
</li>
<li><p>取得比普通员工的最高薪水还要高的领导人的姓名</p>
<ul>
<li>找出普通员工（员工编号没有在mgr字段里面）<ul>
<li><code>select * from emp where empno not in (select distinct mgr from emp where mgr is not null);</code></li>
<li>not in使用过程中，记得排除掉里面的NULL</li>
<li>distinct在select后面才能使用</li>
<li>not in后面和一列比较，这一列要先用select提取出来，有点像固定搭配的感觉。</li>
</ul>
</li>
<li>找出普通员工的最高薪水<ul>
<li><code>select max(sal) from emp where empno not in (select distinct mgr from emp where mgr is not null);</code></li>
</ul>
</li>
<li>找出薪资高于1600的<ul>
<li><code>select * from emp where sal &gt; (select max(sal) from emp where empno not in (select distinct mgr from emp where mgr is not null));</code></li>
</ul>
</li>
<li>！！！比普通员工最高薪水还要高的领导，比普通员工最高薪水还要高的一定不是普通员工。</li>
</ul>
</li>
<li><p>取得薪水最高的前五名普通员工</p>
<ul>
<li><p>先取出员工：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">empno </span><br><span class="line"><span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line">(<span class="keyword">select</span> mgr <span class="keyword">from</span> emp <span class="keyword">where</span> mgr <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p>取出薪资最高的前五名：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> sal , ename <span class="keyword">from</span></span><br><span class="line">emp</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">empno </span><br><span class="line"><span class="keyword">not</span> <span class="keyword">in</span></span><br><span class="line">(<span class="keyword">select</span> mgr <span class="keyword">from</span> emp <span class="keyword">where</span> mgr <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">null</span>)</span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line">sal</span><br><span class="line"><span class="keyword">desc</span></span><br><span class="line">limit <span class="number">5</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>取出薪水最高的第六到第十名员工</p>
<ul>
<li><pre><code class="sql">select 
sal , ename
from
emp
order by
sal
desc
limit 5,5;
</code></pre>
</li>
<li><p>这儿注意下，limit后面是没有括号的，而且下表是从0开始的，5在这里表示第六个数。</p>
</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/03/09/MySQL%E5%AD%A6%E4%B9%A0/" data-id="cl6gepmfr0026e0jq6t6zh70r" data-title="MySQL学习" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag">后端</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/03/13/%E5%88%9D%E8%AF%86Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          初识Java反射机制
        
      </div>
    </a>
  
  
    <a href="/2021/03/01/Maven%E5%AD%A6%E4%B9%A0/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Maven学习</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/2021%E5%B9%B4%E7%BE%8E%E8%B5%9B/">2021年美赛</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/2021%E5%B9%B4%E7%BE%8E%E8%B5%9B/Python/">Python</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%A8%E5%8A%9B%E7%BB%93%E7%82%B9%E5%90%8E%E7%AB%AF/">动力结点后端</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8A%A8%E5%8A%9B%E7%BB%93%E7%82%B9%E5%90%8E%E7%AB%AF%E8%AF%BE%E7%A8%8B/">动力结点后端课程</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%87%AA%E5%AD%A6%E5%86%85%E5%AE%B9%E6%88%96%E8%AF%BE%E7%A8%8B%E4%BD%9C%E4%B8%9A/">自学内容或课程作业</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/Database/" rel="tag">Database</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Python/" rel="tag">Python</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Skills/" rel="tag">Skills</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/introduction/" rel="tag">introduction</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/" rel="tag">云服务器与项目部署</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%89%8D%E7%AB%AF/" rel="tag">前端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8E%E7%AB%AF/" rel="tag">后端</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E4%B8%80%E5%AD%A6%E4%B9%A0/" rel="tag">大一学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E4%B8%89%E8%87%AA%E5%AD%A6/" rel="tag">大三自学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%A4%A7%E4%BA%8C%E8%87%AA%E5%AD%A6/" rel="tag">大二自学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" rel="tag">机器学习</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BE%8E%E8%B5%9B/" rel="tag">美赛</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/" rel="tag">论文精读</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%AB/" rel="tag">读书分享</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E8%B5%84%E6%BA%90%E7%A6%8F%E5%88%A9%EF%BC%81%EF%BC%81%EF%BC%81/" rel="tag">资源福利！！！</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Database/" style="font-size: 12.22px;">Database</a> <a href="/tags/Python/" style="font-size: 16.67px;">Python</a> <a href="/tags/Skills/" style="font-size: 10px;">Skills</a> <a href="/tags/introduction/" style="font-size: 11.11px;">introduction</a> <a href="/tags/%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8E%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/" style="font-size: 12.22px;">云服务器与项目部署</a> <a href="/tags/%E5%89%8D%E7%AB%AF/" style="font-size: 15.56px;">前端</a> <a href="/tags/%E5%90%8E%E7%AB%AF/" style="font-size: 18.89px;">后端</a> <a href="/tags/%E5%A4%A7%E4%B8%80%E5%AD%A6%E4%B9%A0/" style="font-size: 14.44px;">大一学习</a> <a href="/tags/%E5%A4%A7%E4%B8%89%E8%87%AA%E5%AD%A6/" style="font-size: 17.78px;">大三自学</a> <a href="/tags/%E5%A4%A7%E4%BA%8C%E8%87%AA%E5%AD%A6/" style="font-size: 15.56px;">大二自学</a> <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 11.11px;">机器学习</a> <a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 10px;">算法</a> <a href="/tags/%E7%BE%8E%E8%B5%9B/" style="font-size: 20px;">美赛</a> <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 13.33px;">计算机网络</a> <a href="/tags/%E8%AE%BA%E6%96%87%E7%B2%BE%E8%AF%BB/" style="font-size: 10px;">论文精读</a> <a href="/tags/%E8%AF%BB%E4%B9%A6%E5%88%86%E4%BA%AB/" style="font-size: 10px;">读书分享</a> <a href="/tags/%E8%B5%84%E6%BA%90%E7%A6%8F%E5%88%A9%EF%BC%81%EF%BC%81%EF%BC%81/" style="font-size: 10px;">资源福利！！！</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">October 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/06/">June 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">May 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/03/">March 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/02/">February 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/01/16/ML%E5%85%A5%E9%97%A8/">ML入门</a>
          </li>
        
          <li>
            <a href="/2021/12/28/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A03/">大数据分析与智能计算期末复习3</a>
          </li>
        
          <li>
            <a href="/2021/12/24/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A02/">大数据分析与智能计算期末复习2</a>
          </li>
        
          <li>
            <a href="/2021/12/20/%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E6%99%BA%E8%83%BD%E8%AE%A1%E7%AE%97%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">大数据分析与智能计算期末复习</a>
          </li>
        
          <li>
            <a href="/2021/12/13/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84%E8%AF%BE%E7%A8%8B%E6%9C%9F%E6%9C%AB%E5%A4%8D%E4%B9%A0/">系统架构课程期末复习</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 John Doe<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>