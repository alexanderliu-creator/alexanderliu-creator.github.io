<!DOCTYPE HTML>
<html lang="en">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="Go究极李文周网课学习, Hexo">
    <meta name="description" content="这儿是对于Go语言整体系统的学习，是b站李文周老师的教程的整理的内容和自己的学习心得体会，记录在这儿






关于变量的声明
变量声明可以用

12345var(	str string	a   int	wheater bool)


变">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>Go究极李文周网课学习 | Hexo</title>
    <link rel="icon" type="image/png" href="/favicon.png">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.2.0"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Hexo</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>Index</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>Tags</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>Categories</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>Archives</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>About</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/contact" class="waves-effect waves-light">
      
      <i class="fas fa-comments" style="zoom: 0.6;"></i>
      
      <span>Contact</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>Friends</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Hexo</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Index
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			Tags
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			Categories
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			Archives
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			About
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/contact" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-comments"></i>
			
			Contact
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			Friends
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/blinkfox/hexo-theme-matery" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/blinkfox/hexo-theme-matery" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('/medias/featureimages/5.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">Go究极李文周网课学习</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/%E5%90%8E%E7%AB%AF/">
                                <span class="chip bg-color">后端</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2021-02-20
                </div>
                

                

                

                

                
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="这儿是对于Go语言整体系统的学习，是b站李文周老师的教程的整理的内容和自己的学习心得体会，记录在这儿"><a href="#这儿是对于Go语言整体系统的学习，是b站李文周老师的教程的整理的内容和自己的学习心得体会，记录在这儿" class="headerlink" title="这儿是对于Go语言整体系统的学习，是b站李文周老师的教程的整理的内容和自己的学习心得体会，记录在这儿"></a>这儿是对于Go语言整体系统的学习，是b站李文周老师的教程的整理的内容和自己的学习心得体会，记录在这儿</h1><hr>
<span id="more"></span>





<h1 id="关于变量的声明"><a href="#关于变量的声明" class="headerlink" title="关于变量的声明"></a>关于变量的声明</h1><ul>
<li>变量声明可以用</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span>(</span><br><span class="line">	str <span class="type">string</span></span><br><span class="line">	a   <span class="type">int</span></span><br><span class="line">	wheater <span class="type">bool</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>变量如果声明了不使用会报错</li>
<li>go fmt filename 这种方式可以使文件格式化</li>
<li>类型变量和短变量声明:</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="string">&quot;this is rabbit&quot;</span></span><br><span class="line">s2 := <span class="string">&quot;this is rabbit too&quot;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>匿名变量”_” ， 可以忽略一些值，不占用空间也不分配内存，接收值之后就直接扔掉了。</li>
<li>:&#x3D; 等赋值不能在函数外赋值</li>
<li>同一个作用域不能重复声明同一个变量</li>
</ul>
<h1 id="关于常量"><a href="#关于常量" class="headerlink" title="关于常量"></a>关于常量</h1><ul>
<li><code>const pi = 3.14159</code>常量的声明</li>
<li>批量声明:</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">	statusOK = <span class="number">200</span></span><br><span class="line">	notfound = <span class="number">404</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">	n1 = <span class="number">100</span></span><br><span class="line">	n2</span><br><span class="line">	n3</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>如果没有写值的话默认和上面是一样的。</p>
<ul>
<li>iota是go语言的常量计数器，只能在常量表达式中使用。</li>
</ul>
<p>多一个常量，iota++ , 默认值为0, 每出现一次const, iota就重置为0，每多<code>一行</code>常量声明，iota在这一行后就会+1。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>&#123;</span><br><span class="line">	a1 = <span class="literal">iota</span></span><br><span class="line">    _</span><br><span class="line">	a2</span><br><span class="line">	a3</span><br><span class="line">    a4 = <span class="number">100</span></span><br><span class="line">    a5</span><br><span class="line">&#125;<span class="comment">// a1 = 0 , 由于后面没有标，默认也是iota嗷</span></span><br></pre></td></tr></table></figure>

<ul>
<li>定义数量级:</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span>(</span><br><span class="line">	_ = <span class="literal">iota</span></span><br><span class="line">	KB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span>*<span class="literal">iota</span>)</span><br><span class="line">	MB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span>*<span class="literal">iota</span>)</span><br><span class="line">	GB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span>*<span class="literal">iota</span>)</span><br><span class="line">    TB = <span class="number">1</span> &lt;&lt; (<span class="number">10</span>*<span class="literal">iota</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>



<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><ul>
<li><p>int8 , int16 , int32 ,int 64</p>
</li>
<li><p>uint8 , uint16…</p>
</li>
<li><p>uint类型会根据操作系统自己决定</p>
</li>
<li><p>int也是这样</p>
</li>
<li><p>uintptr 存放一个指针嗷！</p>
</li>
<li><p>float32 , float64</p>
</li>
<li><p>bool - true , false</p>
</li>
<li><p>二进制数在go语言中无法直接定义，只能转换</p>
</li>
<li><p>八进制前面带有0 ， 十六进制带有0x ，是可以直接声明的。</p>
</li>
</ul>
<p>%d , %o , %x这三个都是常用的十进制，八进制和十六进制,</p>
<p>%b 是二进制。</p>
<p>%#v 会自动帮你的类型加一个双引号。</p>
<ul>
<li><p>查看变量类型: <code>%T</code></p>
</li>
<li><p>强制类型转换: <code>a := int8(9)</code></p>
</li>
<li><p>%v 打印输出的是变量的值，不用管type , 很有用哦。</p>
</li>
<li><p>浮点数: float32 , float64</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">math.Mathfloat32</span><br><span class="line">math.Mathfloat64</span><br></pre></td></tr></table></figure>

<p>默认也是64</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ul>
<li><p>go语言中的字符串只能用<code>&quot;&quot;</code>来包裹</p>
</li>
<li><p>go语言中的<code>&#39;&#39;</code>用来包裹字符</p>
</li>
<li><p>一个中文一般占三个字节</p>
</li>
<li><p>转义符用法一样的</p>
</li>
<li><p>多行字符串：</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s2 : = <span class="string">`</span></span><br><span class="line"><span class="string">	a</span></span><br><span class="line"><span class="string">	b</span></span><br><span class="line"><span class="string">	c</span></span><br><span class="line"><span class="string">`</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>反引号``中的东西原样子输出，是不会变的。</p>
</li>
<li><p>字符串的拼接: 用加号</p>
</li>
<li><p><code>Printf</code>和<code>Sprintf</code>第一个直接在终端答应输出，第二个是以字符串的形式返回。</p>
</li>
<li><p>strings包里有好多的像是Split和Contains和HasPrefix , Index , lastIndex , Join等函数方法用来调用。</p>
</li>
<li><p>字符串不能修改的，只能转换成切片然后再进行转换哦。</p>
</li>
<li><p><code>&quot;&quot;</code>和<code>&#39;&#39;</code>对应的类型是不一样的嗷</p>
</li>
<li><p>go 使用了rune 类型来处理Unicode , 所以如果要处理中文等，都转换成rune类型嗷。</p>
</li>
</ul>
<h1 id="if和for等结构"><a href="#if和for等结构" class="headerlink" title="if和for等结构"></a>if和for等结构</h1><ul>
<li>非常特别：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> a := <span class="number">19</span>; age &gt; <span class="number">18</span>&#123;</span><br><span class="line">	body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>go语言中只有for循环:</p>
<ul>
<li><pre><code class="go">for i := 0; i&lt;10 ; i++&#123;
    body
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```go</span><br><span class="line">  i := 0</span><br><span class="line">  for ;i&lt;10;i++&#123;</span><br><span class="line">  	body</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="go">i := 0
for i&lt;10&#123;
    body
    i++
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```go</span><br><span class="line">  for&#123;</span><br><span class="line">      body</span><br><span class="line">      if(condition)&#123;</span><br><span class="line">          break</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>range好重要！！！</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s := <span class="string">&quot;hello沙河&quot;</span></span><br><span class="line"><span class="keyword">for</span> i,v := <span class="keyword">range</span> s&#123;</span><br><span class="line">	body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>i获得的是索引，v获得的是value</p>
</li>
</ul>
<h1 id="switch和goto"><a href="#switch和goto" class="headerlink" title="switch和goto"></a>switch和goto</h1><ul>
<li><pre><code class="go">switch n:=1 ; n&#123;
    body
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```go</span><br><span class="line">  switch n&#123;</span><br><span class="line">      case n&lt;26:</span><br><span class="line">      	body...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>fallthrough可以像c语言一样下穿，就是为了满足c语言。（最好不要用嗷！）</p>
</li>
<li><p>goto可以跳到某些代码块儿上，也不常用了。</p>
</li>
<li><p>&#96;&#96;&#96;go<br>xx:<br>fmt.Println(“asjdkfs”)<br>goto xx &#x2F;&#x2F; 这样就完成了跳转</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">- 同样 break 和 continue 也可以接上goto语句</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 运算符</span><br><span class="line"></span><br><span class="line">- `a++`里面是单独的语句，不能放在等号的右边赋值</span><br><span class="line">- 位运算:</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">&amp; 按位与</span><br><span class="line">| 按位或</span><br><span class="line">&lt;&lt; 左移n位</span><br><span class="line">&gt;&gt; 右移n位</span><br><span class="line">^ 按位异或</span><br></pre></td></tr></table></figure></li>
</ul>
<p>默认是二进制进行计算的</p>
<ul>
<li>要注意范围哦，像是int8你如果左移了10位就可能出问题，但是16位就不一定会嗷。</li>
<li>同样的也可以进行赋值的:</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+= -=  =  *=  /=  %=  &lt;&lt;=<span class="number">2</span> &gt;&gt;=<span class="number">2</span>  &amp;=<span class="number">2</span> |=<span class="number">2</span>  ^=<span class="number">2</span></span><br></pre></td></tr></table></figure>





<h1 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型:"></a>复合数据类型:</h1><h2 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h2><ul>
<li>长度和类型</li>
<li>就类似于其他语言中的列表</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name [num]<span class="keyword">type</span></span><br></pre></td></tr></table></figure>

<ul>
<li>对用的type就是[3]int</li>
<li>初始化：</li>
</ul>
<p>默认元素都是零值</p>
<ol>
<li><pre><code class="go">a1 = [3]int&#123;0,1,2&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```go</span><br><span class="line">   a2 := [...]int&#123;1,2,34,545,456...&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>&#96;&#96;&#96;go<br>a3 :&#x3D; [5]int{1,2}   &#x2F;&#x2F;自动补零</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">4. ```go</span><br><span class="line">   a3 := [5]int&#123;0:5,2:8&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>数组的传递:</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x := [<span class="number">3</span>]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">y := x</span><br><span class="line"><span class="comment">//这个时候得到的y是x的一个副本嗷呜！！！</span></span><br></pre></td></tr></table></figure>



<ul>
<li>数组的遍历：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="built_in">len</span>(array);i++&#123;</span><br><span class="line">	body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i,v := <span class="keyword">range</span> ArrayName&#123;</span><br><span class="line">	body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>多维数组:</p>
<ul>
<li><pre><code class="go">var all [3][2]int
all = [3][2]int&#123;
    [2]int&#123;1,2&#125;,
    [2]int&#123;3,4&#125;,
    [2]int&#123;5,6&#125;
&#125; //和numpy差不多嗷呜
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 多维数组的遍历:</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">for _, v1 := range all&#123;</span><br><span class="line">	fmt.Println(v1)</span><br><span class="line">	for _,v2 := range v1&#123;</span><br><span class="line">		fmt.Println(v2)</span><br><span class="line">	&#125;</span><br><span class="line">&#125; //两层遍历，这里的v1实际上是内层数组</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>多维数组也可以这样定义</p>
</li>
</ul>
<p><code>var a1 [...][2]int</code> , 最外层才可以… , 内层是不可以加的哦。</p>
</li>
<li><p>在go语言中，对于数组的赋值，实质上是值应用，相当于复制了一个数组给我们要引用的对象。</p>
</li>
</ul>
<h2 id="切片："><a href="#切片：" class="headerlink" title="切片："></a>切片：</h2><h3 id="切片基础操作："><a href="#切片基础操作：" class="headerlink" title="切片基础操作："></a>切片基础操作：</h3><ul>
<li>可变长度的，并且是引用类型</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">int</span>   <span class="comment">// 切片不存在为nil</span></span><br><span class="line">s1 := []<span class="type">int</span>()   <span class="comment">// 切片存在且len和cap都为0</span></span><br><span class="line">s2 := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">0</span>)   <span class="comment">//和上面一样没啥区别</span></span><br></pre></td></tr></table></figure>

<p>由于是可变的，声明切片的时候可以这样声明</p>
<ul>
<li>切片和数组最大的区别就是切片声明的时候是不带长度的，因为切片长度是可变的，初始化的时候就得以体现。</li>
<li>nil类似于其他语言中的空</li>
<li>切片没有初始化时默认为空，即没有分配内存空间</li>
<li>len长度，cap为容量</li>
<li>初始化:</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> </span><br><span class="line"><span class="keyword">var</span> s []<span class="type">int</span></span><br><span class="line">s = []<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="comment">// 本质也是造一个数组，返回切片给你</span></span><br><span class="line"><span class="number">2.</span></span><br><span class="line">s1 = [...]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line">s = s1[<span class="number">0</span>:<span class="number">4</span>] <span class="comment">//和py中一样，左开右闭。</span></span><br><span class="line"><span class="number">3.</span></span><br><span class="line">s2 := s3[<span class="number">3</span>:]</span><br><span class="line"><span class="comment">// 切片的切片</span></span><br></pre></td></tr></table></figure>

<ul>
<li>切片容量是从切片第一个元素对应底层数组到末尾的元素的个数</li>
<li>切片是引用，指向一个指定的数组，切片和数组都是相互影响的。</li>
<li>make函数构造切片:</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1 := <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">5</span>,<span class="number">10</span>) <span class="comment">//默认切片元素都为0，如果不加第二个参数，默认cap和len相同，本质也是底层数组的分配。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>切片的内存: 一块儿连续的内存</li>
<li>一个nil值的切片是没有底层数组的，切片的长度和容量都是0</li>
<li>切片的遍历:</li>
</ul>
<ol>
<li>&#96;&#96;&#96;go<br>&#x2F;&#x2F;和c语言里面一样<br>for i:&#x3D;0;i&lt;len(s);i++{<br>body<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2. ```go</span><br><span class="line">   for i,v := range s&#123;</span><br><span class="line">   	fmt.Println(l,v)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="切片高级操作："><a href="#切片高级操作：" class="headerlink" title="切片高级操作："></a>切片高级操作：</h3><ul>
<li><p>切片的扩容：</p>
<ul>
<li>相关操作:</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s := []<span class="type">string</span>(<span class="string">&quot;北京&quot;</span>,<span class="string">&quot;上海&quot;</span>)</span><br><span class="line">s[<span class="number">2</span>] = <span class="string">&quot;上海&quot;</span> <span class="comment">// 这个是错误的,index out of range</span></span><br><span class="line">s := s.<span class="built_in">append</span>(s,<span class="string">&quot;广州&quot;</span>,<span class="string">&quot;成都&quot;</span>)</span><br><span class="line"><span class="comment">// 这个时候底层数组的长度直接翻倍，找了一个新的地址直接分配新的内存，原来的底层数组就gg了，重新用了一块儿新的，s如果不接收新的数组的话，就废了，所以最好就是用原来的变量接收新的值。拓展容量有自己的方法的,感兴趣可以百度嗷！</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ul>
<p>s1 :&#x3D; []string(“武汉”,”成都”)<br>  s &#x3D; s.append(s.s1…)&#x2F;&#x2F; 这样也可以哦, …表示拆开，把每个单独的元素拿出来，这样也可以达到拓展的目的</p>
<ul>
<li><p>调用append必须要用原来的变量接收返回值。</p>
</li>
<li><p>切片的复制:</p>
<ul>
<li>copy(destination , source)</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a3 []<span class="type">int</span></span><br><span class="line">a1 := []<span class="type">int</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line"><span class="built_in">copy</span>(a3,a1)</span><br></pre></td></tr></table></figure>
</li>
<li><p>元素的删除:</p>
<ul>
<li>可以通过切片来实现，没有专门的实现方法。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a1 = <span class="built_in">append</span>(a[:<span class="number">1</span>].a1[<span class="number">2</span>:]...)</span><br></pre></td></tr></table></figure>

<ul>
<li>注意传递切片的时候要拆开。</li>
<li>一般不是直接操作数组，因为数组长度固定不可变，所以一般都是操作切片，常用的操作方法有:</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a1 = s[:]</span><br></pre></td></tr></table></figure>

<p>然后再对a1进行操作。</p>
<ul>
<li>经典例子:</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x1 = [...]<span class="type">int</span>&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>&#125;</span><br><span class="line">s1 = x1[:]</span><br><span class="line">s1 = s1.<span class="built_in">append</span>(s1[:<span class="number">1</span>],s1[<span class="number">2</span>:]...)</span><br><span class="line"><span class="comment">//这个时候x1就变成了(1,5,5)</span></span><br></pre></td></tr></table></figure>

<p>由于底层是切片，这样s1变成了[1,5]，按照顺序保存在数组的位置上，但数组的元素个数是不变的，相当于切片有改变了前两个元素。</p>
<ul>
<li>面试题:</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">make</span>([]<span class="type">int</span>,<span class="number">5</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++&#123;</span><br><span class="line">    a = a.<span class="built_in">append</span>(a,i)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果为[0,0,0,0,0,0,1,2,3,4,5,6,7,8,9]</span></span><br></pre></td></tr></table></figure>

<p>一开始初始化make时就已经存在a为[0,0,0,0,0]了，再往后append就是这个结果。</p>
</li>
</ul>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul>
<li>比较简单（不存在指针操作）</li>
<li><code>&amp;</code>和<code>*</code>就这两个操作</li>
<li>bugs:<ul>
<li><code>var a *int</code>这个声明了一个指针，但没有初始化，默认指向nil , <code>*a = 100</code>这样赋值是不可以的。因为这个时候，a指针指向一个空地址，连地址指向哪里都不知道无法赋值。</li>
</ul>
</li>
<li>用new函数分配内存地址:</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">new</span>(<span class="type">int</span>)</span><br><span class="line">*a = <span class="number">100</span></span><br></pre></td></tr></table></figure>

<p>默认给a申请了指针的空间</p>
<ul>
<li><p>new一般用于给基本数据类型申请内存，返回的是对应类型的指针。</p>
</li>
<li><p>make也是用来分配地址的：</p>
<ul>
<li>用于为slice , map , chan申请内存 , make返回的是对应类型本身。</li>
</ul>
</li>
<li><p>go语言中指针有个用法，就是用指针指示成员变量的时候是可以类似于成员对象一样调用的。</p>
</li>
</ul>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><ul>
<li>映射关系，map是应用类型</li>
<li>map[key]value</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> m1 <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span> <span class="comment">// 这样不行，默认map是空，因为没有为map分配内存</span></span><br><span class="line">m1 = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">string</span>]<span class="type">int</span>,<span class="number">10</span>) <span class="comment">// 初始化要估算好内存，最好一次到位，避免动态扩容。</span></span><br><span class="line">m1[<span class="string">&quot;rabbit&quot;</span>] = <span class="number">18</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>v, ok = m1[&quot;rabbit&quot;]</code>因为自动返回两个值嗷</li>
<li>map的遍历:</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> k, v := <span class="keyword">range</span> m1&#123;</span><br><span class="line">	body</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// k是key , v是value</span></span><br><span class="line"><span class="comment">// 注意可以用_来取得我们需要的值即可</span></span><br></pre></td></tr></table></figure>

<ul>
<li>删除:</li>
</ul>
<p><code>delete(mapname,keyname)</code></p>
<ul>
<li>其他一些用法：</li>
</ul>
<p>比如按照指定顺序遍历map:</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> keys = <span class="built_in">make</span>([]<span class="type">string</span>,<span class="number">0</span>,<span class="number">200</span>)</span><br><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> scoreMap&#123;</span><br><span class="line">	keys = <span class="built_in">append</span>(keys,key)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort.Strings(keys)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, key := <span class="keyword">range</span> keys&#123;</span><br><span class="line">	fmt.Println(key,scoreMap[key])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用切片对于map元素进行处理。(利用循环单独提取key存在切片里面，然后对于切片进行操作嗷呜！)。</p>
<ul>
<li><p>map可以和切片等其他的数据类型相组合：</p>
<ul>
<li>注意初始化!!!</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">make</span>([]<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>,<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">s1[<span class="number">0</span>] = <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="type">int</span>]<span class="type">string</span>,<span class="number">1</span>)</span><br><span class="line"><span class="comment">//注意多重结构多重初始化哦，和java中一样样的，基本不用，但是复杂结构要哦。</span></span><br></pre></td></tr></table></figure>

<ul>
<li>&#96;&#96;&#96;go<br>var m1 &#x3D; make(map[string][]int,10)<br>m1[“homework”] &#x3D; []int{1,2,3}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 切片和map在一起一定要记得初始化嗷。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 函数（非常非常重要嗷呜！！！）</span><br><span class="line"></span><br><span class="line">- ```go</span><br><span class="line">  func sum(x, y int) (ret int)&#123;</span><br><span class="line">  	body</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><pre><code class="go">func sum() int&#123;
    body
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 两个对比</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">func sum(x, y int) (ret int)&#123;</span><br><span class="line">	ret = x+y</span><br><span class="line">	return</span><br><span class="line">&#125;</span><br><span class="line">//使用命名返回值可以省略</span><br><span class="line">func sum(x, y int) int&#123;</span><br><span class="line">	ret := x+y</span><br><span class="line">	return ret</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>可变长参数:</p>
<ul>
<li><code>fun f7(x string, y ...int)&#123;&#125;</code></li>
<li>这里的y…处可以传入零个或者多个参数，非常有用</li>
<li>y这个时候为一个slice</li>
<li>可变长参数必须放在参数的最后</li>
</ul>
</li>
<li><p>go语言中没有默认参数这个概念。</p>
</li>
<li><p>go语言中的函数传递的都是值哦，都是传递的副本，和java中差不多嗷</p>
</li>
<li><p>go语言中支持多个返回值嗷呜！</p>
</li>
<li><p>返回值要不都不命名要不都命名。</p>
</li>
</ul>
<h3 id="重点难点-defer语句"><a href="#重点难点-defer语句" class="headerlink" title="重点难点: defer语句"></a>重点难点: defer语句</h3><ul>
<li>多个defer的时候其实上是根据栈来执行的，先进后出的原则嗷呜！</li>
<li>多用于函数结束之前释放资源的时候使用，还用于记录时间啊，文件关闭啊等等。</li>
<li>go语言中的return不是原子操作，在函数中先返回值赋值，然后执行defer语句，最后才真正结束函数。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> (x <span class="type">int</span>)&#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		x++</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//最终的答案是6哦</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> (y <span class="type">int</span>)&#123;</span><br><span class="line">    x := <span class="number">5</span></span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		x++</span><br><span class="line">	&#125;()</span><br><span class="line">	<span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//答案是5</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">()</span></span> (x <span class="type">int</span>)&#123;</span><br><span class="line">	<span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		x++</span><br><span class="line">	&#125;(x)</span><br><span class="line">	<span class="keyword">return</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//答案是5</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>defer calc(&quot;1&quot;,a,b,calc(&quot;10&quot;,a,b))</code></li>
</ul>
<p>这里先调用内层函数算出内部确切的值，例如内部的a和clac都赋予了此刻值，然后才会把外层函数defer延迟调用，就是说defer作用只有一层，其余的依旧会在本步实现。</p>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><ul>
<li>和其他的函数差不多</li>
<li>查找变量从内向外查找</li>
</ul>
<h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><ul>
<li>函数类型的区分，按照参数和返回值来区分的‘</li>
<li>函数接收函数:</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(x []<span class="type">int</span>)</span></span>&#123;</span><br><span class="line">	body</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(x <span class="keyword">func</span>(<span class="type">int</span>,<span class="type">int</span>)</span></span><span class="type">int</span>)&#123;</span><br><span class="line">	<span class="comment">//直接调用函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数还可以作为返回值:</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f</span><span class="params">(x <span class="keyword">func</span>()</span></span><span class="type">int</span>) <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>,<span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">	body</span><br><span class="line">&#125; <span class="comment">// 满足参数要求的都可以返回。</span></span><br></pre></td></tr></table></figure>

<h3 id="匿名函数与立即执行函数"><a href="#匿名函数与立即执行函数" class="headerlink" title="匿名函数与立即执行函数"></a>匿名函数与立即执行函数</h3><ul>
<li>定义一个匿名函数</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f1 = <span class="function"><span class="keyword">func</span><span class="params">(x,y <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">	body</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>函数内部不能再定义函数（但是匿名函数可以），用于这种情况。通常和java中一样用于只使用一次的函数或者使用次数较少的函数。</li>
<li>立即执行函数：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fun main()&#123;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">		fmt.Println(<span class="string">&quot;hello this is here&quot;</span>)</span><br><span class="line">	&#125;()</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x2F;&#x2F;这里的fun函数声明之后立刻使用，只使用一次，之后就找不到了。</p>
<ul>
<li>函数内部定义函数一般用匿名函数，只使用一次的直接用立即执行函数</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul>
<li>包装函数，使得函数之间的接口相匹配。</li>
<li>函数名加上了()代表函数的执行</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">adder</span><span class="params">(x <span class="type">int</span>)</span></span> <span class="function"><span class="keyword">func</span><span class="params">(<span class="type">int</span>)</span></span> <span class="type">int</span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fun(y <span class="type">int</span>) <span class="type">int</span>&#123;</span><br><span class="line">		x += y</span><br><span class="line">		<span class="keyword">return</span> x</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	ret := adder(<span class="number">100</span>)</span><br><span class="line">	ret2 = ret(<span class="number">200</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>人为构造函数接口，函数内部定义的函数</li>
<li>闭包是： <ul>
<li>一个函数</li>
<li>函数包含其外部作用域的一个函数，把x包含进去了，再接下来的过程中再继续调用。</li>
<li>闭包 &#x3D; 函数 + 外部变量的引用</li>
</ul>
</li>
<li>原理：<ul>
<li>函数可以作为返回值</li>
<li>查找变量的顺序</li>
</ul>
</li>
<li>外部传入的变量被包起来了，在调用内层函数的时候实现再次访问。</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">fun f1(f <span class="function"><span class="keyword">func</span><span class="params">()</span></span>)&#123;</span><br><span class="line">	f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f2</span><span class="params">(x,y <span class="type">int</span>)</span></span>&#123;</span><br><span class="line">	fmt.Println x+y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//想把f2传入f1中但模式不匹配，这时候要把f2包起来，把参数的接收分开来！f1(f2)</span></span><br><span class="line"><span class="comment">//构建闭包函数f3，目标是返回一个能传入f1的函数，但是又要保留f2的参数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">f3</span><span class="params">(f2(<span class="type">int</span>,<span class="type">int</span>)</span></span>,x,y <span class="type">int</span>) <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    temp := <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        f2(x,y)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 传入目的f2，进行处理后得到能被f1接收的函数</span></span><br><span class="line"><span class="comment">// f3老子帮你f2要处理的数据处理好，然后帮你构造好，以你需要的形式给你吐出来！！！</span></span><br></pre></td></tr></table></figure>





<h1 id="内置函数简介"><a href="#内置函数简介" class="headerlink" title="内置函数简介"></a>内置函数简介</h1><h2 id="panic和defer和recover-错误处理"><a href="#panic和defer和recover-错误处理" class="headerlink" title="panic和defer和recover(错误处理)"></a>panic和defer和recover(错误处理)</h2><ul>
<li>大致有<code>close len new make append panic recover</code></li>
<li>go语言中没有异常机制</li>
<li>panic直接让程序崩溃退出</li>
<li>防止程序占用资源可以用defer来解决panic , recover则可以尝试恢复错误</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">defer</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">	err := <span class="built_in">recover</span>()</span><br><span class="line">	fmt.Println(err)</span><br><span class="line">	fmt.Println(<span class="string">&quot;释放网络连接&quot;</span>)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;出现了严重的错误。&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>recover会尝试着修复panic，跳过panic的部分然后往后走。recover尽量少用嗷呜！！！该panic还是要panic</p>
<ul>
<li>recover()一定要搭配defer使用，defer一定要在可以能会panic的语句之前调用</li>
</ul>
<h2 id="fmt标准库简介"><a href="#fmt标准库简介" class="headerlink" title="fmt标准库简介"></a>fmt标准库简介</h2><ul>
<li><p>fmt主要用于打印输出和获取输入的时候使用的嗷！</p>
</li>
<li><p><code>Print Printf Println</code> , <code>printf</code>用于格式化输出字符串</p>
</li>
<li><p>注意一下 <code>%T %v %#v %% %+v</code>等等（这几个是通用的，不管什么类型都可以用）</p>
</li>
<li><p><code>%t %p</code>等类似于布尔值，指针等类型</p>
</li>
<li><p><code>fmt.Scan fmt.Scanf fmt.Scanln</code></p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line">fmt.Scan(&amp;s)</span><br><span class="line"></span><br><span class="line">fmt.Scanf(<span class="string">&quot;%s %d %s\n&quot;</span>,&amp;a,&amp;b,&amp;c)</span><br><span class="line"><span class="comment">// 扫描完换行</span></span><br><span class="line"></span><br><span class="line">fmt.Scanln(&amp;a,&amp;b,&amp;c)</span><br><span class="line"><span class="comment">//注意这里不能接收格式化的值嗷</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Sprint 拼接</li>
</ul>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><ul>
<li>老递归了，乖娃子好家伙你差点整死你爹。</li>
<li>和别的语言差不多，找到规律和递归出口，节能写出来，没啥区别orz</li>
</ul>
<h1 id="自定义类型and类型别名"><a href="#自定义类型and类型别名" class="headerlink" title="自定义类型and类型别名"></a>自定义类型and类型别名</h1><ul>
<li>type是用来定义类型的</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> myInt <span class="type">int</span>     <span class="comment">//自定义类型</span></span><br><span class="line"><span class="keyword">type</span> yourInt = <span class="type">int</span> <span class="comment">//类型别名</span></span><br></pre></td></tr></table></figure>

<ul>
<li>别名会使得默写情况下表达更加清晰（例如<code>rume</code>和<code>int32</code>）</li>
</ul>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><ul>
<li>定义一个结构体的方法：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> 类型名 <span class="keyword">struct</span>&#123;</span><br><span class="line">	body</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> varname 类型名</span><br></pre></td></tr></table></figure>

<ul>
<li><p>打印输出的话是按顺序输出每个字段的值</p>
</li>
<li><p>匿名结构体：</p>
<ul>
<li>&#96;&#96;&#96;go<br>var s &#x3D; struct{<br>name string<br>age int<br>}<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - 临时使用的时候用的到。</span><br><span class="line"></span><br><span class="line">  - 结构体要用花括号。</span><br><span class="line"></span><br><span class="line">  - 这样也可以临时声明一个结构体并且返回给一个变量。</span><br><span class="line"></span><br><span class="line">- 和c语言一样，函数是传值操作，结构体同样，如果要改变结构体中的变量的话，一样要传递结构体指针。</span><br><span class="line"></span><br><span class="line">- 取得结构体的指针：</span><br><span class="line"></span><br><span class="line">  - `var p2 = new(person)`(new直接返回对应类型的指针)</span><br><span class="line">  - `%p`能够打印输出对应的指针的地址</span><br><span class="line"></span><br><span class="line">  ```go</span><br><span class="line">  fmt.Println(&quot;%p\n&quot;,&amp;a)</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>结构体初始化：</p>
<ul>
<li>直接声明结构体然后依次赋值</li>
</ul>
 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = person(</span><br><span class="line">    name: <span class="string">&quot;rabbit&quot;</span></span><br><span class="line">    age: <span class="number">19</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<ul>
<li>使用值列表（按照声明的顺序来初始化）进行初始化:</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p := person(</span><br><span class="line">	<span class="string">&quot;rabbit&quot;</span>，</span><br><span class="line">    <span class="number">19</span>，</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">- 结构体内的内存是连续的</span><br><span class="line"></span><br><span class="line">- 可以设置一个构造函数来进行初始化也可以鸭</span><br><span class="line"></span><br><span class="line">​```go</span><br><span class="line">func newPerson(name string , age int) *Person&#123;</span><br><span class="line">	return &amp;person&#123;</span><br><span class="line">		name: name</span><br><span class="line">		age: age</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>注意哦，这里返回的是原构造函数中的一个拷贝之后的版本，当占用内存多的时候，可以考虑使用结构体指针。</li>
</ul>
<h2 id="结构体匿名字段"><a href="#结构体匿名字段" class="headerlink" title="结构体匿名字段"></a>结构体匿名字段</h2><ul>
<li><pre><code class="go">type person struct&#123;
    string
    int
&#125;//相同类型只能写一个
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 适用于字段少，简单且不常用的情况</span><br><span class="line"></span><br><span class="line">- 访问特定元素时，例如访问string，这个时候把string作为成员的名字，可以通过.名字直接进行访问。</span><br><span class="line"></span><br><span class="line">## 嵌套嗷呜!</span><br><span class="line"></span><br><span class="line">- 禁止套娃？（结构体套用结构体）</span><br><span class="line"></span><br><span class="line">- ```go</span><br><span class="line">  type address struct&#123;</span><br><span class="line">  	province string</span><br><span class="line">      city string</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  type person struct&#123;</span><br><span class="line">      name string</span><br><span class="line">      age int</span><br><span class="line">      addr address</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  p1 := person&#123;</span><br><span class="line">      name : &quot;&quot;</span><br><span class="line">      age : </span><br><span class="line">      addr: address&#123;</span><br><span class="line">          province: &quot;&quot;</span><br><span class="line">          city: &quot;&quot;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>匿名嵌套结构体:(感觉很好用的样子嗷呜！！！)</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> person <span class="keyword">struct</span>&#123;</span><br><span class="line">	province <span class="type">string</span></span><br><span class="line">	city <span class="type">string</span></span><br><span class="line">	address</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 := person&#123;</span><br><span class="line">    name : <span class="string">&quot;&quot;</span></span><br><span class="line">    age : </span><br><span class="line">    address: address&#123;</span><br><span class="line">        province: <span class="string">&quot;&quot;</span></span><br><span class="line">        city: <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样之后就能够直接通过<code>p1.city</code>等方式访问内部元素</p>
<p>步过要注意，有可能产生匿名结构体的冲突，比如说几个都有city这个元素，嵌套一个可以，多个的话为了防止冲突最好不用。</p>
</li>
<li><p>构造结构体的函数，可以专门写一个构造函数<code>return struct</code>，然后每次调用这个构造函数就会十分的方便简单。</p>
</li>
</ul>
<h1 id="方法和接收者"><a href="#方法和接收者" class="headerlink" title="方法和接收者"></a>方法和接收者</h1><ul>
<li>有点像类的方法那种感觉啦(方法是作用于特定类型的函数)</li>
<li>声明: <code>func (d dng) wang()</code>，推荐用类型的首字母小写来声明这个类型的一个变量。</li>
<li>go语言中如果标识符首字母是大写的，就表示对外部包可见，类似于java中的public。</li>
<li>注意，如果函数的首字母大写对外可见，那么函数的返回值首字母也要大写，不然类型就不匹配。</li>
<li>对于这种标识符都应该加上注释</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dog 是一个关于狗的结构体</span></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span>&#123;</span><br><span class="line">	name <span class="type">string</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>接收者只能有一个嗷呜</p>
</li>
<li><p>同时还是要注意函数传值传址嗷呜，就算是方法传址也才能改变对象的值。</p>
</li>
<li><p>使用指针传递内容的情况：</p>
<ul>
<li>需要修改接收者中的值</li>
<li>接收者是拷贝开销比较大的大对象</li>
<li>一致性，某个方法传入指针，最后其他的都一样传入指针。</li>
</ul>
</li>
<li><p>添加方法只能给自己定义的type添加方法，不能给别的包定义方法。比如说你想给int设置方法，是不可以的，但是你可以自己写一个对象为int，<code>type myInt int</code>这样构造一个然后再定义方法就可以。</p>
</li>
<li><p><code>var x int32 = 10</code>与<code>x := int32(10)</code>与<code>var a = myInt(100)</code>，这个东西是强制类型准换哈，这个不是方法函数。</p>
</li>
<li><pre><code class="go">s1 := map[string]int&#123;
    &quot;liu&quot; : 5,
    &quot;yi&quot; : 10
    &quot;hao&quot; : 23
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 结构体模拟实现继承</span><br><span class="line"></span><br><span class="line">- </span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">func animal struct&#123;</span><br><span class="line">	name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (a animal) move()&#123;</span><br><span class="line">    fmt.Println(&quot;唱跳rap篮球&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type dog struct&#123;</span><br><span class="line">	feet uint8</span><br><span class="line">	animal</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (d dog) wang()&#123;</span><br><span class="line">	fmt.Printf(&quot;%s在叫：汪汪汪~&quot;,d.name)</span><br><span class="line">&#125;</span><br><span class="line">//可以用dog调用animal方法</span><br><span class="line">//可以用dog来调用animal属性</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>dog中拥有了animal就相当于继承了animal</p>
</li>
</ul>
<h1 id="结构体与JSON"><a href="#结构体与JSON" class="headerlink" title="结构体与JSON"></a>结构体与JSON</h1><ul>
<li>把go语言中的结构体转换为json格式，并且把json格式能转回go语言</li>
<li><code>json.Marshal(struct)</code></li>
<li>格式化功能在json包里面做的，要在json包里拿到属性和字段，注意要用大写嗷。或者还有一种做法：</li>
<li>反引号引号起来就可以以自定义的名字访问</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Name <span class="type">string</span> <span class="string">&#x27;json:&quot;name&quot; db:&quot;name&quot;&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>反序列化: <code>json.Unmarshal(type,&amp;target)</code>（这里要是指针哦，得到了一个值然后传入要地址鸭！）</li>
<li>target为一个指针嗷呜！</li>
</ul>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><ul>
<li><p>接口是一种类型，和普通的类型没有差别，可以作为返回值啊等等等等。（面向接口编程的趋势）</p>
</li>
<li><p>应用场景： 给出一个模板，需要的类实现这个模板，规定了变量有哪些方法</p>
</li>
<li><pre><code class="go">type speaker interface&#123;
    speak()  //只要实现了speak方法都是speaker类型
&#125;

func (c cat) speak()&#123;
    fmt.Println(&quot;miao~&quot;)
&#125;

func da(x speaker)&#123;
    x.speak()
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 只要实现了接口中规定的所有类型，那么这个变量就可以当作接口实现的类型的变量。</span><br><span class="line"></span><br><span class="line">- 但你想到有多个对象有同一个方法的时候，就可用接口了，实现了接口就实现了方法。</span><br><span class="line"></span><br><span class="line">- 甚至可以用接口变量来接收实现的接口,可以指向实现的接口。</span><br><span class="line"></span><br><span class="line">- 多个类型可以实现一个接口，一个类型也可以实现多个接口。</span><br><span class="line"></span><br><span class="line">- 接口可以嵌套！</span><br><span class="line"></span><br><span class="line">## 使用值和指针接收者不同嗷</span><br><span class="line"></span><br><span class="line">- 实现值接收者，结构体和结构体指针的变量都能存。</span><br><span class="line">- 实现指针接收者，只能拿存结构体类型的变量。</span><br><span class="line">- 用指针接收者往往更加常用嗷！</span><br><span class="line"></span><br><span class="line">## 空接口</span><br><span class="line"></span><br><span class="line">- `type xx interface&#123;&#125;`</span><br><span class="line"></span><br><span class="line">- 接口中啥都没有，意味着所有类型都实现了这个接口，意味着这个接口能接收所有的对象。（有点像Object?）</span><br><span class="line"></span><br><span class="line">- 空接口没有必要起名</span><br><span class="line"></span><br><span class="line">- ```go</span><br><span class="line">  m1 := map[string]interface&#123;&#125;</span><br><span class="line">  m1 = make(map[string]interface&#123;&#125;,10)</span><br><span class="line">  m1[&quot;hobby&quot;] = [...]string&#123;&quot;a&quot;,&quot;b&quot;&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>相当于多种类型的集合！！！传入啥类型都可以！！！</p>
</li>
<li><p>类型断言： </p>
<ul>
<li><p>&#96;&#96;&#96;go<br>a.(type)</p>
<p>func assign(a interface{}){<br>switch v :&#x3D; a.(type){<br>    case string:<br>        body1<br>    case int:<br>        body2<br>    case bool:<br>        body3<br>    default:<br>        body4<br>}<br>}&#x2F;&#x2F; switch a.(type){}也可以</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  - int64与int是两个完全不同的类型</span><br><span class="line"></span><br><span class="line"># package</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 组织go语言的一个单位。</span><br><span class="line"></span><br><span class="line">- 只有main包才能组织成一个文件。</span><br><span class="line">- 只有大写的元素和函数才能被跨包访问，小写表示私有。</span><br><span class="line">- 导入的包名应该紧接在package后面。</span><br><span class="line">- 禁止套娃，不能相互嵌套。</span><br><span class="line">- `import 别名 &quot;包的路径&quot;`。</span><br><span class="line">- 匿名导入包 `import _ &quot;路径&quot;`。</span><br><span class="line">- 导入会自动触发init()函数，当import恶的时候会自动调用。</span><br><span class="line">- init在导入的全局声明和main之间执行。</span><br><span class="line">- 从外往里调用import本质上是从里往外调用`init()`方法。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 文件操作(日志库作业)</span><br><span class="line"></span><br><span class="line">- 接口：不同的模式对应的文件操作不一样，可以输出到终端和文件中</span><br><span class="line"></span><br><span class="line">## 打开/关闭文件</span><br><span class="line"></span><br><span class="line">- ```go</span><br><span class="line">  // 打开文件</span><br><span class="line">  fileObj,ok := os.Open(&quot;./main.go&quot;)// 返回一个文件指针，可以用绝对路径</span><br><span class="line">  if ok != nil&#123;</span><br><span class="line">      fmt.Printf(&quot;Open file failed , err:%v&quot;,err)</span><br><span class="line">      return</span><br><span class="line">  &#125;</span><br><span class="line">  defer fileObj.close()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><h3 id="读文件："><a href="#读文件：" class="headerlink" title="读文件："></a>读文件：</h3><ul>
<li><pre><code class="go">var temp = make([]byte,128) //指定读的长度
// 或者是:var temp = [128]byte
n , error = fileObj.Read(temp[:])// 一次读128个进入切片(n是读入的数，error是出的问题)
if error != nil&#123;
    body
&#125;
fmt.Println(string(temp[:n]))读取文件需要一个切片作为参数，先构造切片，然后读入切片中即可
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- `bufio`读取文件（一样要先`os`打开文件）</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">reader := bufio.NewReader(fileObj)//创建对象</span><br><span class="line">line , err := reader.ReadnString(&#x27;\n&#x27;)</span><br><span class="line">if err == io.EOF&#123;</span><br><span class="line">    return</span><br><span class="line">&#125;</span><br><span class="line">if err != nil&#123;</span><br><span class="line">    body</span><br><span class="line">&#125;</span><br><span class="line">// 这里可以从reader中选择读取方式并返回</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><code>ioutil</code>读取文件：</p>
<ul>
<li><code>ret , err := ioutil.ReadFile(Filename)</code>直接读取整个文件 , 这里readfile后买你的参数直接接的就是文件，不需要像上面一样先打开文件哦。</li>
</ul>
</li>
</ul>
<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件:"></a>写文件:</h3><ul>
<li>&#96;&#96;&#96;go<br>os.OpenFile(name,flag,mode)&#x2F;&#x2F;打开文件的模式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 这里的flag本质上为十六进制数（其实底层为二进制），可以指定多种状态`os.O_APPEND|os.O_CREATE `， 可用二进制中的&quot;|&quot;来表示，本质为二进制的位运算来确定模式。哪一位为1 ， 代表着激活了那种模式。</span><br><span class="line"></span><br><span class="line">- 用`fileObj.write(切片)`和`fileObj.WriteString(sting)`可以写入文件</span><br><span class="line"></span><br><span class="line">- 注意哈，文件开完了之后要关上的！</span><br><span class="line"></span><br><span class="line">- 默认好多模式嗷，对着模式去选择就好啦</span><br><span class="line"></span><br><span class="line">- 和上面读文件一样，这里需要写文件也有三种方式</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">bufio.NewWriter(fileObj)</span><br><span class="line">wr.WriteString(&quot;...&quot;)</span><br><span class="line">wr.Flush() // 将缓存中的内容写入文件中</span><br></pre></td></tr></table></figure></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">err := ioutil.WriteFile(filename,[]byte(str),0666)</span><br></pre></td></tr></table></figure>

<ul>
<li>注意, Scanln只要读到空白符就停止了，如果想读入空白符怎么做？</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s <span class="type">string</span></span><br><span class="line">reader := bufio.NewReader(os.Stdin)</span><br><span class="line">s, _ = reader.ReadString(<span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;...&quot;</span>)</span><br></pre></td></tr></table></figure>

<ul>
<li>bufio.Reader本质上为一个接口类型</li>
</ul>
<h2 id="文件中间插入内容"><a href="#文件中间插入内容" class="headerlink" title="文件中间插入内容"></a>文件中间插入内容</h2><ul>
<li>原理用脑子想一想</li>
<li>可以在库中找到对应的方法嗷呜！</li>
<li>可以用fileObj.seek(跨过的长度，文件的初始位置)，光标移动到要插入内容的位置。</li>
<li><code>os.O_RDWR</code>设置文件可读可写，然后借助seek定位</li>
<li>再向文件中写入内容即可</li>
<li>切片不能用new初始化哦</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s []<span class="type">byte</span></span><br><span class="line">s = []<span class="type">byte</span>&#123;<span class="string">&#x27;c&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>新写的内容会覆盖原有的内容哦</li>
<li>要实现插入内容，一般都要新建中间文件，在中间文件中实现之后再导入到目标文件中。（读入之前的，插入目的数，紧接后面的）</li>
<li>文件关了之后再操作哦，比如可以把中间文件重命名为我要的目的文件即可，把以前的文件直接覆盖哦。</li>
</ul>
<h1 id="time标准库"><a href="#time标准库" class="headerlink" title="time标准库"></a>time标准库</h1><ul>
<li>常用函数: <code>time.Now()/Year()/Date()/Hour()/Minute()/Second()/Day()</code></li>
<li>时间戳: <code>.Unix()或者是.UnixNano()</code>,从1970年一月一日到现在的时间</li>
<li>时间间隔：</li>
</ul>
<p><code>.Second</code>啊等等属性</p>
<ul>
<li>一些操作：<ul>
<li>.Add   e.g.  <code>now.Add(24 * time.Hour)</code></li>
<li>.Sub</li>
<li>.Equal</li>
<li>.Before</li>
<li>.After</li>
</ul>
</li>
<li>定时器</li>
</ul>
<p><code>timer := time.Tick(time.Second)</code> &#x2F;&#x2F; 每隔一秒钟执行一次</p>
<ul>
<li><p>时间格式化：</p>
<ul>
<li><p>2006 1 2 3 4 5   这个是go诞生的时间，用于格式化时间</p>
</li>
<li><pre><code class="go">fmt.Println(now.Format(&quot;2006-01-02&quot;))
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```go</span><br><span class="line">  fmt.Println(now.Format(&quot;2006/01/02 15:04:05&quot;))</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><pre><code class="go">fmt.Println(now.Format(&quot;2006/01/02 15:04:05 PM&quot;))
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  fmt.Println(now.Format(&quot;2006/01/02 15:04:05.000&quot;))</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><code>.Parse</code>函数用于格式化把字符串转换为时间</p>
</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">time := time.Parse(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>,<span class="string">&quot;2020-10-27 19:12:39&quot;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="time库的补充内容"><a href="#time库的补充内容" class="headerlink" title="time库的补充内容"></a>time库的补充内容</h2><ul>
<li>一些标准化的内容:</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Microsecond</span><br><span class="line">Millisecond</span><br><span class="line">Second</span><br><span class="line">Minute</span><br><span class="line">Hour     <span class="comment">//这些都是定义好的标准时间嗷！</span></span><br></pre></td></tr></table></figure>

<ul>
<li>Sub函数的调用:</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nextYear , err := time.Parse(<span class="string">&quot;2006-01-02,2020-01-01&quot;</span>)</span><br><span class="line"></span><br><span class="line">now.Sub(nextYear)</span><br></pre></td></tr></table></figure>

<p>注意，这里减的是一个时间对象嗷，不是减去时间。</p>
<ul>
<li><p>时区指定</p>
</li>
<li><p><code>sleep(d duration)</code>(本质为int64)</p>
</li>
<li><pre><code class="go">n := 100
time.Sleep(time.Duration(n))

time.Sleep(100)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果直接传入参数，直接帮你传。如果用变量则需要手动住那换一样嗷！！！</span><br><span class="line"></span><br><span class="line">- ```go</span><br><span class="line">  n := 5</span><br><span class="line">  time.Sleep(time.Duration(n)*time.Second)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>时区的确定和转换:</p>
</li>
</ul>
<p><code>Parse</code>这个玩意没有时区的概念，就是标准时间，不是东八区的时间，这个时候就要获取时区。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">loc , err := time.LoadLocation(<span class="string">&quot;Asia/Shanghai&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span>&#123;</span><br><span class="line">    fmt.Println(<span class="string">&quot;Load loc failed, err:%v\n&quot;</span>,err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeObj , err := time.ParseInLoaction(<span class="string">&quot;2006-01-02 15:04:05&quot;</span>,<span class="string">&quot;2019-08-04 14:41:50&quot;</span>,loc)</span><br><span class="line"></span><br><span class="line">fmt.Println(time.Obj)</span><br></pre></td></tr></table></figure>

<p>只有在时区相同的情况下做加减计算才有意义啊！</p>
<h1 id="runtime-Caller"><a href="#runtime-Caller" class="headerlink" title="runtime.Caller"></a><code>runtime.Caller</code></h1><ul>
<li><p>&#96;&#96;&#96;go<br>pc , file , line , ok :&#x3D; runtime.Caller(0)</p>
<p>if !ok{<br>body<br>}</p>
<p>&#x2F;&#x2F; 这里的0表示调用层数，0表示调用函数的第一层，1就表示调用函数的第二层（由内往外找层数）。<br>&#x2F;&#x2F; file表示调用的文件名 , line表示调用的函数所在的行，ok表示时候调用成功</p>
</li>
</ul>
<p>funcname :&#x3D; runtime.FuncForPC(pc).Name()<br>  &#x2F;&#x2F;拿到对应层的函数名<br>  path.Base(file)<br>  &#x2F;&#x2F;拿到对应的文件名<br>  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  </span><br><span class="line">- 这就是一个库能够拿到调用它的函数对应的行，还有函数名等等，比如在日志库中有相应的应用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 反射</span><br><span class="line"></span><br><span class="line">- 用的少但是原理要知道</span><br><span class="line"></span><br><span class="line">- ```go</span><br><span class="line">  func reflectType(x interface&#123;&#125;)&#123;</span><br><span class="line">      v := reflect.TypeOf(x)</span><br><span class="line">      name := v.Name()</span><br><span class="line">      kind := v.Kind()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><pre><code class="go">v := reflect.ValueOf(x)
v.Kind() // 值的类型种类
v.Int() / v.Float()
reflect.Int64 / reflect.Float32
// 这里取了一个v作为value的种类,它可以去和reflect下的值比较，但是调用的时候，只有第三行两种形式，如果需要int64 , 还需要int64(v.Int())这种方式强制类型转换。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 通过反射设置变量的值，一样要用指针</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">func reflectSetValue(x interface&#123;&#125;)&#123;</span><br><span class="line">	v := reflect.ValueOf(x)</span><br><span class="line">    if v.Elem().kind() == reflect.Int64&#123;</span><br><span class="line">		v.Elem().SetInt(200)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 这里的x要是指针</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>还有类似的函数 : <code>isNil() , isValid()</code></p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflect.ValueOf(a).isValid()</span><br></pre></td></tr></table></figure>

<ul>
<li>结构体指针</li>
</ul>
<h1 id="strconv标准库简介"><a href="#strconv标准库简介" class="headerlink" title="strconv标准库简介"></a>strconv标准库简介</h1><ul>
<li>用于类型转换，有的时候不能进行强制类型转换</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret2 := <span class="type">string</span>(<span class="number">97</span>)</span><br></pre></td></tr></table></figure>

<p>这里就是把97转换为对应的char类型，就有问题</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Sprintf(<span class="string">&quot;%d&quot;</span>,<span class="number">97</span>)</span><br></pre></td></tr></table></figure>

<p>这里返回一个字符串嗷，可以获得数字对应的字符串</p>
<ul>
<li><pre><code class="go">fmt.ParseInt(str,10,64)
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">这里表示把str转换为十进制六十四位 , 如果传入的是0的话就变成int</span><br><span class="line"></span><br><span class="line">- `strconv.Atoi()`字符串转换为int类型可以直接用这个</span><br><span class="line">- `strconv.Itoa()`int类型转换为字符串</span><br><span class="line">- `boolValue , _ := strconv.ParseBool(boolstr)`</span><br><span class="line">- `.ParseFloat()`</span><br><span class="line"></span><br><span class="line"># 并发</span><br><span class="line"></span><br><span class="line">## goroutine</span><br><span class="line"></span><br><span class="line">- ```go</span><br><span class="line">  func hello()&#123;</span><br><span class="line">  	fmt.Println(&quot;hello&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  func main()&#123;</span><br><span class="line">      go hello()</span><br><span class="line">      time.Sleep(time.Second)</span><br><span class="line">      fmt.Println(&quot;main&quot;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>传入go的要是一个包装好的函数哦</p>
</li>
<li><p>main函数结束了，它生成的所有线程都会结束</p>
</li>
<li><p>见<code>vscode</code>中的例子有更加深入的理解哦</p>
</li>
</ul>
<h3 id="关于goroutine的一些底层的知识"><a href="#关于goroutine的一些底层的知识" class="headerlink" title="关于goroutine的一些底层的知识"></a>关于goroutine的一些底层的知识</h3><ul>
<li>goroutine和线程:<ul>
<li>goroutine和os线程的栈内存不一样，goroutine内存很小，但是可以扩容。（可扩展的栈）</li>
<li>GMP调度 ， g为goroutine的，存了goroutine信息和与P绑定的信息，这里p管理一组goroutine队列，为队列做调度，保证最大效率的利用goroutine队列。m是go运行时对于操作系统内核线程的虚拟，是一一映射的关系，一个goroutine最终是要放在M上执行的。p和m也一般是一一对应的</li>
<li>goroutine初始栈的大小是2k.</li>
</ul>
</li>
</ul>
<h2 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h2><ul>
<li>goroutine对应的函数执行结束的时候，goroutine就结束了。</li>
<li>main函数结束了，main函数创建的goroutine就都结束了</li>
</ul>
<p>那么怎么样协调时间呢？</p>
<h3 id="如何优雅的等其它线程结束"><a href="#如何优雅的等其它线程结束" class="headerlink" title="如何优雅的等其它线程结束"></a>如何优雅的等其它线程结束</h3><ul>
<li><code>var wg sync.WaitGroup</code></li>
<li>只能有一个这种计数器，不能有多个。只有当计数器为0的时候，main函数才能退出</li>
<li>在每一个线程中: <code>wg.Add(1)</code> ， 当一个线程结束了之后，wg才会减一。<code>wg.Done()</code>，在线程结束的时候添加，推荐在线程执行的函数中第一行用<code>defer wg.Done()</code>。</li>
<li>每一个线程开始时，Add记录一下，结束时Done()删除一下。</li>
<li>函数的最后要用<code>wg.Wait()</code></li>
</ul>
<h3 id="math-x2F-rand"><a href="#math-x2F-rand" class="headerlink" title="math&#x2F;rand"></a>math&#x2F;rand</h3><ul>
<li><pre><code class="go">rand.Seed()
rand.Int()
rand.Intn(n)//生成一个[0，n)之间的整数
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 在go里面编译好了之后，种子就固定了，如果想每次生成的不一样，那么要在函数中设置种子并且传入不同的值，比如时间。（注意这里和c语言不同哦。）</span><br><span class="line"></span><br><span class="line">- 默认生成的都是正数，如果需要负数的话`0-rand.Int()`类似于这样即可</span><br><span class="line"></span><br><span class="line">- .Sleep接受的是duration类型  time.Sleep(time.Millisecond * time.Duration(rand.Intn(300)))这样返回的就是Duration类型，可以这么转换整数为duration.</span><br><span class="line"></span><br><span class="line">## `runtime.GOMAXPROCS`</span><br><span class="line"></span><br><span class="line">- 设置处理的cpu的数量，如果作为日志监控等可以占用的少一点</span><br><span class="line">- `runtime.NumCPU()`返回使用的CPU的个数</span><br><span class="line">- 一个线程对应多个goroutine</span><br><span class="line">- 一个程序可以使用多个操作系统线程</span><br><span class="line">- goroutine和os线程时多对多的关系,  m:n , 把m个goroutine分配个n个操作系统线程去执行</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># Channel(通道)</span><br><span class="line"></span><br><span class="line">### 初始化</span><br><span class="line"></span><br><span class="line">- 共享内存进行数据交换时，可能发生问题，这个时候就应该加锁，要改成通过通信来共享内存。goroutine是go程序并发的执行体，channel就是他们之间的连接。channel是可以让一个goroutine发送到另外一个goroutine的通信机制。</span><br><span class="line">- `var 变量 chan 元素类型`，channel是一种特殊的类型，本质为一个队列，遵循First in first out的规则。</span><br><span class="line">- 通道的初始化   `b = make(chan int)`</span><br><span class="line">- 通道必须初始化才能使用</span><br><span class="line">- `var ch3 chan []int` 声明一个传递int切片的通道</span><br><span class="line">- `make(chan 元素类型，[缓冲大小])` 含有带有缓冲区的通道的初始化 , 缓冲区如果不存在的话，无法向里面传递信息，因为无位置接收。</span><br><span class="line">- 通道里面的类型小一点好，如果大的话，用指针会好哦。</span><br><span class="line"></span><br><span class="line">### 发送与接收</span><br><span class="line"></span><br><span class="line">- `ch &lt;- 10`</span><br><span class="line">- `x := &lt;- ch `</span><br><span class="line">- 可以跨越线程进行值的输入与输出</span><br><span class="line">- 只有`b&lt;-`，如果b没有缓冲区，则无法成功输入，如果`x := &lt;-b`，b中还没有值，则程序会等待b的输入</span><br><span class="line">- 通道的关闭 : `close(channel)` ， 不关也没问题的</span><br><span class="line">- `for i := range ch1&#123;&#125;` 这个也是作用于通道</span><br><span class="line">- 关闭通道后不可以往通道里面再写数据，但是可以从通道里面读数据。往线程里写完数据之后还是最好, close(线程)这样来保证线程的安全。</span><br><span class="line"></span><br><span class="line">### 单向通道</span><br><span class="line"></span><br><span class="line">- 只能读入或者输出，常用于一些函数，限制通道的功能(当通道只能进行某一些操作时)</span><br><span class="line">- `func f1(ch1 &lt;-chan int) || func f2(ch2 chan&lt;- int)`</span><br><span class="line"></span><br><span class="line">### 数据读取</span><br><span class="line"></span><br><span class="line">- ```go</span><br><span class="line">  for&#123;</span><br><span class="line">  	x , ok := &lt;-channel</span><br><span class="line">  	if !ok&#123;</span><br><span class="line">  		break;</span><br><span class="line">  	&#125;</span><br><span class="line">  	else&#123;</span><br><span class="line">  		fmt.Println(x)</span><br><span class="line">  	&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>这里如果channel为空，会等待，直到channel中没有值才会退出</p>
</li>
<li><p>什么时候ok是false , 直到通道close掉，这个才为false,所以要人为去close掉通道，才能退出！</p>
</li>
<li><p>for , range是一样的，会等待通道内的值，只有通道关闭才会退出循环，所以在程序中要记得close嗷！</p>
</li>
</ul>
<h3 id="其它的一些操作"><a href="#其它的一些操作" class="headerlink" title="其它的一些操作"></a>其它的一些操作</h3><ul>
<li><code>var once sync.Once</code>然后<code>once.Do(func()&#123;...&#125;)</code>这样就可以使得某一段函数只执行一次，例如多个容器接收，一次关闭某个特定的通道</li>
<li>关于关闭的通道可以继续读取通道，当读取完元素之后依旧可以继续读取，读取的是对应类型的零值。</li>
<li>通道由两个返回值，一个是真正的返回值，第二个是true或者false即是否读取到了值，就算ok为false，一样可以读取到对应的返回值。</li>
</ul>
<h3 id="通道的状态"><a href="#通道的状态" class="headerlink" title="通道的状态"></a>通道的状态</h3><p>![image-20201105184844101](C:\Users\Alexander Liu\AppData\Roaming\Typora\typora-user-images\image-20201105184844101.png)</p>
<ul>
<li>关闭已经关闭的channel就会panic</li>
<li>如果所有的goroutine都在等一个阻塞的channel这个时候程序会发生死锁。</li>
<li>goroutine的泄露，如果后台在等一个阻塞的channel，主程序能够运行，这个时候可以正常运行，但是后台goroutine占着一块儿内存始终不会释放，这个时候造成了goroutine的泄露。</li>
</ul>
<h3 id="匿名结构体计数通道"><a href="#匿名结构体计数通道" class="headerlink" title="匿名结构体计数通道"></a>匿名结构体计数通道</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">notifyCh  &lt;-  <span class="keyword">struct</span>&#123;&#125;&#123;&#125;</span><br><span class="line"><span class="comment">//不占任何内存，构造出来用于记录数量</span></span><br><span class="line">	</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;<span class="number">5</span>;i++&#123;</span><br><span class="line">        &lt;-notifyCh</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(results)</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<ul>
<li>如果能取到5个值，说明这个通道里面目的数据量都被传满了，这个时候就可以去取真实的值了。这这个线程也会一直等着，直到目标容量被存满之后，才会关闭对应的通道。非常非常有用。</li>
</ul>
<h1 id="select多路复用"><a href="#select多路复用" class="headerlink" title="select多路复用"></a>select多路复用</h1><ul>
<li><pre><code class="go">select&#123;
    case &lt;-ch1:
    
    case data := &lt;-ch2:
    
    case ch3&lt;-data:
    
    default:
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 哪个能成走哪个，若多个能走从中随便选一个嗷。</span><br><span class="line"></span><br><span class="line">- 空的select可以用于阻塞main函数，程序会运行到这里然后一直等哦</span><br><span class="line"></span><br><span class="line"># Channel重大发现嗷</span><br><span class="line"></span><br><span class="line">- 当多个任务无法区分时，可以用多个线程分别执行，思考之间的关系，在主程序中去进行wait和close之类的操作，可以很好的解决通道的问题！！！</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># sync包中的互斥锁</span><br><span class="line"></span><br><span class="line">- 实现了对于公共空间的元素的访问的操作,对于公共资源的操作和访问时，就先加锁。</span><br><span class="line">- `var lock sync.Mutex`and`lock.Lock()`and`lock.Unlock()`</span><br><span class="line"></span><br><span class="line">## 读写互斥锁</span><br><span class="line"></span><br><span class="line">- 用于读的次数远大与写的次数</span><br><span class="line">- 分为读锁和写锁两个锁，读锁的时候可以继续获取，写锁的时候别的锁就要先等一等。</span><br><span class="line">- `sync.RWMutex`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># sync.Once</span><br><span class="line"></span><br><span class="line">- `.Do(func())`只做一次，once.Do()保证了某个函数仅仅执行一次，要求函数苛刻，传入的函数要求没有参数也没有返回值，因此这个时候，可能会使用到函数闭包。</span><br><span class="line"></span><br><span class="line">`f := func()&#123;close(channel)&#125;`</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># sync.Map</span><br><span class="line"></span><br><span class="line">- Go内置的map不是并发安全的</span><br><span class="line">- 这个时候自己可以加锁嘛，go内置了一些开箱即用的map - `sync.Map`，定义了一些Store和Load等方法</span><br><span class="line"></span><br><span class="line">- 开箱即用意味着map不用初始化</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">var m2 = sync.Map&#123;&#125;</span><br><span class="line">var wg sync.Waitgroup</span><br><span class="line"></span><br><span class="line">func main()&#123;</span><br><span class="line">    for i:=0;i&lt;21;i++&#123;</span><br><span class="line">        wg.Add(1)</span><br><span class="line">        go func(n int)&#123;</span><br><span class="line">            key := strconv.Itoa(n)</span><br><span class="line">            m2.Store(key, n)</span><br><span class="line">            value,_ := m2.Load(key)</span><br><span class="line">            wg.Done()</span><br><span class="line">        &#125;(i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>必须使用sync.map内部自带的Store来存值，用Load来取值，用特定的方法来取值。</p>
</li>
</ul>
<h1 id="atomic原子性操作"><a href="#atomic原子性操作" class="headerlink" title="atomic原子性操作"></a>atomic原子性操作</h1><ul>
<li><p>原子性操作自动帮你加锁，去锁。</p>
</li>
<li><pre><code class="go">func main()&#123;
    atomic.AddInt64(&amp;x,1)
&#125;
//内置的加法函数
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 有一系列的相关操作来保证功能的实现。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 网络编程</span><br><span class="line"></span><br><span class="line">## 协议和层</span><br><span class="line"></span><br><span class="line">- 物理层：把电脑连接起来的物理手段，传送0，1信号</span><br><span class="line">- 数据链路层：规定解读电信号的方式，“以太网”协议占据主导，然后将数据分为帧发送。以太网规定了网卡接口有唯一的地址，就可以确定某一个网卡。</span><br><span class="line">- 网络层：网络地址和MAC协议，IPv4和IPv6两个协议，最多发65535个字节</span><br><span class="line">- 传输层：通过MAC地址和IP地址，可以建立通信，还有一个参数叫端口，确定是电脑哪个程序，上述三个确定了唯一一个电脑上的某个程序。TCP和UCP两种，三次握手，四次挥手等等orz , 时效性高用UCP , TCP则保证数据的稳定性</span><br><span class="line">- 应用层：建立在传输层之上，不停的加上不同的协议，最后得到一个物理层的传输数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## socket编程</span><br><span class="line"></span><br><span class="line">- TCP/IP都要用到socket , socket是一个抽象层，处于传输层和应用层之间。</span><br><span class="line">- 一个TCP连接多个客户端，go中的并发性高</span><br><span class="line">- TCP处理流程：</span><br><span class="line">  - 监听端口</span><br><span class="line">  - 接收客户端请求建立来凝结</span><br><span class="line">  - 创建goroutine处理链接</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># os.Args</span><br><span class="line"></span><br><span class="line">- 获取命令行参数</span><br><span class="line">- 可以以os.Args[num]的方式获取某个输入参数</span><br><span class="line"></span><br><span class="line"># Flag</span><br><span class="line"></span><br><span class="line">- 创建一个标志位参数</span><br><span class="line"></span><br><span class="line">`name := flag.String(&quot;name&quot;,&quot;ask&quot;,&quot;b&quot;)`,这个时候的name时一个指针，指向某个分配了位置的内存地址。</span><br><span class="line"></span><br><span class="line">- 可以通过`--help`来体现到底有哪些方法</span><br><span class="line"></span><br><span class="line">- ```go</span><br><span class="line">  name := flag.String(&quot;name&quot;,&quot;ask&quot;,&quot;Enter your name&quot;)</span><br><span class="line">  flag.Parse()</span><br><span class="line">  fmt.Println(*name)</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p><code>age := flag.Int(&quot;age&quot;,18,&quot;请输入真实姓名&quot;)</code></p>
</li>
<li><p>有Int , Sting ,Bool ,Duration等方法，这些方法都用于构造某个标志位，可以返回一个指针，通过特定的指针访问某个用户输入的特定的属性。</p>
</li>
<li><p><code>flag.exe -name=兔子姐姐 -age=10000</code>这样即为用户端输入。</p>
</li>
<li><p><code>var name string</code> , <code>flag.StringVar(&amp;name,&quot;name&quot;,&quot;ask&quot;,&quot;Enter your name&quot;)</code></p>
</li>
</ul>
<p>这种方式也可以，并且不用执政，得到的就是纯纯的变量本身嗷。</p>
<ul>
<li><code>flag.Args() , flag.NArg() , flag.NFlag()</code></li>
<li>第一个时返回[]string参数，返回命令行后面其它参数；第二个时返回其它参数的个数，第三个时返回命令行参数的个数</li>
</ul>
<h1 id="TCP粘包"><a href="#TCP粘包" class="headerlink" title="TCP粘包"></a>TCP粘包</h1><ul>
<li>传送数据的时候，可能会同时发送多个数据</li>
<li>如果发送的时间间隔长的话，一次就只会发送一个数据</li>
<li>可以自己定义协议来定义包头和长度</li>
<li>详情参见代码</li>
</ul>
<h1 id="net-http"><a href="#net-http" class="headerlink" title="net/http"></a><code>net/http</code></h1><ul>
<li>首先这个包写的非常好，可以直接用来写一些小型的服务端</li>
<li>和前端的知识有的融合在一起了，<code>HandleFunc(request,func)</code>可以获得对应字段进行数据处理，读取对应的页面文件和CSS文件并传输给服务端。详情参见vscode中的例子</li>
<li><code>ListenAndServe</code>函数可以用于监听某一个端口号，作为服务端等待客户端向其发送的请求</li>
<li><code>http-client</code>中，url的构建可以采用，新建一个<code>url.Values&#123;&#125;</code>，然后再再不断地set元素的值，最后采用<code>urlStr = data.Encode()</code>，这个时候再去get就可以使用<code>http.NewRequest(&quot;GET&quot;,urlStr,nil)</code>这个方式来获得新的url。下面为构建url对象：</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">apiUrl := <span class="string">&quot;http://127.0.0.1:9090/get&quot;</span></span><br><span class="line"></span><br><span class="line">data := url.Values&#123;&#125;</span><br><span class="line">data.Set(<span class="string">&quot;name&quot;</span>,<span class="string">&quot;小王子&quot;</span>)</span><br><span class="line">data.Set(<span class="string">&quot;age&quot;</span>,<span class="number">18</span>)</span><br><span class="line">urlObj , err := url.ParseRequestURL(apiUrl)</span><br><span class="line"></span><br><span class="line">queryStr := data.Encode()</span><br><span class="line">urlObj.RawQuery = queryStr</span><br><span class="line">req , _ := http.NewRequest(<span class="string">&quot;GET&quot;</span>, urlObj.String(),<span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">http.DefaultClient.Do(req)</span><br></pre></td></tr></table></figure>

<ul>
<li>上述为个性请求的定制</li>
<li>response读取完成之后记得要关闭</li>
<li>后端发请求频繁的时候，可以考虑公用一个Client，这个时候可以通过声明全局变量的形式来操作，可以通过var把关键字提前到最前面，然后剪辑出来，让其保证长连接,<code>DisableKeepAlives: false</code>。</li>
<li>拉起的频率的非常低时，就应该禁用长连接，上面那个设置为true，用完client后马上进行释放，就会非常方便。</li>
</ul>
<h1 id="Context单元测试和pprof调试工具"><a href="#Context单元测试和pprof调试工具" class="headerlink" title="Context单元测试和pprof调试工具"></a>Context单元测试和pprof调试工具</h1><h2 id="go语言中单元测试"><a href="#go语言中单元测试" class="headerlink" title="go语言中单元测试"></a>go语言中单元测试</h2><ul>
<li><code>go test</code>命令</li>
<li>每个函数必须导入test包，文件必须以_test.go命名，测试函数必须以Test开头，后缀就是特定的函数名，大写开头，写法如下:</li>
<li><code>func TestName(t *testing.T)</code></li>
<li>可以看一看测试组，有’Run’这种函数可以有很多花哨的操作</li>
<li>可以通过<code>go test -cover</code>来查看覆盖率，甚至可以生成覆盖率的文件，通过go语言中的tool工具再浏览器中打开查看，画面很炫酷</li>
<li>一般情况下各个函数模块的测试覆盖率要达到100% , 整体覆盖率要达到60%</li>
</ul>
<h2 id="go语言中的基准测试"><a href="#go语言中的基准测试" class="headerlink" title="go语言中的基准测试"></a>go语言中的基准测试</h2><ul>
<li><p><code>func BenchmarkName()</code></p>
</li>
<li><p>执行时使用<code>go test -bench=Split</code></p>
</li>
<li><p>要用循环反复执行一个函数来进行操作效率分析</p>
</li>
<li><p>具体的例如基准测试使用的proxy的量，都可以找到对应的博客来操作对应的值。</p>
</li>
<li><pre><code class="go">func BenchmarkSplit(b *testing.B)&#123;
    for i:=0;i&lt;b.N;i++&#123;
        Split(&quot;A:B:C&quot;,&quot;:&quot;)
    &#125;
&#125;
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 上述就是一个测试的例子，可以通过结果来分析各个值，然后再次去优化代码。例如内存申请的次数等会影响到代码的效率。</span><br><span class="line"></span><br><span class="line">### 性能比较函数</span><br><span class="line"></span><br><span class="line">- 例如斐波那契数列</span><br><span class="line">- 可以通过封装函数来实现多次跑一个函数来达到目的，传入的参数可以为`b *testing.B , int n`，第二个参数是执行特定函数的次数。</span><br><span class="line">- b.N是循环的次数，不要传入函数中，是错误的用法。是一个随着函数和执行次数在该改变的变量。</span><br><span class="line">- 默认情况下，每个基准测试最少运行一秒，若没有到疫苗，b.N的值会1，2，5，10，20...这样一直增加，并且函数可以继续运行。</span><br><span class="line">- 可以用`-benchtime`来获得标志增加的最小基准时间，还有其它类似的用法等等。</span><br><span class="line">- 还可以并行测试，指定CPU的数量之类的。</span><br><span class="line"></span><br><span class="line">### setup和teardown等专业工具</span><br><span class="line"></span><br><span class="line">- setup和teardown函数，一个是初始化操作，一个是结尾首位操作</span><br><span class="line"></span><br><span class="line">## go语言中的示例函数</span><br><span class="line"></span><br><span class="line">- 以ExampleName这种形式开头，可以自动产生文档嗷！</span><br><span class="line">- 具体的在单元测试这一章的网上是有的。</span><br><span class="line">- go语言可以自动拉一个文档出来，骚得很。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## pprof工具的使用(go性能调优)</span><br><span class="line"></span><br><span class="line">- aspects: CPU profile , Memory , block , goroutine</span><br><span class="line">- `runtime/pprof` , `net/http/pprof`等运行时数据进行分析</span><br><span class="line">- 只有在代码测试优化时才进行调用</span><br><span class="line">- `isCPUPprof , isMemPprof`是否开启标志位</span><br><span class="line"></span><br><span class="line">![image-20201201220143773](C:\Users\Alexander Liu\AppData\Roaming\Typora\typora-user-images\image-20201201220143773.png)</span><br><span class="line"></span><br><span class="line">- 上述往文件中写入对应的信息</span><br><span class="line"></span><br><span class="line">- 结合flag包判断是否开启性能检测</span><br><span class="line"></span><br><span class="line">```go</span><br><span class="line">var isCPUPprof bool</span><br><span class="line"></span><br><span class="line">flag.BoolVar(&amp;isCPUPprof,&quot;cpu&quot;,false,&quot;turn cpu pprof on&quot;)</span><br><span class="line">flag.Parse()</span><br><span class="line"></span><br><span class="line">if isCPUPprof&#123;</span><br><span class="line">	file, err := os.Create(&quot;./cpu.pprof&quot;)</span><br><span class="line">	if err != nil&#123;</span><br><span class="line">		fmt.Printf(&quot;create cpu failed , err: 			%v\n&quot;,err)</span><br><span class="line">		return</span><br><span class="line">	&#125;</span><br><span class="line">	pprof.StartCPUPprof(file)</span><br><span class="line">	defer func()&#123;</span><br><span class="line">		pprof.StopCPUProfile()</span><br><span class="line">		file.Close()</span><br><span class="line">	&#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre>
</li>
<li><p>对于模型进行分析的时候，命令行:<code>xx.exe -cpu=true</code>，三十秒后就会自动生成相关的文件</p>
</li>
<li><p><code>go tool pprof xx.pprof</code>可以使用内置的go工具对于特定的值进行分析。进入交互界面后，输入top3或者top4就可以查看占用cpu最多的几个东东，这些东东可以帮助你了解自己函数的性能，从而进行优化！(quit可以退出交换界面嗷！)</p>
</li>
<li><p>还有<code>go-torch</code>等操作使得图特别选炫酷，可以看blog去看看怎么去操作那些东西。</p>
</li>
</ul>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><ul>
<li><p>用<code>MySQL</code></p>
</li>
<li><p><code>DDL,DML,DCL</code>之类的</p>
</li>
<li><p>支持插件式的搜索引擎。常见的有:<code>MyISAM</code>和<code>InnoDB</code></p>
<ul>
<li>MyISAM:</li>
</ul>
<ol>
<li>查询速度快</li>
<li>只支持表锁</li>
<li>不支持事务</li>
</ol>
<ul>
<li>InnoDB:</li>
</ul>
<ol>
<li>整体速度快</li>
<li>支持表锁和行锁</li>
<li>支持事务</li>
</ol>
<ul>
<li><p>事务：把多个SQL操作当成一个整体</p>
</li>
<li><p>ACID:</p>
</li>
</ul>
<ol>
<li>原子性：只有成功或者失败</li>
<li>一致性</li>
<li>隔离性：事务之间相互独立</li>
<li>持久性：事务操作结果不会丢失</li>
</ol>
</li>
<li><p>关系型数据库：用表来存放一类的数据</p>
</li>
<li><p>《漫画数据库》可以康康嗷！</p>
</li>
<li><p>隔离的四个级别：Read uncommitted , read committed , repeatable read , serializable</p>
</li>
<li><p>索引的原理： B5树和B+树</p>
</li>
<li><p>MySQL主从：</p>
<ul>
<li>binlog，把某个</li>
</ul>
</li>
<li><p>读写分离：从从库里面读，往主库里面写</p>
</li>
</ul>
<h1 id="Go对于MySQL的操作"><a href="#Go对于MySQL的操作" class="headerlink" title="Go对于MySQL的操作"></a>Go对于MySQL的操作</h1><h2 id="连接数据库："><a href="#连接数据库：" class="headerlink" title="连接数据库："></a>连接数据库：</h2><ul>
<li><p>database&#x2F;sql ，这个库并没有具体实现，不提供数据库驱动，因此要装第三方的驱动。</p>
</li>
<li><img src="C:\Users\Alexander Liu\AppData\Roaming\Typora\typora-user-images\image-20201207163310289.png" alt="image-20201207163310289" style="zoom: 200%;" />
</li>
<li><p>&#96;&#96;&#96;bash<br>go get -u github.com&#x2F;go-sql-driver&#x2F;mysql</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">下载依赖管理</span><br><span class="line"></span><br><span class="line">## 读取某一行的数据：</span><br><span class="line"></span><br><span class="line">![image-20201207172109804](C:\Users\Alexander Liu\AppData\Roaming\Typora\typora-user-images\image-20201207172109804.png)</span><br><span class="line"></span><br><span class="line">- 必须对于`rowobj`调用scan方法，这样才能释放链接，不然就会一直占有连接资源。</span><br><span class="line"></span><br><span class="line">- `SetMaxOpenConns`可以设置与数据库连接的最大数目</span><br><span class="line">- `SetMaxIdleConn`设置连接池中的最大闲置连接数</span><br><span class="line">- `db.QueryRow(sqlStr, 2).Scan(&amp;u1.id, &amp;u1.name, &amp;u1.age) *//从连接池拿出一个连接去数据库查询数据*`高级写法</span><br><span class="line"></span><br><span class="line">- 不要用:=去处理db，db这里是一个全局变量，要对于全局db进行处理。</span><br><span class="line"></span><br><span class="line">## 增删改查：</span><br><span class="line"></span><br><span class="line">详情看相关的go代码嗷！ </span><br><span class="line"></span><br><span class="line">## 数据预处理</span><br><span class="line"></span><br><span class="line">- sql语句分开成为命令部分和数据部分，先把命令部分发送非服务端，然后数据给服务端进行替换。</span><br><span class="line">- reason: 让服务器提前编译，一次白你要多次执行，时间花费少，以及避免用户输入恶意数据这种情况的发生。</span><br><span class="line"></span><br><span class="line">## go语言实现事务</span><br><span class="line"></span><br><span class="line">- 两个或者多个操作揉成一个整体</span><br><span class="line">- `Begin(*Tx, error) Commit Rollback()`这三个来实现</span><br><span class="line">- 只要有错误就回滚</span><br><span class="line">- 相当于多个事务打包一起，除了问题就回退，保证表原来的状态，只有所有过程都没问题才能正常更新表嗷！！！</span><br><span class="line"></span><br><span class="line">## sqlx的使用</span><br><span class="line"></span><br><span class="line">- [具体使用方法](https://www.liwenzhou.com/posts/Go/sqlx/)</span><br><span class="line"></span><br><span class="line">- 注意，这里的get方法用到了反射，取了指针，所以变量定义的时候要是大写，才能够被别的包的reflect检索到。</span><br><span class="line">- 注意传递指针注意注意注意嗷！</span><br><span class="line">- 不同的数据库占位符是不一样的。</span><br><span class="line"></span><br><span class="line">## sql注入</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># GO MODULE</span><br><span class="line"></span><br><span class="line">- go mod init</span><br><span class="line">- go get</span><br><span class="line">- go env</span><br><span class="line"></span><br><span class="line"># Context</span><br><span class="line"></span><br><span class="line">- 非常重要:</span><br><span class="line">  - 如何优雅控制子goroutine退出？</span><br><span class="line">    - 可以和C语言中一样，去中间break一下就退出了。</span><br><span class="line">    - `var exitChan chan bool`， 然后用select去检查channel中有没有值，这样来控制退出。</span><br><span class="line">    - `ctx , cancel := context.WithCancel(context.Background)`</span><br><span class="line">    </span><br><span class="line">    完整版:</span><br><span class="line">    </span><br><span class="line">    ```go</span><br><span class="line">    func f(ctx context.Context)&#123;</span><br><span class="line">    	def wg.Done</span><br><span class="line">        FORLOOP:</span><br><span class="line">        for&#123;</span><br><span class="line">            fmt.Println(&quot;退出&quot;)</span><br><span class="line">            time.Sleep(time.Millisecond * 500)</span><br><span class="line">            select&#123;</span><br><span class="line">                case &lt;- ctx.Done():</span><br><span class="line">                	break FORLOOP</span><br><span class="line">            	default:</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func main()&#123;</span><br><span class="line">        ctx , cancel := context.WithCancel(context.Background())</span><br><span class="line">        wg.Add(1)</span><br><span class="line">        go f(ctx)</span><br><span class="line">        time.Sleep(time.Second*5)</span><br><span class="line">        cancel()</span><br><span class="line">        wg.Wait()</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>  一个根的ctx一级级往下传，可以控制嵌套的进程的暂停和退出</p>
</li>
</ul>
<h1 id="服务端Agent开发"><a href="#服务端Agent开发" class="headerlink" title="服务端Agent开发"></a>服务端Agent开发</h1><h2 id="项目架构设计"><a href="#项目架构设计" class="headerlink" title="项目架构设计"></a>项目架构设计</h2><h2 id="Kafka-and-zookeeper"><a href="#Kafka-and-zookeeper" class="headerlink" title="Kafka and zookeeper"></a>Kafka and zookeeper</h2><h2 id="tailf接受"><a href="#tailf接受" class="headerlink" title="tailf接受"></a>tailf接受</h2><h1 id="gin框架"><a href="#gin框架" class="headerlink" title="gin框架"></a>gin框架</h1><ul>
<li>github上有源码，直接上去copy下来</li>
<li>路由初始化：<ul>
<li><ol>
<li>gin.Default()获取路由</li>
<li>绑定路由规则，执行的函数,<code>r.GET(&quot;/&quot;,func(c *gin.Context))</code> , Context里面封装了request,response之类的东西。使得更加为一个整体。</li>
<li>使服务器监听端口</li>
</ol>
</li>
</ul>
</li>
<li>gin路由：<ul>
<li>由httprouter做的</li>
<li><code>Restful风格的API</code>:<ul>
<li>获取文章 <code>/blog/getXxx</code> &#x3D;&gt; Get   blog&#x2F;Xxx</li>
<li>添加 <code>/blog/addXxx</code>&#x3D;&gt;  Post   blog&#x2F;Xxx</li>
<li>修改 <code>/blog/updateXxx</code> &#x3D;&gt; Put   blog&#x2F;Xxx</li>
<li>删除 <code>/blog/delXxx</code> &#x3D;&gt;  Delete   blog&#x2F;Xxx</li>
</ul>
</li>
</ul>
</li>
<li>剩下的例子去看代码</li>
<li>httproter原理可以去github上看源码，构造前缀树啊之类的东西</li>
<li>![image-20201215152054557](C:\Users\Alexander Liu\AppData\Roaming\Typora\typora-user-images\image-20201215152054557.png)</li>
</ul>
<h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><ul>
<li>HTTP是无状态的协议，为了区分是否为同一个客户端发出，才有了cookie。</li>
<li>client请求服务器，服务器除了返回信息还会返回一个cookie，cookie保存在本地的浏览器上，起到身份识别的作用。当client再次请求server时，会携带cookie</li>
<li>作用：<ul>
<li>保持用户登录状态</li>
<li>保持用户的信息(比如说京东的购物车)</li>
</ul>
</li>
<li>缺点：<ul>
<li>安全性不高</li>
<li>增加访问带宽消耗</li>
<li>可以被禁用</li>
<li>cookie有上限的</li>
</ul>
</li>
</ul>
<h1 id="Redis数据库"><a href="#Redis数据库" class="headerlink" title="Redis数据库"></a>Redis数据库</h1><ul>
<li>应用场景:<ul>
<li>缓存系统，减轻mysql的压力</li>
<li>cache缓存</li>
<li>热门排行榜</li>
<li>利用LIST实现队列的功能</li>
</ul>
</li>
<li>Session的过期时间，可以在set的时候使用</li>
<li>我们用的库是自带连接池的库嗷！</li>
<li>《Redis实战》好书啊！</li>
</ul>
<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><ul>
<li><p>弥补Cookie的不足，只存session的id， session是离不开cookie的，session保存在cookie里面</p>
</li>
<li><p>要用到redis数据库嗷！</p>
</li>
<li><p>![image-20201216200209531](C:\Users\Alexander Liu\AppData\Roaming\Typora\typora-user-images\image-20201216200209531.png)</p>
</li>
<li><p>session接口设计：</p>
<ul>
<li>Set()</li>
<li>Get()</li>
<li>Del()</li>
<li>Save():  session存储</li>
</ul>
</li>
</ul>
<h1 id="一些偷学到的小技巧"><a href="#一些偷学到的小技巧" class="headerlink" title="一些偷学到的小技巧:"></a>一些偷学到的小技巧:</h1><h2 id="vscode中用户代码片段打开设置"><a href="#vscode中用户代码片段打开设置" class="headerlink" title="vscode中用户代码片段打开设置"></a>vscode中用户代码片段打开设置</h2><ul>
<li>在vscode中:<ul>
<li>ctrl + shift + p</li>
<li>snippets</li>
<li>选含有preferences那一项</li>
<li>选中go</li>
<li>然后用json格式就可以自定义代码格式<ul>
<li>前面的名字为你想定义的模板名</li>
<li>prefix为快捷键的方式</li>
<li>body为你要输出的内容</li>
<li>description为描述貌似没啥用???</li>
<li>$为最后光标停留的位置</li>
<li>关于json怎么写之类的我收藏了的，可以直接康收藏。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="相关代码含义查找"><a href="#相关代码含义查找" class="headerlink" title="相关代码含义查找"></a>相关代码含义查找</h2><ul>
<li>上go语言官网（已在收藏夹中）</li>
<li>找到对应的import函数</li>
<li>找到对应的用法即可</li>
</ul>
<h1 id="一些小而重要的知识点"><a href="#一些小而重要的知识点" class="headerlink" title="一些小而重要的知识点"></a>一些小而重要的知识点</h1><h2 id="文件中defer的用法"><a href="#文件中defer的用法" class="headerlink" title="文件中defer的用法"></a>文件中defer的用法</h2><p>![image-20201026172410243](C:\Users\Alexander Liu\AppData\Roaming\Typora\typora-user-images\image-20201026172410243.png)</p>
<p>下面才是对的，由于出问题时，fileObj为nil ， 而err有值，所以调用fileObj.Close()会引发错误造成panic ， 所以直接退出程序这个时候反而是对的，因为对应文件根本没有打开，只有打开了对应文件才应该关闭。相当于固定搭配，记住就好啦！</p>
<h2 id="使用go-module导入包"><a href="#使用go-module导入包" class="headerlink" title="使用go module导入包"></a>使用go module导入包</h2><ul>
<li>对于需要包管理的文件夹，要先<code>go mod init name</code>这阿姨那个对于包管理初始化，这个name是起的名字。这名字对于以后的调用中都用得到，而且是从<code>demoname</code>开始调用相对路径的，注意不是从文件夹开始调用，是从<code>demoname</code>开始调用</li>
</ul>
<h2 id="一些快捷键补充"><a href="#一些快捷键补充" class="headerlink" title="一些快捷键补充"></a>一些快捷键补充</h2><ul>
<li>按住alt用鼠标选中多个位置，可以多行一起操作</li>
</ul>
<h2 id="面试题分享"><a href="#面试题分享" class="headerlink" title="面试题分享"></a>面试题分享</h2><ul>
<li>判断链表有循环？</li>
</ul>
<p>从头开始走，一次走一步，一次走两步，看两者有没有机会相遇</p>
<ul>
<li>走台阶问题</li>
</ul>
<p>问题归纳，使用递归可以解决</p>
<h1 id="大作业"><a href="#大作业" class="headerlink" title="大作业"></a>大作业</h1><h2 id="日志库"><a href="#日志库" class="headerlink" title="日志库"></a>日志库</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ul>
<li>不同的地方输出日志</li>
<li>日志的分级别:<ul>
<li>debug</li>
<li>trace</li>
<li>info</li>
<li>warning</li>
<li>error</li>
<li>fatal</li>
</ul>
</li>
<li>日志要支持开关控制</li>
<li>日志要有时间，行号，文件名，日志级别，日志信息</li>
<li>日志文件要切割:<ul>
<li>按照文件大小切割<ul>
<li>每次记录日志之前都判断一下文件大小</li>
</ul>
</li>
<li>按照日期切割<ul>
<li>每次记录日志之前都判断一下时间（在日志结构体中设置一个字段记录上一次切割的小时数）</li>
<li>写日志前判断一下小时数是否和结构体中的小时数一致即可</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="日志库的异步实现"><a href="#日志库的异步实现" class="headerlink" title="日志库的异步实现:"></a>日志库的异步实现:</h3><ul>
<li>在线程写入的时候，启用其它的线程来执行其它功能保证不会卡。</li>
</ul>
<h2 id="worker-pool-goroutine池"><a href="#worker-pool-goroutine池" class="headerlink" title="worker pool(goroutine池)"></a>worker pool(goroutine池)</h2><ul>
<li>使用goroutine来实现int64位中各位和的计算</li>
</ul>
<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips:"></a>Tips:</h1><ul>
<li>一个用了指针，全部都用指针嗷，这样才能保证对象对应的结构体或者方法能够被修改！！！要么全是指针接收者，要么全是值接收者。</li>
<li>传递参数的时候:</li>
</ul>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">add</span><span class="params">(a ...<span class="keyword">interface</span>&#123;&#125;)</span></span>&#123;</span><br><span class="line">	body</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = []<span class="keyword">interface</span>&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">add(s)</span><br><span class="line">add(s...)</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里s传递是一个slice,s...传递的则是切片中的每一个元素，这个很重要嗷。</span></span><br></pre></td></tr></table></figure>


                
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        Author:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">John Doe</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        Link:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="http://example.com/2021/02/20/go%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/">http://example.com/2021/02/20/go%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%9F%A5%E7%BC%BA%E8%A1%A5%E6%BC%8F/</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        Reprint policy:
                    </i>
                </span>
                <span class="reprint-info">
                    All articles in this blog are used except for special statements
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    reprint policy. If reproduced, please indicate source
                    <a href="/about" target="_blank">John Doe</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>Copied successfully, please follow the reprint policy of this article</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">more</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/%E5%90%8E%E7%AB%AF/">
                                    <span class="chip bg-color">后端</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="/2021/02/20/go%E8%AF%AD%E8%A8%80%E8%87%AA%E5%AD%A6/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/9.jpg" class="responsive-img" alt="Go语言自学">
                        
                        <span class="card-title">Go语言自学</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            Go是大二比较系统的学习的后端语言，没有学习完，但是对于redis数据库等之类的后端内容有了相关的了解，后面还会更新完善
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2021-02-20
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            John Doe
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/%E5%90%8E%E7%AB%AF/">
                        <span class="chip bg-color">后端</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2021/02/20/%E7%88%AC%E8%99%AB%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3(%E8%87%AA%E5%AD%A6)/">
                    <div class="card-image">
                        
                        
                        <img src="/medias/featureimages/11.jpg" class="responsive-img" alt="xpath中小爬爬的运用">
                        
                        <span class="card-title">xpath中小爬爬的运用</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            这儿是爬虫部分xpath的初始学习，在我学习完html和css之后，就采用结点的方式去获取网站了，因此这儿不多赘述，后续有精力再去完善相应的内容。
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2021-02-20
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            John Doe
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Python/">
                        <span class="chip bg-color">Python</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('0'),
            headingSelector: 'h2, h3, h4'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="503838841"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='auto'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="/libs/aplayer/Meting.min.js"></script>

    

    <div class="container row center-align"
         style="margin-bottom: 0px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            
                <span id="year">2019-2022</span>
            
            <a href="/about" target="_blank">John Doe</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            
            
                
            
            
                <span id="busuanzi_container_site_pv">
                &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;Total visits:&nbsp;
                    <span id="busuanzi_value_site_pv" class="white-color"></span>
            </span>
            
            
                <span id="busuanzi_container_site_uv">
                &nbsp;|&nbsp;<i class="fas fa-users"></i>&nbsp;Total visitors:&nbsp;
                    <span id="busuanzi_value_site_uv" class="white-color"></span>
            </span>
            
            <br>

            <!-- 运行天数提醒. -->
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/blinkfox" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:1181062873@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=1181062873" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 1181062873" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

     
        <script src="https://ssl.captcha.qq.com/TCaptcha.js"></script>
        <script src="/libs/others/TencentCaptcha.js"></script>
        <button id="TencentCaptcha" data-appid="xxxxxxxxxx" data-cbfn="callback" type="button" hidden></button>
    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
