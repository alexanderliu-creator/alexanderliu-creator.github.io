<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Go究极李文周网课学习 | 兔の博客</title><meta name="author" content="Alexander Liu"><meta name="copyright" content="Alexander Liu"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="这儿是对于Go语言整体系统的学习，是b站李文周老师的教程的整理的内容和自己的学习心得体会，记录在这儿">
<meta property="og:type" content="article">
<meta property="og:title" content="Go究极李文周网课学习">
<meta property="og:url" content="http://example.com/2021/02/20/go-di-er-ci-cha-que-bu-lou/index.html">
<meta property="og:site_name" content="兔の博客">
<meta property="og:description" content="这儿是对于Go语言整体系统的学习，是b站李文周老师的教程的整理的内容和自己的学习心得体会，记录在这儿">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7">
<meta property="article:published_time" content="2021-02-20T08:05:21.000Z">
<meta property="article:modified_time" content="2021-03-01T13:04:05.000Z">
<meta property="article:author" content="Alexander Liu">
<meta property="article:tag" content="后端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/02/20/go-di-er-ci-cha-que-bu-lou/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"prismjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Go究极李文周网课学习',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-03-01 21:04:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="兔の博客" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">134</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">兔の博客</a></span><div id="menus"><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Go究极李文周网课学习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-02-20T08:05:21.000Z" title="发表于 2021-02-20 16:05:21">2021-02-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-03-01T13:04:05.000Z" title="更新于 2021-03-01 21:04:05">2021-03-01</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Go究极李文周网课学习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="这儿是对于Go语言整体系统的学习，是b站李文周老师的教程的整理的内容和自己的学习心得体会，记录在这儿"><a href="#这儿是对于Go语言整体系统的学习，是b站李文周老师的教程的整理的内容和自己的学习心得体会，记录在这儿" class="headerlink" title="这儿是对于Go语言整体系统的学习，是b站李文周老师的教程的整理的内容和自己的学习心得体会，记录在这儿"></a>这儿是对于Go语言整体系统的学习，是b站李文周老师的教程的整理的内容和自己的学习心得体会，记录在这儿</h1><hr>
<span id="more"></span>





<h1 id="关于变量的声明"><a href="#关于变量的声明" class="headerlink" title="关于变量的声明"></a>关于变量的声明</h1><ul>
<li>变量声明可以用</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span><span class="token punctuation">(</span>
	str <span class="token builtin">string</span>
	a   <span class="token builtin">int</span>
	wheater <span class="token builtin">bool</span>
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>变量如果声明了不使用会报错</li>
<li>go fmt filename 这种方式可以使文件格式化</li>
<li>类型变量和短变量声明:</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> s1 <span class="token operator">=</span> <span class="token string">"this is rabbit"</span>
s2 <span class="token operator">:=</span> <span class="token string">"this is rabbit too"</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li>匿名变量”_” ， 可以忽略一些值，不占用空间也不分配内存，接收值之后就直接扔掉了。</li>
<li>:= 等赋值不能在函数外赋值</li>
<li>同一个作用域不能重复声明同一个变量</li>
</ul>
<h1 id="关于常量"><a href="#关于常量" class="headerlink" title="关于常量"></a>关于常量</h1><ul>
<li><code>const pi = 3.14159</code>常量的声明</li>
<li>批量声明:</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span><span class="token punctuation">(</span>
	statusOK <span class="token operator">=</span> <span class="token number">200</span>
	notfound <span class="token operator">=</span> <span class="token number">404</span>
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span><span class="token punctuation">(</span>
	n1 <span class="token operator">=</span> <span class="token number">100</span>
	n2
	n3
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>如果没有写值的话默认和上面是一样的。</p>
<ul>
<li>iota是go语言的常量计数器，只能在常量表达式中使用。</li>
</ul>
<p>多一个常量，iota++ , 默认值为0, 每出现一次const, iota就重置为0，每多<code>一行</code>常量声明，iota在这一行后就会+1。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span><span class="token punctuation">{</span>
	a1 <span class="token operator">=</span> <span class="token boolean">iota</span>
    <span class="token boolean">_</span>
	a2
	a3
    a4 <span class="token operator">=</span> <span class="token number">100</span>
    a5
<span class="token punctuation">}</span><span class="token comment">// a1 = 0 , 由于后面没有标，默认也是iota嗷</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>定义数量级:</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">const</span><span class="token punctuation">(</span>
	<span class="token boolean">_</span> <span class="token operator">=</span> <span class="token boolean">iota</span>
	KB <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">*</span><span class="token boolean">iota</span><span class="token punctuation">)</span>
	MB <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">*</span><span class="token boolean">iota</span><span class="token punctuation">)</span>
	GB <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">*</span><span class="token boolean">iota</span><span class="token punctuation">)</span>
    TB <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">*</span><span class="token boolean">iota</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><ul>
<li><p>int8 , int16 , int32 ,int 64</p>
</li>
<li><p>uint8 , uint16…</p>
</li>
<li><p>uint类型会根据操作系统自己决定</p>
</li>
<li><p>int也是这样</p>
</li>
<li><p>uintptr 存放一个指针嗷！</p>
</li>
<li><p>float32 , float64</p>
</li>
<li><p>bool - true , false</p>
</li>
<li><p>二进制数在go语言中无法直接定义，只能转换</p>
</li>
<li><p>八进制前面带有0 ， 十六进制带有0x ，是可以直接声明的。</p>
</li>
</ul>
<p>%d , %o , %x这三个都是常用的十进制，八进制和十六进制,</p>
<p>%b 是二进制。</p>
<p>%#v 会自动帮你的类型加一个双引号。</p>
<ul>
<li><p>查看变量类型: <code>%T</code></p>
</li>
<li><p>强制类型转换: <code>a := int8(9)</code></p>
</li>
<li><p>%v 打印输出的是变量的值，不用管type , 很有用哦。</p>
</li>
<li><p>浮点数: float32 , float64</p>
</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">math<span class="token punctuation">.</span>Mathfloat32
math<span class="token punctuation">.</span>Mathfloat64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>默认也是64</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ul>
<li><p>go语言中的字符串只能用<code>""</code>来包裹</p>
</li>
<li><p>go语言中的<code>''</code>用来包裹字符</p>
</li>
<li><p>一个中文一般占三个字节</p>
</li>
<li><p>转义符用法一样的</p>
</li>
<li><p>多行字符串：</p>
</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">s2 <span class="token punctuation">:</span> <span class="token operator">=</span> <span class="token string">`
	a
	b
	c
`</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>反引号``中的东西原样子输出，是不会变的。</p>
</li>
<li><p>字符串的拼接: 用加号</p>
</li>
<li><p><code>Printf</code>和<code>Sprintf</code>第一个直接在终端答应输出，第二个是以字符串的形式返回。</p>
</li>
<li><p>strings包里有好多的像是Split和Contains和HasPrefix , Index , lastIndex , Join等函数方法用来调用。</p>
</li>
<li><p>字符串不能修改的，只能转换成切片然后再进行转换哦。</p>
</li>
<li><p><code>""</code>和<code>''</code>对应的类型是不一样的嗷</p>
</li>
<li><p>go 使用了rune 类型来处理Unicode , 所以如果要处理中文等，都转换成rune类型嗷。</p>
</li>
</ul>
<h1 id="if和for等结构"><a href="#if和for等结构" class="headerlink" title="if和for等结构"></a>if和for等结构</h1><ul>
<li>非常特别：</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">if</span> a <span class="token operator">:=</span> <span class="token number">19</span><span class="token punctuation">;</span> age <span class="token operator">&gt;</span> <span class="token number">18</span><span class="token punctuation">{</span>
	body
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>go语言中只有for循环:</p>
<ul>
<li><pre><code class="go">for i := 0; i&lt;10 ; i++{
    body
}
<pre class="line-numbers language-none"><code class="language-none">
- ```go
  i := 0
  for ;i&lt;10;i++{
  	body
  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><pre><code class="go">i := 0
for i&lt;10{
    body
    i++
}
<pre class="line-numbers language-none"><code class="language-none">
- ```go
  for{
      body
      if(condition){
          break
      }
  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p>range好重要！！！</p>
</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">s <span class="token operator">:=</span> <span class="token string">"hello沙河"</span>
<span class="token keyword">for</span> i<span class="token punctuation">,</span>v <span class="token operator">:=</span> <span class="token keyword">range</span> s<span class="token punctuation">{</span>
	body
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>i获得的是索引，v获得的是value</p>
</li>
</ul>
<h1 id="switch和goto"><a href="#switch和goto" class="headerlink" title="switch和goto"></a>switch和goto</h1><ul>
<li><pre><code class="go">switch n:=1 ; n{
    body
}
<pre class="line-numbers language-none"><code class="language-none">
- ```go
  switch n{
      case n&lt;26:
      	body...
  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p>fallthrough可以像c语言一样下穿，就是为了满足c语言。（最好不要用嗷！）</p>
</li>
<li><p>goto可以跳到某些代码块儿上，也不常用了。</p>
</li>
<li><p>```go<br>xx:<br>fmt.Println(“asjdkfs”)<br>goto xx // 这样就完成了跳转</p>
<pre class="line-numbers language-none"><code class="language-none">  
- 同样 break 和 continue 也可以接上goto语句





# 运算符

- `a++`里面是单独的语句，不能放在等号的右边赋值
- 位运算:

```go
&amp; 按位与
| 按位或
&lt;&lt; 左移n位
&gt;&gt; 右移n位
^ 按位异或<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<p>默认是二进制进行计算的</p>
<ul>
<li>要注意范围哦，像是int8你如果左移了10位就可能出问题，但是16位就不一定会嗷。</li>
<li>同样的也可以进行赋值的:</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token operator">+=</span> <span class="token operator">-=</span>  <span class="token operator">=</span>  <span class="token operator">*=</span>  <span class="token operator">/=</span>  <span class="token operator">%=</span>  <span class="token operator">&lt;&lt;=</span><span class="token number">2</span> <span class="token operator">&gt;&gt;=</span><span class="token number">2</span>  <span class="token operator">&amp;=</span><span class="token number">2</span> <span class="token operator">|=</span><span class="token number">2</span>  <span class="token operator">^=</span><span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>





<h1 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型:"></a>复合数据类型:</h1><h2 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h2><ul>
<li>长度和类型</li>
<li>就类似于其他语言中的列表</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> name <span class="token punctuation">[</span>num<span class="token punctuation">]</span><span class="token keyword">type</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>对用的type就是[3]int</li>
<li>初始化：</li>
</ul>
<p>默认元素都是零值</p>
<ol>
<li><pre><code class="go">a1 = [3]int{0,1,2}
<pre class="line-numbers language-none"><code class="language-none">
2. ```go
   a2 := [...]int{1,2,34,545,456...}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p>```go<br>a3 := [5]int{1,2}   //自动补零</p>
<pre class="line-numbers language-none"><code class="language-none">
4. ```go
   a3 := [5]int{0:5,2:8}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
</ol>
<ul>
<li>数组的传递:</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">x <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span>
y <span class="token operator">:=</span> x
<span class="token comment">//这个时候得到的y是x的一个副本嗷呜！！！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<ul>
<li>数组的遍历：</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> i<span class="token operator">:=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token function">len</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">{</span>
	body
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> i<span class="token punctuation">,</span>v <span class="token operator">:=</span> <span class="token keyword">range</span> ArrayName<span class="token punctuation">{</span>
	body
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>多维数组:</p>
<ul>
<li><pre><code class="go">var all [3][2]int
all = [3][2]int{
    [2]int{1,2},
    [2]int{3,4},
    [2]int{5,6}
} //和numpy差不多嗷呜
<pre class="line-numbers language-none"><code class="language-none">
- 多维数组的遍历:

```go
for _, v1 := range all{
	fmt.Println(v1)
	for _,v2 := range v1{
		fmt.Println(v2)
	}
} //两层遍历，这里的v1实际上是内层数组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p>多维数组也可以这样定义</p>
</li>
</ul>
<p><code>var a1 [...][2]int</code> , 最外层才可以… , 内层是不可以加的哦。</p>
</li>
<li><p>在go语言中，对于数组的赋值，实质上是值应用，相当于复制了一个数组给我们要引用的对象。</p>
</li>
</ul>
<h2 id="切片："><a href="#切片：" class="headerlink" title="切片："></a>切片：</h2><h3 id="切片基础操作："><a href="#切片基础操作：" class="headerlink" title="切片基础操作："></a>切片基础操作：</h3><ul>
<li>可变长度的，并且是引用类型</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> s <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>   <span class="token comment">// 切片不存在为nil</span>
s1 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">int</span><span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">// 切片存在且len和cap都为0</span>
s2 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>   <span class="token comment">//和上面一样没啥区别</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>由于是可变的，声明切片的时候可以这样声明</p>
<ul>
<li>切片和数组最大的区别就是切片声明的时候是不带长度的，因为切片长度是可变的，初始化的时候就得以体现。</li>
<li>nil类似于其他语言中的空</li>
<li>切片没有初始化时默认为空，即没有分配内存空间</li>
<li>len长度，cap为容量</li>
<li>初始化:</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token number">1.</span> 
<span class="token keyword">var</span> s <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>
s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span>
<span class="token comment">// 本质也是造一个数组，返回切片给你</span>
<span class="token number">2.</span>
s1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">}</span>
s <span class="token operator">=</span> s1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token comment">//和py中一样，左开右闭。</span>
<span class="token number">3.</span>
s2 <span class="token operator">:=</span> s3<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
<span class="token comment">// 切片的切片</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>切片容量是从切片第一个元素对应底层数组到末尾的元素的个数</li>
<li>切片是引用，指向一个指定的数组，切片和数组都是相互影响的。</li>
<li>make函数构造切片:</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">s1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment">//默认切片元素都为0，如果不加第二个参数，默认cap和len相同，本质也是底层数组的分配。</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>切片的内存: 一块儿连续的内存</li>
<li>一个nil值的切片是没有底层数组的，切片的长度和容量都是0</li>
<li>切片的遍历:</li>
</ul>
<ol>
<li>```go<br>//和c语言里面一样<br>for i:=0;i&lt;len(s);i++{<br>body<br>}<pre class="line-numbers language-none"><code class="language-none">
2. ```go
   for i,v := range s{
   	fmt.Println(l,v)
   }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h3 id="切片高级操作："><a href="#切片高级操作：" class="headerlink" title="切片高级操作："></a>切片高级操作：</h3><ul>
<li><p>切片的扩容：</p>
<ul>
<li>相关操作:</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">s <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">string</span><span class="token punctuation">(</span><span class="token string">"北京"</span><span class="token punctuation">,</span><span class="token string">"上海"</span><span class="token punctuation">)</span>
s<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"上海"</span> <span class="token comment">// 这个是错误的,index out of range</span>
s <span class="token operator">:=</span> s<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span><span class="token string">"广州"</span><span class="token punctuation">,</span><span class="token string">"成都"</span><span class="token punctuation">)</span>
<span class="token comment">// 这个时候底层数组的长度直接翻倍，找了一个新的地址直接分配新的内存，原来的底层数组就gg了，重新用了一块儿新的，s如果不接收新的数组的话，就废了，所以最好就是用原来的变量接收新的值。拓展容量有自己的方法的,感兴趣可以百度嗷！</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<p>s1 := []string(“武汉”,”成都”)<br>  s = s.append(s.s1…)// 这样也可以哦, …表示拆开，把每个单独的元素拿出来，这样也可以达到拓展的目的</p>
<ul>
<li><p>调用append必须要用原来的变量接收返回值。</p>
</li>
<li><p>切片的复制:</p>
<ul>
<li>copy(destination , source)</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> a3 <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>
a1 <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">int</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token function">copy</span><span class="token punctuation">(</span>a3<span class="token punctuation">,</span>a1<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</li>
<li><p>元素的删除:</p>
<ul>
<li>可以通过切片来实现，没有专门的实现方法。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">a1 <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span>a1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>注意传递切片的时候要拆开。</li>
<li>一般不是直接操作数组，因为数组长度固定不可变，所以一般都是操作切片，常用的操作方法有:</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">a1 <span class="token operator">=</span> s<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>然后再对a1进行操作。</p>
<ul>
<li>经典例子:</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">x1 <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">}</span>
s1 <span class="token operator">=</span> x1<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">]</span>
s1 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>s1<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span>s1<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token operator">...</span><span class="token punctuation">)</span>
<span class="token comment">//这个时候x1就变成了(1,5,5)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>由于底层是切片，这样s1变成了[1,5]，按照顺序保存在数组的位置上，但数组的元素个数是不变的，相当于切片有改变了前两个元素。</p>
<ul>
<li>面试题:</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span>

<span class="token keyword">for</span> i<span class="token operator">:=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">{</span>
    a <span class="token operator">=</span> a<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">//结果为[0,0,0,0,0,0,1,2,3,4,5,6,7,8,9]</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>一开始初始化make时就已经存在a为[0,0,0,0,0]了，再往后append就是这个结果。</p>
</li>
</ul>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul>
<li>比较简单（不存在指针操作）</li>
<li><code>&amp;</code>和<code>*</code>就这两个操作</li>
<li>bugs:<ul>
<li><code>var a *int</code>这个声明了一个指针，但没有初始化，默认指向nil , <code>*a = 100</code>这样赋值是不可以的。因为这个时候，a指针指向一个空地址，连地址指向哪里都不知道无法赋值。</li>
</ul>
</li>
<li>用new函数分配内存地址:</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span>
<span class="token operator">*</span>a <span class="token operator">=</span> <span class="token number">100</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<p>默认给a申请了指针的空间</p>
<ul>
<li><p>new一般用于给基本数据类型申请内存，返回的是对应类型的指针。</p>
</li>
<li><p>make也是用来分配地址的：</p>
<ul>
<li>用于为slice , map , chan申请内存 , make返回的是对应类型本身。</li>
</ul>
</li>
<li><p>go语言中指针有个用法，就是用指针指示成员变量的时候是可以类似于成员对象一样调用的。</p>
</li>
</ul>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><ul>
<li>映射关系，map是应用类型</li>
<li>map[key]value</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> m1 <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token comment">// 这样不行，默认map是空，因为没有为map分配内存</span>
m1 <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment">// 初始化要估算好内存，最好一次到位，避免动态扩容。</span>
m1<span class="token punctuation">[</span><span class="token string">"rabbit"</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">18</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>v, ok = m1["rabbit"]</code>因为自动返回两个值嗷</li>
<li>map的遍历:</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> m1<span class="token punctuation">{</span>
	body
<span class="token punctuation">}</span>
<span class="token comment">// k是key , v是value</span>
<span class="token comment">// 注意可以用_来取得我们需要的值即可</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>删除:</li>
</ul>
<p><code>delete(mapname,keyname)</code></p>
<ul>
<li>其他一些用法：</li>
</ul>
<p>比如按照指定顺序遍历map:</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> keys <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span>
<span class="token keyword">for</span> key <span class="token operator">:=</span> <span class="token keyword">range</span> scoreMap<span class="token punctuation">{</span>
	keys <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>keys<span class="token punctuation">,</span>key<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

sort<span class="token punctuation">.</span><span class="token function">Strings</span><span class="token punctuation">(</span>keys<span class="token punctuation">)</span>

<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> key <span class="token operator">:=</span> <span class="token keyword">range</span> keys<span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>scoreMap<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>利用切片对于map元素进行处理。(利用循环单独提取key存在切片里面，然后对于切片进行操作嗷呜！)。</p>
<ul>
<li><p>map可以和切片等其他的数据类型相组合：</p>
<ul>
<li>注意初始化!!!</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> s1 <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span>
s1<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token comment">//注意多重结构多重初始化哦，和java中一样样的，基本不用，但是复杂结构要哦。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li>```go<br>var m1 = make(map[string][]int,10)<br>m1[“homework”] = []int{1,2,3}<pre class="line-numbers language-none"><code class="language-none">
- 切片和map在一起一定要记得初始化嗷。





# 函数（非常非常重要嗷呜！！！）

- ```go
  func sum(x, y int) (ret int){
  	body
  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><pre><code class="go">func sum() int{
    body
}
<pre class="line-numbers language-none"><code class="language-none">
- 两个对比

```go
func sum(x, y int) (ret int){
	ret = x+y
	return
}
//使用命名返回值可以省略
func sum(x, y int) int{
	ret := x+y
	return ret
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p>可变长参数:</p>
<ul>
<li><code>fun f7(x string, y ...int){}</code></li>
<li>这里的y…处可以传入零个或者多个参数，非常有用</li>
<li>y这个时候为一个slice</li>
<li>可变长参数必须放在参数的最后</li>
</ul>
</li>
<li><p>go语言中没有默认参数这个概念。</p>
</li>
<li><p>go语言中的函数传递的都是值哦，都是传递的副本，和java中差不多嗷</p>
</li>
<li><p>go语言中支持多个返回值嗷呜！</p>
</li>
<li><p>返回值要不都不命名要不都命名。</p>
</li>
</ul>
<h3 id="重点难点-defer语句"><a href="#重点难点-defer语句" class="headerlink" title="重点难点: defer语句"></a>重点难点: defer语句</h3><ul>
<li>多个defer的时候其实上是根据栈来执行的，先进后出的原则嗷呜！</li>
<li>多用于函数结束之前释放资源的时候使用，还用于记录时间啊，文件关闭啊等等。</li>
<li>go语言中的return不是原子操作，在函数中先返回值赋值，然后执行defer语句，最后才真正结束函数。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>x <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		x<span class="token operator">++</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span> <span class="token number">5</span>
<span class="token punctuation">}</span>
<span class="token comment">//最终的答案是6哦</span>

<span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>y <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    x <span class="token operator">:=</span> <span class="token number">5</span>
	<span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		x<span class="token operator">++</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span> x
<span class="token punctuation">}</span>
<span class="token comment">//答案是5</span>

<span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>x <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		x<span class="token operator">++</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
	<span class="token keyword">return</span> <span class="token number">5</span>
<span class="token punctuation">}</span>
<span class="token comment">//答案是5</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><code>defer calc("1",a,b,calc("10",a,b))</code></li>
</ul>
<p>这里先调用内层函数算出内部确切的值，例如内部的a和clac都赋予了此刻值，然后才会把外层函数defer延迟调用，就是说defer作用只有一层，其余的依旧会在本步实现。</p>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><ul>
<li>和其他的函数差不多</li>
<li>查找变量从内向外查找</li>
</ul>
<h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><ul>
<li>函数类型的区分，按照参数和返回值来区分的‘</li>
<li>函数接收函数:</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span>x <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	body
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span>x <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token comment">//直接调用函数</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>函数还可以作为返回值:</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">f</span><span class="token punctuation">(</span>x <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token punctuation">{</span>
	body
<span class="token punctuation">}</span> <span class="token comment">// 满足参数要求的都可以返回。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<h3 id="匿名函数与立即执行函数"><a href="#匿名函数与立即执行函数" class="headerlink" title="匿名函数与立即执行函数"></a>匿名函数与立即执行函数</h3><ul>
<li>定义一个匿名函数</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> f1 <span class="token operator">=</span> <span class="token keyword">func</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	body
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<ul>
<li>函数内部不能再定义函数（但是匿名函数可以），用于这种情况。通常和java中一样用于只使用一次的函数或者使用次数较少的函数。</li>
<li>立即执行函数：</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">fun <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>

	<span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"hello this is here"</span><span class="token punctuation">)</span>
	<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>//这里的fun函数声明之后立刻使用，只使用一次，之后就找不到了。</p>
<ul>
<li>函数内部定义函数一般用匿名函数，只使用一次的直接用立即执行函数</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul>
<li>包装函数，使得函数之间的接口相匹配。</li>
<li>函数名加上了()代表函数的执行</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">adder</span><span class="token punctuation">(</span>x <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token function">fun</span><span class="token punctuation">(</span>y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span><span class="token punctuation">{</span>
		x <span class="token operator">+=</span> y
		<span class="token keyword">return</span> x
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	ret <span class="token operator">:=</span> <span class="token function">adder</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span>
	ret2 <span class="token operator">=</span> <span class="token function">ret</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>人为构造函数接口，函数内部定义的函数</li>
<li>闭包是： <ul>
<li>一个函数</li>
<li>函数包含其外部作用域的一个函数，把x包含进去了，再接下来的过程中再继续调用。</li>
<li>闭包 = 函数 + 外部变量的引用</li>
</ul>
</li>
<li>原理：<ul>
<li>函数可以作为返回值</li>
<li>查找变量的顺序</li>
</ul>
</li>
<li>外部传入的变量被包起来了，在调用内层函数的时候实现再次访问。</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">fun <span class="token function">f1</span><span class="token punctuation">(</span>f <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">func</span> <span class="token function">f2</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y <span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	fmt<span class="token punctuation">.</span>Println x<span class="token operator">+</span>y
<span class="token punctuation">}</span>

<span class="token comment">//想把f2传入f1中但模式不匹配，这时候要把f2包起来，把参数的接收分开来！f1(f2)</span>
<span class="token comment">//构建闭包函数f3，目标是返回一个能传入f1的函数，但是又要保留f2的参数</span>
<span class="token keyword">func</span> <span class="token function">f3</span><span class="token punctuation">(</span><span class="token function">f2</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">,</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">,</span>x<span class="token punctuation">,</span>y <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    temp <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">f2</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> temp
<span class="token punctuation">}</span>
<span class="token comment">// 传入目的f2，进行处理后得到能被f1接收的函数</span>
<span class="token comment">// f3老子帮你f2要处理的数据处理好，然后帮你构造好，以你需要的形式给你吐出来！！！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>





<h1 id="内置函数简介"><a href="#内置函数简介" class="headerlink" title="内置函数简介"></a>内置函数简介</h1><h2 id="panic和defer和recover-错误处理"><a href="#panic和defer和recover-错误处理" class="headerlink" title="panic和defer和recover(错误处理)"></a>panic和defer和recover(错误处理)</h2><ul>
<li>大致有<code>close len new make append panic recover</code></li>
<li>go语言中没有异常机制</li>
<li>panic直接让程序崩溃退出</li>
<li>防止程序占用资源可以用defer来解决panic , recover则可以尝试恢复错误</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">defer</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	err <span class="token operator">:=</span> <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"释放网络连接"</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token function">panic</span><span class="token punctuation">(</span><span class="token string">"出现了严重的错误。"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>recover会尝试着修复panic，跳过panic的部分然后往后走。recover尽量少用嗷呜！！！该panic还是要panic</p>
<ul>
<li>recover()一定要搭配defer使用，defer一定要在可以能会panic的语句之前调用</li>
</ul>
<h2 id="fmt标准库简介"><a href="#fmt标准库简介" class="headerlink" title="fmt标准库简介"></a>fmt标准库简介</h2><ul>
<li><p>fmt主要用于打印输出和获取输入的时候使用的嗷！</p>
</li>
<li><p><code>Print Printf Println</code> , <code>printf</code>用于格式化输出字符串</p>
</li>
<li><p>注意一下 <code>%T %v %#v %% %+v</code>等等（这几个是通用的，不管什么类型都可以用）</p>
</li>
<li><p><code>%t %p</code>等类似于布尔值，指针等类型</p>
</li>
<li><p><code>fmt.Scan fmt.Scanf fmt.Scanln</code></p>
</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> s <span class="token builtin">string</span>
fmt<span class="token punctuation">.</span><span class="token function">Scan</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span>

fmt<span class="token punctuation">.</span><span class="token function">Scanf</span><span class="token punctuation">(</span><span class="token string">"%s %d %s\n"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">,</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span>
<span class="token comment">// 扫描完换行</span>

fmt<span class="token punctuation">.</span><span class="token function">Scanln</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">,</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span>
<span class="token comment">//注意这里不能接收格式化的值嗷</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>Sprint 拼接</li>
</ul>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><ul>
<li>老递归了，乖娃子好家伙你差点整死你爹。</li>
<li>和别的语言差不多，找到规律和递归出口，节能写出来，没啥区别orz</li>
</ul>
<h1 id="自定义类型and类型别名"><a href="#自定义类型and类型别名" class="headerlink" title="自定义类型and类型别名"></a>自定义类型and类型别名</h1><ul>
<li>type是用来定义类型的</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> myInt <span class="token builtin">int</span>     <span class="token comment">//自定义类型</span>
<span class="token keyword">type</span> yourInt <span class="token operator">=</span> <span class="token builtin">int</span> <span class="token comment">//类型别名</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li>别名会使得默写情况下表达更加清晰（例如<code>rume</code>和<code>int32</code>）</li>
</ul>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><ul>
<li>定义一个结构体的方法：</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> 类型名 <span class="token keyword">struct</span><span class="token punctuation">{</span>
	body
<span class="token punctuation">}</span>

<span class="token keyword">var</span> varname 类型名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>打印输出的话是按顺序输出每个字段的值</p>
</li>
<li><p>匿名结构体：</p>
<ul>
<li>```go<br>var s = struct{<br>name string<br>age int<br>}<pre class="line-numbers language-none"><code class="language-none">
  - 临时使用的时候用的到。

  - 结构体要用花括号。

  - 这样也可以临时声明一个结构体并且返回给一个变量。

- 和c语言一样，函数是传值操作，结构体同样，如果要改变结构体中的变量的话，一样要传递结构体指针。

- 取得结构体的指针：

  - `var p2 = new(person)`(new直接返回对应类型的指针)
  - `%p`能够打印输出对应的指针的地址

  ```go
  fmt.Println("%p\n",&amp;a)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
<li><p>结构体初始化：</p>
<ul>
<li>直接声明结构体然后依次赋值</li>
</ul>
 <pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token function">person</span><span class="token punctuation">(</span>
    name<span class="token punctuation">:</span> <span class="token string">"rabbit"</span>
    age<span class="token punctuation">:</span> <span class="token number">19</span>
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>使用值列表（按照声明的顺序来初始化）进行初始化:</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">p <span class="token operator">:=</span> <span class="token function">person</span><span class="token punctuation">(</span>
	<span class="token string">"rabbit"</span>，
    <span class="token number">19</span>，
<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">  
- 结构体内的内存是连续的

- 可以设置一个构造函数来进行初始化也可以鸭

​```go
func newPerson(name string , age int) *Person{
	return &amp;person{
		name: name
		age: age
	}
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>注意哦，这里返回的是原构造函数中的一个拷贝之后的版本，当占用内存多的时候，可以考虑使用结构体指针。</li>
</ul>
<h2 id="结构体匿名字段"><a href="#结构体匿名字段" class="headerlink" title="结构体匿名字段"></a>结构体匿名字段</h2><ul>
<li><pre><code class="go">type person struct{
    string
    int
}//相同类型只能写一个
<pre class="line-numbers language-none"><code class="language-none">
- 适用于字段少，简单且不常用的情况

- 访问特定元素时，例如访问string，这个时候把string作为成员的名字，可以通过.名字直接进行访问。

## 嵌套嗷呜!

- 禁止套娃？（结构体套用结构体）

- ```go
  type address struct{
  	province string
      city string
  }
  
  type person struct{
      name string
      age int
      addr address
  }
  
  p1 := person{
      name : ""
      age : 
      addr: address{
          province: ""
          city: ""
      }
  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p>匿名嵌套结构体:(感觉很好用的样子嗷呜！！！)</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">type</span> person <span class="token keyword">struct</span><span class="token punctuation">{</span>
	province <span class="token builtin">string</span>
	city <span class="token builtin">string</span>
	address
<span class="token punctuation">}</span>


p1 <span class="token operator">:=</span> person<span class="token punctuation">{</span>
    name <span class="token punctuation">:</span> <span class="token string">""</span>
    age <span class="token punctuation">:</span> 
    address<span class="token punctuation">:</span> address<span class="token punctuation">{</span>
        province<span class="token punctuation">:</span> <span class="token string">""</span>
        city<span class="token punctuation">:</span> <span class="token string">""</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>这样之后就能够直接通过<code>p1.city</code>等方式访问内部元素</p>
<p>步过要注意，有可能产生匿名结构体的冲突，比如说几个都有city这个元素，嵌套一个可以，多个的话为了防止冲突最好不用。</p>
</li>
<li><p>构造结构体的函数，可以专门写一个构造函数<code>return struct</code>，然后每次调用这个构造函数就会十分的方便简单。</p>
</li>
</ul>
<h1 id="方法和接收者"><a href="#方法和接收者" class="headerlink" title="方法和接收者"></a>方法和接收者</h1><ul>
<li>有点像类的方法那种感觉啦(方法是作用于特定类型的函数)</li>
<li>声明: <code>func (d dng) wang()</code>，推荐用类型的首字母小写来声明这个类型的一个变量。</li>
<li>go语言中如果标识符首字母是大写的，就表示对外部包可见，类似于java中的public。</li>
<li>注意，如果函数的首字母大写对外可见，那么函数的返回值首字母也要大写，不然类型就不匹配。</li>
<li>对于这种标识符都应该加上注释</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token comment">//Dog 是一个关于狗的结构体</span>
<span class="token keyword">type</span> Dog <span class="token keyword">struct</span><span class="token punctuation">{</span>
	name <span class="token builtin">string</span>
<span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li><p>接收者只能有一个嗷呜</p>
</li>
<li><p>同时还是要注意函数传值传址嗷呜，就算是方法传址也才能改变对象的值。</p>
</li>
<li><p>使用指针传递内容的情况：</p>
<ul>
<li>需要修改接收者中的值</li>
<li>接收者是拷贝开销比较大的大对象</li>
<li>一致性，某个方法传入指针，最后其他的都一样传入指针。</li>
</ul>
</li>
<li><p>添加方法只能给自己定义的type添加方法，不能给别的包定义方法。比如说你想给int设置方法，是不可以的，但是你可以自己写一个对象为int，<code>type myInt int</code>这样构造一个然后再定义方法就可以。</p>
</li>
<li><p><code>var x int32 = 10</code>与<code>x := int32(10)</code>与<code>var a = myInt(100)</code>，这个东西是强制类型准换哈，这个不是方法函数。</p>
</li>
<li><pre><code class="go">s1 := map[string]int{
    "liu" : 5,
    "yi" : 10
    "hao" : 23
}
<pre class="line-numbers language-none"><code class="language-none">





# 结构体模拟实现继承

- 

```go
func animal struct{
	name string
}

func (a animal) move(){
    fmt.Println("唱跳rap篮球")
}

type dog struct{
	feet uint8
	animal
}

func (d dog) wang(){
	fmt.Printf("%s在叫：汪汪汪~",d.name)
}
//可以用dog调用animal方法
//可以用dog来调用animal属性<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p>dog中拥有了animal就相当于继承了animal</p>
</li>
</ul>
<h1 id="结构体与JSON"><a href="#结构体与JSON" class="headerlink" title="结构体与JSON"></a>结构体与JSON</h1><ul>
<li>把go语言中的结构体转换为json格式，并且把json格式能转回go语言</li>
<li><code>json.Marshal(struct)</code></li>
<li>格式化功能在json包里面做的，要在json包里拿到属性和字段，注意要用大写嗷。或者还有一种做法：</li>
<li>反引号引号起来就可以以自定义的名字访问</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">Name <span class="token builtin">string</span> 'json<span class="token punctuation">:</span><span class="token string">"name"</span> db<span class="token punctuation">:</span><span class="token string">"name"</span>'<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>反序列化: <code>json.Unmarshal(type,&amp;target)</code>（这里要是指针哦，得到了一个值然后传入要地址鸭！）</li>
<li>target为一个指针嗷呜！</li>
</ul>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><ul>
<li><p>接口是一种类型，和普通的类型没有差别，可以作为返回值啊等等等等。（面向接口编程的趋势）</p>
</li>
<li><p>应用场景： 给出一个模板，需要的类实现这个模板，规定了变量有哪些方法</p>
</li>
<li><pre><code class="go">type speaker interface{
    speak()  //只要实现了speak方法都是speaker类型
}

func (c cat) speak(){
    fmt.Println("miao~")
}

func da(x speaker){
    x.speak()
}
<pre class="line-numbers language-none"><code class="language-none">
- 只要实现了接口中规定的所有类型，那么这个变量就可以当作接口实现的类型的变量。

- 但你想到有多个对象有同一个方法的时候，就可用接口了，实现了接口就实现了方法。

- 甚至可以用接口变量来接收实现的接口,可以指向实现的接口。

- 多个类型可以实现一个接口，一个类型也可以实现多个接口。

- 接口可以嵌套！

## 使用值和指针接收者不同嗷

- 实现值接收者，结构体和结构体指针的变量都能存。
- 实现指针接收者，只能拿存结构体类型的变量。
- 用指针接收者往往更加常用嗷！

## 空接口

- `type xx interface{}`

- 接口中啥都没有，意味着所有类型都实现了这个接口，意味着这个接口能接收所有的对象。（有点像Object?）

- 空接口没有必要起名

- ```go
  m1 := map[string]interface{}
  m1 = make(map[string]interface{},10)
  m1["hobby"] = [...]string{"a","b"}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p>相当于多种类型的集合！！！传入啥类型都可以！！！</p>
</li>
<li><p>类型断言： </p>
<ul>
<li><p>```go<br>a.(type)</p>
<p>func assign(a interface{}){<br>switch v := a.(type){<br>    case string:<br>        body1<br>    case int:<br>        body2<br>    case bool:<br>        body3<br>    default:<br>        body4<br>}<br>}// switch a.(type){}也可以</p>
<pre class="line-numbers language-none"><code class="language-none">
  - int64与int是两个完全不同的类型

# package



- 组织go语言的一个单位。

- 只有main包才能组织成一个文件。
- 只有大写的元素和函数才能被跨包访问，小写表示私有。
- 导入的包名应该紧接在package后面。
- 禁止套娃，不能相互嵌套。
- `import 别名 "包的路径"`。
- 匿名导入包 `import _ "路径"`。
- 导入会自动触发init()函数，当import恶的时候会自动调用。
- init在导入的全局声明和main之间执行。
- 从外往里调用import本质上是从里往外调用`init()`方法。





# 文件操作(日志库作业)

- 接口：不同的模式对应的文件操作不一样，可以输出到终端和文件中

## 打开/关闭文件

- ```go
  // 打开文件
  fileObj,ok := os.Open("./main.go")// 返回一个文件指针，可以用绝对路径
  if ok != nil{
      fmt.Printf("Open file failed , err:%v",err)
      return
  }
  defer fileObj.close()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
</li>
</ul>
<h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><h3 id="读文件："><a href="#读文件：" class="headerlink" title="读文件："></a>读文件：</h3><ul>
<li><pre><code class="go">var temp = make([]byte,128) //指定读的长度
// 或者是:var temp = [128]byte
n , error = fileObj.Read(temp[:])// 一次读128个进入切片(n是读入的数，error是出的问题)
if error != nil{
    body
}
fmt.Println(string(temp[:n]))读取文件需要一个切片作为参数，先构造切片，然后读入切片中即可
<pre class="line-numbers language-none"><code class="language-none">
- `bufio`读取文件（一样要先`os`打开文件）

```go
reader := bufio.NewReader(fileObj)//创建对象
line , err := reader.ReadnString('\n')
if err == io.EOF{
    return
}
if err != nil{
    body
}
// 这里可以从reader中选择读取方式并返回<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p><code>ioutil</code>读取文件：</p>
<ul>
<li><code>ret , err := ioutil.ReadFile(Filename)</code>直接读取整个文件 , 这里readfile后买你的参数直接接的就是文件，不需要像上面一样先打开文件哦。</li>
</ul>
</li>
</ul>
<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件:"></a>写文件:</h3><ul>
<li>```go<br>os.OpenFile(name,flag,mode)//打开文件的模式<pre class="line-numbers language-none"><code class="language-none">
- 这里的flag本质上为十六进制数（其实底层为二进制），可以指定多种状态`os.O_APPEND|os.O_CREATE `， 可用二进制中的"|"来表示，本质为二进制的位运算来确定模式。哪一位为1 ， 代表着激活了那种模式。

- 用`fileObj.write(切片)`和`fileObj.WriteString(sting)`可以写入文件

- 注意哈，文件开完了之后要关上的！

- 默认好多模式嗷，对着模式去选择就好啦

- 和上面读文件一样，这里需要写文件也有三种方式

```go
bufio.NewWriter(fileObj)
wr.WriteString("...")
wr.Flush() // 将缓存中的内容写入文件中<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">err := ioutil.WriteFile(filename,[]byte(str),0666)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>注意, Scanln只要读到空白符就停止了，如果想读入空白符怎么做？</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> s <span class="token builtin">string</span>
reader <span class="token operator">:=</span> bufio<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>os<span class="token punctuation">.</span>Stdin<span class="token punctuation">)</span>
s<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">=</span> reader<span class="token punctuation">.</span><span class="token function">ReadString</span><span class="token punctuation">(</span><span class="token char">'\n'</span><span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"..."</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>bufio.Reader本质上为一个接口类型</li>
</ul>
<h2 id="文件中间插入内容"><a href="#文件中间插入内容" class="headerlink" title="文件中间插入内容"></a>文件中间插入内容</h2><ul>
<li>原理用脑子想一想</li>
<li>可以在库中找到对应的方法嗷呜！</li>
<li>可以用fileObj.seek(跨过的长度，文件的初始位置)，光标移动到要插入内容的位置。</li>
<li><code>os.O_RDWR</code>设置文件可读可写，然后借助seek定位</li>
<li>再向文件中写入内容即可</li>
<li>切片不能用new初始化哦</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">var</span> s <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span>
s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">{</span><span class="token char">'c'</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<ul>
<li>新写的内容会覆盖原有的内容哦</li>
<li>要实现插入内容，一般都要新建中间文件，在中间文件中实现之后再导入到目标文件中。（读入之前的，插入目的数，紧接后面的）</li>
<li>文件关了之后再操作哦，比如可以把中间文件重命名为我要的目的文件即可，把以前的文件直接覆盖哦。</li>
</ul>
<h1 id="time标准库"><a href="#time标准库" class="headerlink" title="time标准库"></a>time标准库</h1><ul>
<li>常用函数: <code>time.Now()/Year()/Date()/Hour()/Minute()/Second()/Day()</code></li>
<li>时间戳: <code>.Unix()或者是.UnixNano()</code>,从1970年一月一日到现在的时间</li>
<li>时间间隔：</li>
</ul>
<p><code>.Second</code>啊等等属性</p>
<ul>
<li>一些操作：<ul>
<li>.Add   e.g.  <code>now.Add(24 * time.Hour)</code></li>
<li>.Sub</li>
<li>.Equal</li>
<li>.Before</li>
<li>.After</li>
</ul>
</li>
<li>定时器</li>
</ul>
<p><code>timer := time.Tick(time.Second)</code> // 每隔一秒钟执行一次</p>
<ul>
<li><p>时间格式化：</p>
<ul>
<li><p>2006 1 2 3 4 5   这个是go诞生的时间，用于格式化时间</p>
</li>
<li><pre><code class="go">fmt.Println(now.Format("2006-01-02"))
<pre class="line-numbers language-none"><code class="language-none">
- ```go
  fmt.Println(now.Format("2006/01/02 15:04:05"))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><pre><code class="go">fmt.Println(now.Format("2006/01/02 15:04:05 PM"))
<pre class="line-numbers language-none"><code class="language-none">
- ```
  fmt.Println(now.Format("2006/01/02 15:04:05.000"))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p><code>.Parse</code>函数用于格式化把字符串转换为时间</p>
</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">time <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token string">"2006-01-02 15:04:05"</span><span class="token punctuation">,</span><span class="token string">"2020-10-27 19:12:39"</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li>
</ul>
<h2 id="time库的补充内容"><a href="#time库的补充内容" class="headerlink" title="time库的补充内容"></a>time库的补充内容</h2><ul>
<li>一些标准化的内容:</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">Microsecond
Millisecond
Second
Minute
Hour     <span class="token comment">//这些都是定义好的标准时间嗷！</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>Sub函数的调用:</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">nextYear <span class="token punctuation">,</span> err <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">Parse</span><span class="token punctuation">(</span><span class="token string">"2006-01-02,2020-01-01"</span><span class="token punctuation">)</span>

now<span class="token punctuation">.</span><span class="token function">Sub</span><span class="token punctuation">(</span>nextYear<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>注意，这里减的是一个时间对象嗷，不是减去时间。</p>
<ul>
<li><p>时区指定</p>
</li>
<li><p><code>sleep(d duration)</code>(本质为int64)</p>
</li>
<li><pre><code class="go">n := 100
time.Sleep(time.Duration(n))

time.Sleep(100)
<pre class="line-numbers language-none"><code class="language-none">
如果直接传入参数，直接帮你传。如果用变量则需要手动住那换一样嗷！！！

- ```go
  n := 5
  time.Sleep(time.Duration(n)*time.Second)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p>时区的确定和转换:</p>
</li>
</ul>
<p><code>Parse</code>这个玩意没有时区的概念，就是标准时间，不是东八区的时间，这个时候就要获取时区。</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">loc <span class="token punctuation">,</span> err <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">LoadLocation</span><span class="token punctuation">(</span><span class="token string">"Asia/Shanghai"</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span><span class="token punctuation">{</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Load loc failed, err:%v\n"</span><span class="token punctuation">,</span>err<span class="token punctuation">)</span>
    <span class="token keyword">return</span>
<span class="token punctuation">}</span>

timeObj <span class="token punctuation">,</span> err <span class="token operator">:=</span> time<span class="token punctuation">.</span><span class="token function">ParseInLoaction</span><span class="token punctuation">(</span><span class="token string">"2006-01-02 15:04:05"</span><span class="token punctuation">,</span><span class="token string">"2019-08-04 14:41:50"</span><span class="token punctuation">,</span>loc<span class="token punctuation">)</span>

fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Obj<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>只有在时区相同的情况下做加减计算才有意义啊！</p>
<h1 id="runtime-Caller"><a href="#runtime-Caller" class="headerlink" title="runtime.Caller"></a><code>runtime.Caller</code></h1><ul>
<li><p>```go<br>pc , file , line , ok := runtime.Caller(0)</p>
<p>if !ok{<br>body<br>}</p>
<p>// 这里的0表示调用层数，0表示调用函数的第一层，1就表示调用函数的第二层（由内往外找层数）。<br>// file表示调用的文件名 , line表示调用的函数所在的行，ok表示时候调用成功</p>
</li>
</ul>
<p>funcname := runtime.FuncForPC(pc).Name()<br>  //拿到对应层的函数名<br>  path.Base(file)<br>  //拿到对应的文件名<br>  </p><pre class="line-numbers language-none"><code class="language-none">  
- 这就是一个库能够拿到调用它的函数对应的行，还有函数名等等，比如在日志库中有相应的应用





# 反射

- 用的少但是原理要知道

- ```go
  func reflectType(x interface{}){
      v := reflect.TypeOf(x)
      name := v.Name()
      kind := v.Kind()
  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p>
<ul>
<li><pre><code class="go">v := reflect.ValueOf(x)
v.Kind() // 值的类型种类
v.Int() / v.Float()
reflect.Int64 / reflect.Float32
// 这里取了一个v作为value的种类,它可以去和reflect下的值比较，但是调用的时候，只有第三行两种形式，如果需要int64 , 还需要int64(v.Int())这种方式强制类型转换。
<pre class="line-numbers language-none"><code class="language-none">
- 通过反射设置变量的值，一样要用指针

```go
func reflectSetValue(x interface{}){
	v := reflect.ValueOf(x)
    if v.Elem().kind() == reflect.Int64{
		v.Elem().SetInt(200)
	}
}
// 这里的x要是指针<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p>还有类似的函数 : <code>isNil() , isValid()</code></p>
</li>
</ul>
<pre class="line-numbers language-none"><code class="language-none">reflect.ValueOf(a).isValid()<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ul>
<li>结构体指针</li>
</ul>
<h1 id="strconv标准库简介"><a href="#strconv标准库简介" class="headerlink" title="strconv标准库简介"></a>strconv标准库简介</h1><ul>
<li>用于类型转换，有的时候不能进行强制类型转换</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">ret2 <span class="token operator">:=</span> <span class="token function">string</span><span class="token punctuation">(</span><span class="token number">97</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这里就是把97转换为对应的char类型，就有问题</p>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token number">97</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>这里返回一个字符串嗷，可以获得数字对应的字符串</p>
<ul>
<li><pre><code class="go">fmt.ParseInt(str,10,64)
<pre class="line-numbers language-none"><code class="language-none">
这里表示把str转换为十进制六十四位 , 如果传入的是0的话就变成int

- `strconv.Atoi()`字符串转换为int类型可以直接用这个
- `strconv.Itoa()`int类型转换为字符串
- `boolValue , _ := strconv.ParseBool(boolstr)`
- `.ParseFloat()`

# 并发

## goroutine

- ```go
  func hello(){
  	fmt.Println("hello")
  }
  
  func main(){
      go hello()
      time.Sleep(time.Second)
      fmt.Println("main")
  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p>传入go的要是一个包装好的函数哦</p>
</li>
<li><p>main函数结束了，它生成的所有线程都会结束</p>
</li>
<li><p>见<code>vscode</code>中的例子有更加深入的理解哦</p>
</li>
</ul>
<h3 id="关于goroutine的一些底层的知识"><a href="#关于goroutine的一些底层的知识" class="headerlink" title="关于goroutine的一些底层的知识"></a>关于goroutine的一些底层的知识</h3><ul>
<li>goroutine和线程:<ul>
<li>goroutine和os线程的栈内存不一样，goroutine内存很小，但是可以扩容。（可扩展的栈）</li>
<li>GMP调度 ， g为goroutine的，存了goroutine信息和与P绑定的信息，这里p管理一组goroutine队列，为队列做调度，保证最大效率的利用goroutine队列。m是go运行时对于操作系统内核线程的虚拟，是一一映射的关系，一个goroutine最终是要放在M上执行的。p和m也一般是一一对应的</li>
<li>goroutine初始栈的大小是2k.</li>
</ul>
</li>
</ul>
<h2 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h2><ul>
<li>goroutine对应的函数执行结束的时候，goroutine就结束了。</li>
<li>main函数结束了，main函数创建的goroutine就都结束了</li>
</ul>
<p>那么怎么样协调时间呢？</p>
<h3 id="如何优雅的等其它线程结束"><a href="#如何优雅的等其它线程结束" class="headerlink" title="如何优雅的等其它线程结束"></a>如何优雅的等其它线程结束</h3><ul>
<li><code>var wg sync.WaitGroup</code></li>
<li>只能有一个这种计数器，不能有多个。只有当计数器为0的时候，main函数才能退出</li>
<li>在每一个线程中: <code>wg.Add(1)</code> ， 当一个线程结束了之后，wg才会减一。<code>wg.Done()</code>，在线程结束的时候添加，推荐在线程执行的函数中第一行用<code>defer wg.Done()</code>。</li>
<li>每一个线程开始时，Add记录一下，结束时Done()删除一下。</li>
<li>函数的最后要用<code>wg.Wait()</code></li>
</ul>
<h3 id="math-x2F-rand"><a href="#math-x2F-rand" class="headerlink" title="math/rand"></a>math/rand</h3><ul>
<li><pre><code class="go">rand.Seed()
rand.Int()
rand.Intn(n)//生成一个[0，n)之间的整数
<pre class="line-numbers language-none"><code class="language-none">
- 在go里面编译好了之后，种子就固定了，如果想每次生成的不一样，那么要在函数中设置种子并且传入不同的值，比如时间。（注意这里和c语言不同哦。）

- 默认生成的都是正数，如果需要负数的话`0-rand.Int()`类似于这样即可

- .Sleep接受的是duration类型  time.Sleep(time.Millisecond * time.Duration(rand.Intn(300)))这样返回的就是Duration类型，可以这么转换整数为duration.

## `runtime.GOMAXPROCS`

- 设置处理的cpu的数量，如果作为日志监控等可以占用的少一点
- `runtime.NumCPU()`返回使用的CPU的个数
- 一个线程对应多个goroutine
- 一个程序可以使用多个操作系统线程
- goroutine和os线程时多对多的关系,  m:n , 把m个goroutine分配个n个操作系统线程去执行



# Channel(通道)

### 初始化

- 共享内存进行数据交换时，可能发生问题，这个时候就应该加锁，要改成通过通信来共享内存。goroutine是go程序并发的执行体，channel就是他们之间的连接。channel是可以让一个goroutine发送到另外一个goroutine的通信机制。
- `var 变量 chan 元素类型`，channel是一种特殊的类型，本质为一个队列，遵循First in first out的规则。
- 通道的初始化   `b = make(chan int)`
- 通道必须初始化才能使用
- `var ch3 chan []int` 声明一个传递int切片的通道
- `make(chan 元素类型，[缓冲大小])` 含有带有缓冲区的通道的初始化 , 缓冲区如果不存在的话，无法向里面传递信息，因为无位置接收。
- 通道里面的类型小一点好，如果大的话，用指针会好哦。

### 发送与接收

- `ch &lt;- 10`
- `x := &lt;- ch `
- 可以跨越线程进行值的输入与输出
- 只有`b&lt;-`，如果b没有缓冲区，则无法成功输入，如果`x := &lt;-b`，b中还没有值，则程序会等待b的输入
- 通道的关闭 : `close(channel)` ， 不关也没问题的
- `for i := range ch1{}` 这个也是作用于通道
- 关闭通道后不可以往通道里面再写数据，但是可以从通道里面读数据。往线程里写完数据之后还是最好, close(线程)这样来保证线程的安全。

### 单向通道

- 只能读入或者输出，常用于一些函数，限制通道的功能(当通道只能进行某一些操作时)
- `func f1(ch1 &lt;-chan int) || func f2(ch2 chan&lt;- int)`

### 数据读取

- ```go
  for{
  	x , ok := &lt;-channel
  	if !ok{
  		break;
  	}
  	else{
  		fmt.Println(x)
  	}
  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p>这里如果channel为空，会等待，直到channel中没有值才会退出</p>
</li>
<li><p>什么时候ok是false , 直到通道close掉，这个才为false,所以要人为去close掉通道，才能退出！</p>
</li>
<li><p>for , range是一样的，会等待通道内的值，只有通道关闭才会退出循环，所以在程序中要记得close嗷！</p>
</li>
</ul>
<h3 id="其它的一些操作"><a href="#其它的一些操作" class="headerlink" title="其它的一些操作"></a>其它的一些操作</h3><ul>
<li><code>var once sync.Once</code>然后<code>once.Do(func(){...})</code>这样就可以使得某一段函数只执行一次，例如多个容器接收，一次关闭某个特定的通道</li>
<li>关于关闭的通道可以继续读取通道，当读取完元素之后依旧可以继续读取，读取的是对应类型的零值。</li>
<li>通道由两个返回值，一个是真正的返回值，第二个是true或者false即是否读取到了值，就算ok为false，一样可以读取到对应的返回值。</li>
</ul>
<h3 id="通道的状态"><a href="#通道的状态" class="headerlink" title="通道的状态"></a>通道的状态</h3><p>![image-20201105184844101](C:\Users\Alexander Liu\AppData\Roaming\Typora\typora-user-images\image-20201105184844101.png)</p>
<ul>
<li>关闭已经关闭的channel就会panic</li>
<li>如果所有的goroutine都在等一个阻塞的channel这个时候程序会发生死锁。</li>
<li>goroutine的泄露，如果后台在等一个阻塞的channel，主程序能够运行，这个时候可以正常运行，但是后台goroutine占着一块儿内存始终不会释放，这个时候造成了goroutine的泄露。</li>
</ul>
<h3 id="匿名结构体计数通道"><a href="#匿名结构体计数通道" class="headerlink" title="匿名结构体计数通道"></a>匿名结构体计数通道</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go">notifyCh  <span class="token operator">&lt;-</span>  <span class="token keyword">struct</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">//不占任何内存，构造出来用于记录数量</span>
	
<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">for</span> i<span class="token operator">:=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span><span class="token number">5</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">{</span>
        <span class="token operator">&lt;-</span>notifyCh
    <span class="token punctuation">}</span>
    <span class="token function">close</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>如果能取到5个值，说明这个通道里面目的数据量都被传满了，这个时候就可以去取真实的值了。这这个线程也会一直等着，直到目标容量被存满之后，才会关闭对应的通道。非常非常有用。</li>
</ul>
<h1 id="select多路复用"><a href="#select多路复用" class="headerlink" title="select多路复用"></a>select多路复用</h1><ul>
<li><pre><code class="go">select{
    case &lt;-ch1:
    
    case data := &lt;-ch2:
    
    case ch3&lt;-data:
    
    default:
}
<pre class="line-numbers language-none"><code class="language-none">
- 哪个能成走哪个，若多个能走从中随便选一个嗷。

- 空的select可以用于阻塞main函数，程序会运行到这里然后一直等哦

# Channel重大发现嗷

- 当多个任务无法区分时，可以用多个线程分别执行，思考之间的关系，在主程序中去进行wait和close之类的操作，可以很好的解决通道的问题！！！





# sync包中的互斥锁

- 实现了对于公共空间的元素的访问的操作,对于公共资源的操作和访问时，就先加锁。
- `var lock sync.Mutex`and`lock.Lock()`and`lock.Unlock()`

## 读写互斥锁

- 用于读的次数远大与写的次数
- 分为读锁和写锁两个锁，读锁的时候可以继续获取，写锁的时候别的锁就要先等一等。
- `sync.RWMutex`



# sync.Once

- `.Do(func())`只做一次，once.Do()保证了某个函数仅仅执行一次，要求函数苛刻，传入的函数要求没有参数也没有返回值，因此这个时候，可能会使用到函数闭包。

`f := func(){close(channel)}`



# sync.Map

- Go内置的map不是并发安全的
- 这个时候自己可以加锁嘛，go内置了一些开箱即用的map - `sync.Map`，定义了一些Store和Load等方法

- 开箱即用意味着map不用初始化

```go
var m2 = sync.Map{}
var wg sync.Waitgroup

func main(){
    for i:=0;i&lt;21;i++{
        wg.Add(1)
        go func(n int){
            key := strconv.Itoa(n)
            m2.Store(key, n)
            value,_ := m2.Load(key)
            wg.Done()
        }(i)
    }
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p>必须使用sync.map内部自带的Store来存值，用Load来取值，用特定的方法来取值。</p>
</li>
</ul>
<h1 id="atomic原子性操作"><a href="#atomic原子性操作" class="headerlink" title="atomic原子性操作"></a>atomic原子性操作</h1><ul>
<li><p>原子性操作自动帮你加锁，去锁。</p>
</li>
<li><pre><code class="go">func main(){
    atomic.AddInt64(&amp;x,1)
}
//内置的加法函数
<pre class="line-numbers language-none"><code class="language-none">
- 有一系列的相关操作来保证功能的实现。





# 网络编程

## 协议和层

- 物理层：把电脑连接起来的物理手段，传送0，1信号
- 数据链路层：规定解读电信号的方式，“以太网”协议占据主导，然后将数据分为帧发送。以太网规定了网卡接口有唯一的地址，就可以确定某一个网卡。
- 网络层：网络地址和MAC协议，IPv4和IPv6两个协议，最多发65535个字节
- 传输层：通过MAC地址和IP地址，可以建立通信，还有一个参数叫端口，确定是电脑哪个程序，上述三个确定了唯一一个电脑上的某个程序。TCP和UCP两种，三次握手，四次挥手等等orz , 时效性高用UCP , TCP则保证数据的稳定性
- 应用层：建立在传输层之上，不停的加上不同的协议，最后得到一个物理层的传输数据。



## socket编程

- TCP/IP都要用到socket , socket是一个抽象层，处于传输层和应用层之间。
- 一个TCP连接多个客户端，go中的并发性高
- TCP处理流程：
  - 监听端口
  - 接收客户端请求建立来凝结
  - 创建goroutine处理链接







# os.Args

- 获取命令行参数
- 可以以os.Args[num]的方式获取某个输入参数

# Flag

- 创建一个标志位参数

`name := flag.String("name","ask","b")`,这个时候的name时一个指针，指向某个分配了位置的内存地址。

- 可以通过`--help`来体现到底有哪些方法

- ```go
  name := flag.String("name","ask","Enter your name")
  flag.Parse()
  fmt.Println(*name)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p><code>age := flag.Int("age",18,"请输入真实姓名")</code></p>
</li>
<li><p>有Int , Sting ,Bool ,Duration等方法，这些方法都用于构造某个标志位，可以返回一个指针，通过特定的指针访问某个用户输入的特定的属性。</p>
</li>
<li><p><code>flag.exe -name=兔子姐姐 -age=10000</code>这样即为用户端输入。</p>
</li>
<li><p><code>var name string</code> , <code>flag.StringVar(&amp;name,"name","ask","Enter your name")</code></p>
</li>
</ul>
<p>这种方式也可以，并且不用执政，得到的就是纯纯的变量本身嗷。</p>
<ul>
<li><code>flag.Args() , flag.NArg() , flag.NFlag()</code></li>
<li>第一个时返回[]string参数，返回命令行后面其它参数；第二个时返回其它参数的个数，第三个时返回命令行参数的个数</li>
</ul>
<h1 id="TCP粘包"><a href="#TCP粘包" class="headerlink" title="TCP粘包"></a>TCP粘包</h1><ul>
<li>传送数据的时候，可能会同时发送多个数据</li>
<li>如果发送的时间间隔长的话，一次就只会发送一个数据</li>
<li>可以自己定义协议来定义包头和长度</li>
<li>详情参见代码</li>
</ul>
<h1 id="net-http"><a href="#net-http" class="headerlink" title="net/http"></a><code>net/http</code></h1><ul>
<li>首先这个包写的非常好，可以直接用来写一些小型的服务端</li>
<li>和前端的知识有的融合在一起了，<code>HandleFunc(request,func)</code>可以获得对应字段进行数据处理，读取对应的页面文件和CSS文件并传输给服务端。详情参见vscode中的例子</li>
<li><code>ListenAndServe</code>函数可以用于监听某一个端口号，作为服务端等待客户端向其发送的请求</li>
<li><code>http-client</code>中，url的构建可以采用，新建一个<code>url.Values{}</code>，然后再再不断地set元素的值，最后采用<code>urlStr = data.Encode()</code>，这个时候再去get就可以使用<code>http.NewRequest("GET",urlStr,nil)</code>这个方式来获得新的url。下面为构建url对象：</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go">apiUrl <span class="token operator">:=</span> <span class="token string">"http://127.0.0.1:9090/get"</span>

data <span class="token operator">:=</span> url<span class="token punctuation">.</span>Values<span class="token punctuation">{</span><span class="token punctuation">}</span>
data<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"name"</span><span class="token punctuation">,</span><span class="token string">"小王子"</span><span class="token punctuation">)</span>
data<span class="token punctuation">.</span><span class="token function">Set</span><span class="token punctuation">(</span><span class="token string">"age"</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">)</span>
urlObj <span class="token punctuation">,</span> err <span class="token operator">:=</span> url<span class="token punctuation">.</span><span class="token function">ParseRequestURL</span><span class="token punctuation">(</span>apiUrl<span class="token punctuation">)</span>

queryStr <span class="token operator">:=</span> data<span class="token punctuation">.</span><span class="token function">Encode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
urlObj<span class="token punctuation">.</span>RawQuery <span class="token operator">=</span> queryStr
req <span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> http<span class="token punctuation">.</span><span class="token function">NewRequest</span><span class="token punctuation">(</span><span class="token string">"GET"</span><span class="token punctuation">,</span> urlObj<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token boolean">nil</span><span class="token punctuation">)</span>

http<span class="token punctuation">.</span>DefaultClient<span class="token punctuation">.</span><span class="token function">Do</span><span class="token punctuation">(</span>req<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ul>
<li>上述为个性请求的定制</li>
<li>response读取完成之后记得要关闭</li>
<li>后端发请求频繁的时候，可以考虑公用一个Client，这个时候可以通过声明全局变量的形式来操作，可以通过var把关键字提前到最前面，然后剪辑出来，让其保证长连接,<code>DisableKeepAlives: false</code>。</li>
<li>拉起的频率的非常低时，就应该禁用长连接，上面那个设置为true，用完client后马上进行释放，就会非常方便。</li>
</ul>
<h1 id="Context单元测试和pprof调试工具"><a href="#Context单元测试和pprof调试工具" class="headerlink" title="Context单元测试和pprof调试工具"></a>Context单元测试和pprof调试工具</h1><h2 id="go语言中单元测试"><a href="#go语言中单元测试" class="headerlink" title="go语言中单元测试"></a>go语言中单元测试</h2><ul>
<li><code>go test</code>命令</li>
<li>每个函数必须导入test包，文件必须以_test.go命名，测试函数必须以Test开头，后缀就是特定的函数名，大写开头，写法如下:</li>
<li><code>func TestName(t *testing.T)</code></li>
<li>可以看一看测试组，有’Run’这种函数可以有很多花哨的操作</li>
<li>可以通过<code>go test -cover</code>来查看覆盖率，甚至可以生成覆盖率的文件，通过go语言中的tool工具再浏览器中打开查看，画面很炫酷</li>
<li>一般情况下各个函数模块的测试覆盖率要达到100% , 整体覆盖率要达到60%</li>
</ul>
<h2 id="go语言中的基准测试"><a href="#go语言中的基准测试" class="headerlink" title="go语言中的基准测试"></a>go语言中的基准测试</h2><ul>
<li><p><code>func BenchmarkName()</code></p>
</li>
<li><p>执行时使用<code>go test -bench=Split</code></p>
</li>
<li><p>要用循环反复执行一个函数来进行操作效率分析</p>
</li>
<li><p>具体的例如基准测试使用的proxy的量，都可以找到对应的博客来操作对应的值。</p>
</li>
<li><pre><code class="go">func BenchmarkSplit(b *testing.B){
    for i:=0;i&lt;b.N;i++{
        Split("A:B:C",":")
    }
}
<pre class="line-numbers language-none"><code class="language-none">
- 上述就是一个测试的例子，可以通过结果来分析各个值，然后再次去优化代码。例如内存申请的次数等会影响到代码的效率。

### 性能比较函数

- 例如斐波那契数列
- 可以通过封装函数来实现多次跑一个函数来达到目的，传入的参数可以为`b *testing.B , int n`，第二个参数是执行特定函数的次数。
- b.N是循环的次数，不要传入函数中，是错误的用法。是一个随着函数和执行次数在该改变的变量。
- 默认情况下，每个基准测试最少运行一秒，若没有到疫苗，b.N的值会1，2，5，10，20...这样一直增加，并且函数可以继续运行。
- 可以用`-benchtime`来获得标志增加的最小基准时间，还有其它类似的用法等等。
- 还可以并行测试，指定CPU的数量之类的。

### setup和teardown等专业工具

- setup和teardown函数，一个是初始化操作，一个是结尾首位操作

## go语言中的示例函数

- 以ExampleName这种形式开头，可以自动产生文档嗷！
- 具体的在单元测试这一章的网上是有的。
- go语言可以自动拉一个文档出来，骚得很。



## pprof工具的使用(go性能调优)

- aspects: CPU profile , Memory , block , goroutine
- `runtime/pprof` , `net/http/pprof`等运行时数据进行分析
- 只有在代码测试优化时才进行调用
- `isCPUPprof , isMemPprof`是否开启标志位

![image-20201201220143773](C:\Users\Alexander Liu\AppData\Roaming\Typora\typora-user-images\image-20201201220143773.png)

- 上述往文件中写入对应的信息

- 结合flag包判断是否开启性能检测

```go
var isCPUPprof bool

flag.BoolVar(&amp;isCPUPprof,"cpu",false,"turn cpu pprof on")
flag.Parse()

if isCPUPprof{
	file, err := os.Create("./cpu.pprof")
	if err != nil{
		fmt.Printf("create cpu failed , err: 			%v\n",err)
		return
	}
	pprof.StartCPUPprof(file)
	defer func(){
		pprof.StopCPUProfile()
		file.Close()
	}()
}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
</code></pre>
</li>
<li><p>对于模型进行分析的时候，命令行:<code>xx.exe -cpu=true</code>，三十秒后就会自动生成相关的文件</p>
</li>
<li><p><code>go tool pprof xx.pprof</code>可以使用内置的go工具对于特定的值进行分析。进入交互界面后，输入top3或者top4就可以查看占用cpu最多的几个东东，这些东东可以帮助你了解自己函数的性能，从而进行优化！(quit可以退出交换界面嗷！)</p>
</li>
<li><p>还有<code>go-torch</code>等操作使得图特别选炫酷，可以看blog去看看怎么去操作那些东西。</p>
</li>
</ul>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><ul>
<li><p>用<code>MySQL</code></p>
</li>
<li><p><code>DDL,DML,DCL</code>之类的</p>
</li>
<li><p>支持插件式的搜索引擎。常见的有:<code>MyISAM</code>和<code>InnoDB</code></p>
<ul>
<li>MyISAM:</li>
</ul>
<ol>
<li>查询速度快</li>
<li>只支持表锁</li>
<li>不支持事务</li>
</ol>
<ul>
<li>InnoDB:</li>
</ul>
<ol>
<li>整体速度快</li>
<li>支持表锁和行锁</li>
<li>支持事务</li>
</ol>
<ul>
<li><p>事务：把多个SQL操作当成一个整体</p>
</li>
<li><p>ACID:</p>
</li>
</ul>
<ol>
<li>原子性：只有成功或者失败</li>
<li>一致性</li>
<li>隔离性：事务之间相互独立</li>
<li>持久性：事务操作结果不会丢失</li>
</ol>
</li>
<li><p>关系型数据库：用表来存放一类的数据</p>
</li>
<li><p>《漫画数据库》可以康康嗷！</p>
</li>
<li><p>隔离的四个级别：Read uncommitted , read committed , repeatable read , serializable</p>
</li>
<li><p>索引的原理： B5树和B+树</p>
</li>
<li><p>MySQL主从：</p>
<ul>
<li>binlog，把某个</li>
</ul>
</li>
<li><p>读写分离：从从库里面读，往主库里面写</p>
</li>
</ul>
<h1 id="Go对于MySQL的操作"><a href="#Go对于MySQL的操作" class="headerlink" title="Go对于MySQL的操作"></a>Go对于MySQL的操作</h1><h2 id="连接数据库："><a href="#连接数据库：" class="headerlink" title="连接数据库："></a>连接数据库：</h2><ul>
<li><p>database/sql ，这个库并没有具体实现，不提供数据库驱动，因此要装第三方的驱动。</p>
</li>
<li><img src="C:\Users\Alexander Liu\AppData\Roaming\Typora\typora-user-images\image-20201207163310289.png" alt="image-20201207163310289" style="zoom: 200%;">
</li>
<li><p>```bash<br>go get -u github.com/go-sql-driver/mysql</p>
<pre class="line-numbers language-none"><code class="language-none">
下载依赖管理

## 读取某一行的数据：

![image-20201207172109804](C:\Users\Alexander Liu\AppData\Roaming\Typora\typora-user-images\image-20201207172109804.png)

- 必须对于`rowobj`调用scan方法，这样才能释放链接，不然就会一直占有连接资源。

- `SetMaxOpenConns`可以设置与数据库连接的最大数目
- `SetMaxIdleConn`设置连接池中的最大闲置连接数
- `db.QueryRow(sqlStr, 2).Scan(&amp;u1.id, &amp;u1.name, &amp;u1.age) *//从连接池拿出一个连接去数据库查询数据*`高级写法

- 不要用:=去处理db，db这里是一个全局变量，要对于全局db进行处理。

## 增删改查：

详情看相关的go代码嗷！ 

## 数据预处理

- sql语句分开成为命令部分和数据部分，先把命令部分发送非服务端，然后数据给服务端进行替换。
- reason: 让服务器提前编译，一次白你要多次执行，时间花费少，以及避免用户输入恶意数据这种情况的发生。

## go语言实现事务

- 两个或者多个操作揉成一个整体
- `Begin(*Tx, error) Commit Rollback()`这三个来实现
- 只要有错误就回滚
- 相当于多个事务打包一起，除了问题就回退，保证表原来的状态，只有所有过程都没问题才能正常更新表嗷！！！

## sqlx的使用

- [具体使用方法](https://www.liwenzhou.com/posts/Go/sqlx/)

- 注意，这里的get方法用到了反射，取了指针，所以变量定义的时候要是大写，才能够被别的包的reflect检索到。
- 注意传递指针注意注意注意嗷！
- 不同的数据库占位符是不一样的。

## sql注入



# GO MODULE

- go mod init
- go get
- go env

# Context

- 非常重要:
  - 如何优雅控制子goroutine退出？
    - 可以和C语言中一样，去中间break一下就退出了。
    - `var exitChan chan bool`， 然后用select去检查channel中有没有值，这样来控制退出。
    - `ctx , cancel := context.WithCancel(context.Background)`
    
    完整版:
    
    ```go
    func f(ctx context.Context){
    	def wg.Done
        FORLOOP:
        for{
            fmt.Println("退出")
            time.Sleep(time.Millisecond * 500)
            select{
                case &lt;- ctx.Done():
                	break FORLOOP
            	default:
            }
        }
    }
    
    func main(){
        ctx , cancel := context.WithCancel(context.Background())
        wg.Add(1)
        go f(ctx)
        time.Sleep(time.Second*5)
        cancel()
        wg.Wait()
    }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>  一个根的ctx一级级往下传，可以控制嵌套的进程的暂停和退出</p>
</li>
</ul>
<h1 id="服务端Agent开发"><a href="#服务端Agent开发" class="headerlink" title="服务端Agent开发"></a>服务端Agent开发</h1><h2 id="项目架构设计"><a href="#项目架构设计" class="headerlink" title="项目架构设计"></a>项目架构设计</h2><h2 id="Kafka-and-zookeeper"><a href="#Kafka-and-zookeeper" class="headerlink" title="Kafka and zookeeper"></a>Kafka and zookeeper</h2><h2 id="tailf接受"><a href="#tailf接受" class="headerlink" title="tailf接受"></a>tailf接受</h2><h1 id="gin框架"><a href="#gin框架" class="headerlink" title="gin框架"></a>gin框架</h1><ul>
<li>github上有源码，直接上去copy下来</li>
<li>路由初始化：<ul>
<li><ol>
<li>gin.Default()获取路由</li>
<li>绑定路由规则，执行的函数,<code>r.GET("/",func(c *gin.Context))</code> , Context里面封装了request,response之类的东西。使得更加为一个整体。</li>
<li>使服务器监听端口</li>
</ol>
</li>
</ul>
</li>
<li>gin路由：<ul>
<li>由httprouter做的</li>
<li><code>Restful风格的API</code>:<ul>
<li>获取文章 <code>/blog/getXxx</code> =&gt; Get   blog/Xxx</li>
<li>添加 <code>/blog/addXxx</code>=&gt;  Post   blog/Xxx</li>
<li>修改 <code>/blog/updateXxx</code> =&gt; Put   blog/Xxx</li>
<li>删除 <code>/blog/delXxx</code> =&gt;  Delete   blog/Xxx</li>
</ul>
</li>
</ul>
</li>
<li>剩下的例子去看代码</li>
<li>httproter原理可以去github上看源码，构造前缀树啊之类的东西</li>
<li>![image-20201215152054557](C:\Users\Alexander Liu\AppData\Roaming\Typora\typora-user-images\image-20201215152054557.png)</li>
</ul>
<h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><ul>
<li>HTTP是无状态的协议，为了区分是否为同一个客户端发出，才有了cookie。</li>
<li>client请求服务器，服务器除了返回信息还会返回一个cookie，cookie保存在本地的浏览器上，起到身份识别的作用。当client再次请求server时，会携带cookie</li>
<li>作用：<ul>
<li>保持用户登录状态</li>
<li>保持用户的信息(比如说京东的购物车)</li>
</ul>
</li>
<li>缺点：<ul>
<li>安全性不高</li>
<li>增加访问带宽消耗</li>
<li>可以被禁用</li>
<li>cookie有上限的</li>
</ul>
</li>
</ul>
<h1 id="Redis数据库"><a href="#Redis数据库" class="headerlink" title="Redis数据库"></a>Redis数据库</h1><ul>
<li>应用场景:<ul>
<li>缓存系统，减轻mysql的压力</li>
<li>cache缓存</li>
<li>热门排行榜</li>
<li>利用LIST实现队列的功能</li>
</ul>
</li>
<li>Session的过期时间，可以在set的时候使用</li>
<li>我们用的库是自带连接池的库嗷！</li>
<li>《Redis实战》好书啊！</li>
</ul>
<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><ul>
<li><p>弥补Cookie的不足，只存session的id， session是离不开cookie的，session保存在cookie里面</p>
</li>
<li><p>要用到redis数据库嗷！</p>
</li>
<li><p>![image-20201216200209531](C:\Users\Alexander Liu\AppData\Roaming\Typora\typora-user-images\image-20201216200209531.png)</p>
</li>
<li><p>session接口设计：</p>
<ul>
<li>Set()</li>
<li>Get()</li>
<li>Del()</li>
<li>Save():  session存储</li>
</ul>
</li>
</ul>
<h1 id="一些偷学到的小技巧"><a href="#一些偷学到的小技巧" class="headerlink" title="一些偷学到的小技巧:"></a>一些偷学到的小技巧:</h1><h2 id="vscode中用户代码片段打开设置"><a href="#vscode中用户代码片段打开设置" class="headerlink" title="vscode中用户代码片段打开设置"></a>vscode中用户代码片段打开设置</h2><ul>
<li>在vscode中:<ul>
<li>ctrl + shift + p</li>
<li>snippets</li>
<li>选含有preferences那一项</li>
<li>选中go</li>
<li>然后用json格式就可以自定义代码格式<ul>
<li>前面的名字为你想定义的模板名</li>
<li>prefix为快捷键的方式</li>
<li>body为你要输出的内容</li>
<li>description为描述貌似没啥用???</li>
<li>$为最后光标停留的位置</li>
<li>关于json怎么写之类的我收藏了的，可以直接康收藏。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="相关代码含义查找"><a href="#相关代码含义查找" class="headerlink" title="相关代码含义查找"></a>相关代码含义查找</h2><ul>
<li>上go语言官网（已在收藏夹中）</li>
<li>找到对应的import函数</li>
<li>找到对应的用法即可</li>
</ul>
<h1 id="一些小而重要的知识点"><a href="#一些小而重要的知识点" class="headerlink" title="一些小而重要的知识点"></a>一些小而重要的知识点</h1><h2 id="文件中defer的用法"><a href="#文件中defer的用法" class="headerlink" title="文件中defer的用法"></a>文件中defer的用法</h2><p>![image-20201026172410243](C:\Users\Alexander Liu\AppData\Roaming\Typora\typora-user-images\image-20201026172410243.png)</p>
<p>下面才是对的，由于出问题时，fileObj为nil ， 而err有值，所以调用fileObj.Close()会引发错误造成panic ， 所以直接退出程序这个时候反而是对的，因为对应文件根本没有打开，只有打开了对应文件才应该关闭。相当于固定搭配，记住就好啦！</p>
<h2 id="使用go-module导入包"><a href="#使用go-module导入包" class="headerlink" title="使用go module导入包"></a>使用go module导入包</h2><ul>
<li>对于需要包管理的文件夹，要先<code>go mod init name</code>这阿姨那个对于包管理初始化，这个name是起的名字。这名字对于以后的调用中都用得到，而且是从<code>demoname</code>开始调用相对路径的，注意不是从文件夹开始调用，是从<code>demoname</code>开始调用</li>
</ul>
<h2 id="一些快捷键补充"><a href="#一些快捷键补充" class="headerlink" title="一些快捷键补充"></a>一些快捷键补充</h2><ul>
<li>按住alt用鼠标选中多个位置，可以多行一起操作</li>
</ul>
<h2 id="面试题分享"><a href="#面试题分享" class="headerlink" title="面试题分享"></a>面试题分享</h2><ul>
<li>判断链表有循环？</li>
</ul>
<p>从头开始走，一次走一步，一次走两步，看两者有没有机会相遇</p>
<ul>
<li>走台阶问题</li>
</ul>
<p>问题归纳，使用递归可以解决</p>
<h1 id="大作业"><a href="#大作业" class="headerlink" title="大作业"></a>大作业</h1><h2 id="日志库"><a href="#日志库" class="headerlink" title="日志库"></a>日志库</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ul>
<li>不同的地方输出日志</li>
<li>日志的分级别:<ul>
<li>debug</li>
<li>trace</li>
<li>info</li>
<li>warning</li>
<li>error</li>
<li>fatal</li>
</ul>
</li>
<li>日志要支持开关控制</li>
<li>日志要有时间，行号，文件名，日志级别，日志信息</li>
<li>日志文件要切割:<ul>
<li>按照文件大小切割<ul>
<li>每次记录日志之前都判断一下文件大小</li>
</ul>
</li>
<li>按照日期切割<ul>
<li>每次记录日志之前都判断一下时间（在日志结构体中设置一个字段记录上一次切割的小时数）</li>
<li>写日志前判断一下小时数是否和结构体中的小时数一致即可</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="日志库的异步实现"><a href="#日志库的异步实现" class="headerlink" title="日志库的异步实现:"></a>日志库的异步实现:</h3><ul>
<li>在线程写入的时候，启用其它的线程来执行其它功能保证不会卡。</li>
</ul>
<h2 id="worker-pool-goroutine池"><a href="#worker-pool-goroutine池" class="headerlink" title="worker pool(goroutine池)"></a>worker pool(goroutine池)</h2><ul>
<li>使用goroutine来实现int64位中各位和的计算</li>
</ul>
<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips:"></a>Tips:</h1><ul>
<li>一个用了指针，全部都用指针嗷，这样才能保证对象对应的结构体或者方法能够被修改！！！要么全是指针接收者，要么全是值接收者。</li>
<li>传递参数的时候:</li>
</ul>
<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">add</span><span class="token punctuation">(</span>a <span class="token operator">...</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	body
<span class="token punctuation">}</span>

<span class="token keyword">var</span> s <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token keyword">interface</span><span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">}</span>
<span class="token function">add</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token function">add</span><span class="token punctuation">(</span>s<span class="token operator">...</span><span class="token punctuation">)</span>

<span class="token comment">//这里s传递是一个slice,s...传递的则是切片中的每一个元素，这个很重要嗷。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">Alexander Liu</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/02/20/go-di-er-ci-cha-que-bu-lou/">http://example.com/2021/02/20/go-di-er-ci-cha-que-bu-lou/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">兔の博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%90%8E%E7%AB%AF/">后端</a></div><div class="post_share"><div class="social-share" data-image="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/02/20/go-yu-yan-zi-xue/"><img class="prev-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Go语言自学</div></div></a></div><div class="next-post pull-right"><a href="/2021/02/20/python-duo-xian-cheng-zi-xue/"><img class="next-cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Python多线程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/05/19/docker-xue-xi/" title="Docker学习"><img class="cover" src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210819205713.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-05-19</div><div class="title">Docker学习</div></div></a></div><div><a href="/2021/08/19/docker-jin-jie/" title="Docker进阶"><img class="cover" src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210819205713.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-19</div><div class="title">Docker进阶</div></div></a></div><div><a href="/2021/08/25/elasticsearch-xue-xi/" title="ElasticSearch学习"><img class="cover" src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/cloudimg/img/20210825185001.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-25</div><div class="title">ElasticSearch学习</div></div></a></div><div><a href="/2021/03/16/jdbc-xue-xi/" title="JDBC学习"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-16</div><div class="title">JDBC学习</div></div></a></div><div><a href="/2021/04/21/jsp-xue-xi/" title="JSP学习"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-21</div><div class="title">JSP学习</div></div></a></div><div><a href="/2021/02/20/java-fu-xi/" title="Java大二上所学内容"><img class="cover" src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-02-20</div><div class="title">Java大二上所学内容</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/02/24/5O1day2nriDzjSu.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Alexander Liu</div><div class="author-info__description">欢迎来到兔子的小窝，这里是兔子的一些笔记分享</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">134</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%BF%99%E5%84%BF%E6%98%AF%E5%AF%B9%E4%BA%8EGo%E8%AF%AD%E8%A8%80%E6%95%B4%E4%BD%93%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%8C%E6%98%AFb%E7%AB%99%E6%9D%8E%E6%96%87%E5%91%A8%E8%80%81%E5%B8%88%E7%9A%84%E6%95%99%E7%A8%8B%E7%9A%84%E6%95%B4%E7%90%86%E7%9A%84%E5%86%85%E5%AE%B9%E5%92%8C%E8%87%AA%E5%B7%B1%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%BF%83%E5%BE%97%E4%BD%93%E4%BC%9A%EF%BC%8C%E8%AE%B0%E5%BD%95%E5%9C%A8%E8%BF%99%E5%84%BF"><span class="toc-number">1.</span> <span class="toc-text">这儿是对于Go语言整体系统的学习，是b站李文周老师的教程的整理的内容和自己的学习心得体会，记录在这儿</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%8F%98%E9%87%8F%E7%9A%84%E5%A3%B0%E6%98%8E"><span class="toc-number">2.</span> <span class="toc-text">关于变量的声明</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B3%E4%BA%8E%E5%B8%B8%E9%87%8F"><span class="toc-number">3.</span> <span class="toc-text">关于常量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.</span> <span class="toc-text">基本数据类型</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">5.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#if%E5%92%8Cfor%E7%AD%89%E7%BB%93%E6%9E%84"><span class="toc-number">6.</span> <span class="toc-text">if和for等结构</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#switch%E5%92%8Cgoto"><span class="toc-number">7.</span> <span class="toc-text">switch和goto</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.</span> <span class="toc-text">复合数据类型:</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%EF%BC%9A"><span class="toc-number">8.1.</span> <span class="toc-text">数组：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%87%E7%89%87%EF%BC%9A"><span class="toc-number">8.2.</span> <span class="toc-text">切片：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-number">8.2.1.</span> <span class="toc-text">切片基础操作：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87%E9%AB%98%E7%BA%A7%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-number">8.2.2.</span> <span class="toc-text">切片高级操作：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">8.3.</span> <span class="toc-text">指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#map"><span class="toc-number">8.4.</span> <span class="toc-text">map</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%82%B9%E9%9A%BE%E7%82%B9-defer%E8%AF%AD%E5%8F%A5"><span class="toc-number">8.4.1.</span> <span class="toc-text">重点难点: defer语句</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">8.4.2.</span> <span class="toc-text">变量作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E8%BF%94%E5%9B%9E%E5%80%BC"><span class="toc-number">8.4.3.</span> <span class="toc-text">函数作为返回值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E4%B8%8E%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0"><span class="toc-number">8.4.4.</span> <span class="toc-text">匿名函数与立即执行函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85"><span class="toc-number">8.4.5.</span> <span class="toc-text">闭包</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0%E7%AE%80%E4%BB%8B"><span class="toc-number">9.</span> <span class="toc-text">内置函数简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#panic%E5%92%8Cdefer%E5%92%8Crecover-%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86"><span class="toc-number">9.1.</span> <span class="toc-text">panic和defer和recover(错误处理)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fmt%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B"><span class="toc-number">9.2.</span> <span class="toc-text">fmt标准库简介</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">10.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8Band%E7%B1%BB%E5%9E%8B%E5%88%AB%E5%90%8D"><span class="toc-number">11.</span> <span class="toc-text">自定义类型and类型别名</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">12.</span> <span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E5%8C%BF%E5%90%8D%E5%AD%97%E6%AE%B5"><span class="toc-number">12.1.</span> <span class="toc-text">结构体匿名字段</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%92%8C%E6%8E%A5%E6%94%B6%E8%80%85"><span class="toc-number">13.</span> <span class="toc-text">方法和接收者</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%B8%8EJSON"><span class="toc-number">14.</span> <span class="toc-text">结构体与JSON</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">15.</span> <span class="toc-text">接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">15.1.</span> <span class="toc-text">读写文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E6%96%87%E4%BB%B6%EF%BC%9A"><span class="toc-number">15.1.1.</span> <span class="toc-text">读文件：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%99%E6%96%87%E4%BB%B6"><span class="toc-number">15.1.2.</span> <span class="toc-text">写文件:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%AD%E9%97%B4%E6%8F%92%E5%85%A5%E5%86%85%E5%AE%B9"><span class="toc-number">15.2.</span> <span class="toc-text">文件中间插入内容</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#time%E6%A0%87%E5%87%86%E5%BA%93"><span class="toc-number">16.</span> <span class="toc-text">time标准库</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#time%E5%BA%93%E7%9A%84%E8%A1%A5%E5%85%85%E5%86%85%E5%AE%B9"><span class="toc-number">16.1.</span> <span class="toc-text">time库的补充内容</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#runtime-Caller"><span class="toc-number">17.</span> <span class="toc-text">runtime.Caller</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#strconv%E6%A0%87%E5%87%86%E5%BA%93%E7%AE%80%E4%BB%8B"><span class="toc-number">18.</span> <span class="toc-text">strconv标准库简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Egoroutine%E7%9A%84%E4%B8%80%E4%BA%9B%E5%BA%95%E5%B1%82%E7%9A%84%E7%9F%A5%E8%AF%86"><span class="toc-number">18.0.1.</span> <span class="toc-text">关于goroutine的一些底层的知识</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sync-WaitGroup"><span class="toc-number">18.1.</span> <span class="toc-text">sync.WaitGroup</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E7%AD%89%E5%85%B6%E5%AE%83%E7%BA%BF%E7%A8%8B%E7%BB%93%E6%9D%9F"><span class="toc-number">18.1.1.</span> <span class="toc-text">如何优雅的等其它线程结束</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#math-x2F-rand"><span class="toc-number">18.1.2.</span> <span class="toc-text">math&#x2F;rand</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E5%AE%83%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C"><span class="toc-number">18.1.3.</span> <span class="toc-text">其它的一些操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-number">18.1.4.</span> <span class="toc-text">通道的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E7%BB%93%E6%9E%84%E4%BD%93%E8%AE%A1%E6%95%B0%E9%80%9A%E9%81%93"><span class="toc-number">18.1.5.</span> <span class="toc-text">匿名结构体计数通道</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#select%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8"><span class="toc-number">19.</span> <span class="toc-text">select多路复用</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#atomic%E5%8E%9F%E5%AD%90%E6%80%A7%E6%93%8D%E4%BD%9C"><span class="toc-number">20.</span> <span class="toc-text">atomic原子性操作</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#TCP%E7%B2%98%E5%8C%85"><span class="toc-number">21.</span> <span class="toc-text">TCP粘包</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#net-http"><span class="toc-number">22.</span> <span class="toc-text">net&#x2F;http</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Context%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%92%8Cpprof%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7"><span class="toc-number">23.</span> <span class="toc-text">Context单元测试和pprof调试工具</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#go%E8%AF%AD%E8%A8%80%E4%B8%AD%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95"><span class="toc-number">23.1.</span> <span class="toc-text">go语言中单元测试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95"><span class="toc-number">23.2.</span> <span class="toc-text">go语言中的基准测试</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">24.</span> <span class="toc-text">数据库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Go%E5%AF%B9%E4%BA%8EMySQL%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">25.</span> <span class="toc-text">Go对于MySQL的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%EF%BC%9A"><span class="toc-number">25.1.</span> <span class="toc-text">连接数据库：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AFAgent%E5%BC%80%E5%8F%91"><span class="toc-number">26.</span> <span class="toc-text">服务端Agent开发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">26.1.</span> <span class="toc-text">项目架构设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Kafka-and-zookeeper"><span class="toc-number">26.2.</span> <span class="toc-text">Kafka and zookeeper</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tailf%E6%8E%A5%E5%8F%97"><span class="toc-number">26.3.</span> <span class="toc-text">tailf接受</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#gin%E6%A1%86%E6%9E%B6"><span class="toc-number">27.</span> <span class="toc-text">gin框架</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#cookie"><span class="toc-number">28.</span> <span class="toc-text">cookie</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Redis%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">29.</span> <span class="toc-text">Redis数据库</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Session"><span class="toc-number">30.</span> <span class="toc-text">Session</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%81%B7%E5%AD%A6%E5%88%B0%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7"><span class="toc-number">31.</span> <span class="toc-text">一些偷学到的小技巧:</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#vscode%E4%B8%AD%E7%94%A8%E6%88%B7%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%E6%89%93%E5%BC%80%E8%AE%BE%E7%BD%AE"><span class="toc-number">31.1.</span> <span class="toc-text">vscode中用户代码片段打开设置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B8%E5%85%B3%E4%BB%A3%E7%A0%81%E5%90%AB%E4%B9%89%E6%9F%A5%E6%89%BE"><span class="toc-number">31.2.</span> <span class="toc-text">相关代码含义查找</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%B0%8F%E8%80%8C%E9%87%8D%E8%A6%81%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">32.</span> <span class="toc-text">一些小而重要的知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E4%B8%ADdefer%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">32.1.</span> <span class="toc-text">文件中defer的用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8go-module%E5%AF%BC%E5%85%A5%E5%8C%85"><span class="toc-number">32.2.</span> <span class="toc-text">使用go module导入包</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E5%BF%AB%E6%8D%B7%E9%94%AE%E8%A1%A5%E5%85%85"><span class="toc-number">32.3.</span> <span class="toc-text">一些快捷键补充</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E5%88%86%E4%BA%AB"><span class="toc-number">32.4.</span> <span class="toc-text">面试题分享</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%A4%A7%E4%BD%9C%E4%B8%9A"><span class="toc-number">33.</span> <span class="toc-text">大作业</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%BA%93"><span class="toc-number">33.1.</span> <span class="toc-text">日志库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-number">33.1.1.</span> <span class="toc-text">需求分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A5%E5%BF%97%E5%BA%93%E7%9A%84%E5%BC%82%E6%AD%A5%E5%AE%9E%E7%8E%B0"><span class="toc-number">33.1.2.</span> <span class="toc-text">日志库的异步实现:</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#worker-pool-goroutine%E6%B1%A0"><span class="toc-number">33.2.</span> <span class="toc-text">worker pool(goroutine池)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Tips"><span class="toc-number">34.</span> <span class="toc-text">Tips:</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/12/07/cao-zuo-xi-tong-gai-shu/" title="1. 操作系统概述"><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202212071136497.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="1. 操作系统概述"/></a><div class="content"><a class="title" href="/2022/12/07/cao-zuo-xi-tong-gai-shu/" title="1. 操作系统概述">1. 操作系统概述</a><time datetime="2022-12-07T03:35:42.000Z" title="发表于 2022-12-07 11:35:42">2022-12-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/05/cpu-cache-xue-xi/" title="CPU Cache 学习"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPU Cache 学习"/></a><div class="content"><a class="title" href="/2022/12/05/cpu-cache-xue-xi/" title="CPU Cache 学习">CPU Cache 学习</a><time datetime="2022-12-05T04:14:46.000Z" title="发表于 2022-12-05 12:14:46">2022-12-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/16/ml-ru-men/" title="ML入门"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ML入门"/></a><div class="content"><a class="title" href="/2022/01/16/ml-ru-men/" title="ML入门">ML入门</a><time datetime="2022-01-16T11:11:14.000Z" title="发表于 2022-01-16 19:11:14">2022-01-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/28/da-shu-ju-fen-xi-yu-zhi-neng-ji-suan-qi-mo-fu-xi-3/" title="大数据分析与智能计算期末复习3"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="大数据分析与智能计算期末复习3"/></a><div class="content"><a class="title" href="/2021/12/28/da-shu-ju-fen-xi-yu-zhi-neng-ji-suan-qi-mo-fu-xi-3/" title="大数据分析与智能计算期末复习3">大数据分析与智能计算期末复习3</a><time datetime="2021-12-28T14:05:22.000Z" title="发表于 2021-12-28 22:05:22">2021-12-28</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/12/24/da-shu-ju-fen-xi-yu-zhi-neng-ji-suan-qi-mo-fu-xi-2/" title="大数据分析与智能计算期末复习2"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="大数据分析与智能计算期末复习2"/></a><div class="content"><a class="title" href="/2021/12/24/da-shu-ju-fen-xi-yu-zhi-neng-ji-suan-qi-mo-fu-xi-2/" title="大数据分析与智能计算期末复习2">大数据分析与智能计算期末复习2</a><time datetime="2021-12-24T07:59:54.000Z" title="发表于 2021-12-24 15:59:54">2021-12-24</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By Alexander Liu</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>