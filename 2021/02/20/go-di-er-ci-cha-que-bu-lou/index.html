

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/tuzi.png">
  <link rel="icon" href="/img/tuzi.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Alexander Liu">
  <meta name="keywords" content="分布式系统,后端研发,数据协同">
  
    <meta name="description" content="这儿是对于Go语言整体系统的学习，是b站李文周老师的教程的整理的内容和自己的学习心得体会，记录在这儿">
<meta property="og:type" content="article">
<meta property="og:title" content="Go究极李文周网课学习">
<meta property="og:url" content="http://example.com/2021/02/20/go-di-er-ci-cha-que-bu-lou/index.html">
<meta property="og:site_name" content="兔の博客">
<meta property="og:description" content="这儿是对于Go语言整体系统的学习，是b站李文周老师的教程的整理的内容和自己的学习心得体会，记录在这儿">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:/Users/Alexander%20Liu/AppData/Roaming/Typora/typora-user-images/image-20201207163310289.png">
<meta property="article:published_time" content="2021-02-20T08:05:21.000Z">
<meta property="article:modified_time" content="2021-03-01T13:04:05.000Z">
<meta property="article:author" content="Alexander Liu">
<meta property="article:tag" content="后端">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="c:/Users/Alexander%20Liu/AppData/Roaming/Typora/typora-user-images/image-20201207163310289.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Go究极李文周网课学习 - 兔の博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="兔の博客" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>兔的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/background_post.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Go究极李文周网课学习"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Alexander Liu
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2021-02-20 16:05" pubdate>
          2021年2月20日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          26k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          220 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Go究极李文周网课学习</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：2 年前
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <h1 id="这儿是对于Go语言整体系统的学习，是b站李文周老师的教程的整理的内容和自己的学习心得体会，记录在这儿"><a href="#这儿是对于Go语言整体系统的学习，是b站李文周老师的教程的整理的内容和自己的学习心得体会，记录在这儿" class="headerlink" title="这儿是对于Go语言整体系统的学习，是b站李文周老师的教程的整理的内容和自己的学习心得体会，记录在这儿"></a>这儿是对于Go语言整体系统的学习，是b站李文周老师的教程的整理的内容和自己的学习心得体会，记录在这儿</h1><hr>
<span id="more"></span>





<h1 id="关于变量的声明"><a href="#关于变量的声明" class="headerlink" title="关于变量的声明"></a>关于变量的声明</h1><ul>
<li>变量声明可以用</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span>(<br>	str <span class="hljs-type">string</span><br>	a   <span class="hljs-type">int</span><br>	wheater <span class="hljs-type">bool</span><br>)<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>变量如果声明了不使用会报错</li>
<li>go fmt filename 这种方式可以使文件格式化</li>
<li>类型变量和短变量声明:</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s1 = <span class="hljs-string">"this is rabbit"</span><br>s2 := <span class="hljs-string">"this is rabbit too"</span><br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>匿名变量”_” ， 可以忽略一些值，不占用空间也不分配内存，接收值之后就直接扔掉了。</li>
<li>:= 等赋值不能在函数外赋值</li>
<li>同一个作用域不能重复声明同一个变量</li>
</ul>
<h1 id="关于常量"><a href="#关于常量" class="headerlink" title="关于常量"></a>关于常量</h1><ul>
<li><code>const pi = 3.14159</code>常量的声明</li>
<li>批量声明:</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span>(<br>	statusOK = <span class="hljs-number">200</span><br>	notfound = <span class="hljs-number">404</span><br>)<br></code></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span>(<br>	n1 = <span class="hljs-number">100</span><br>	n2<br>	n3<br>)<br></code></pre></td></tr></tbody></table></figure>

<p>如果没有写值的话默认和上面是一样的。</p>
<ul>
<li>iota是go语言的常量计数器，只能在常量表达式中使用。</li>
</ul>
<p>多一个常量，iota++ , 默认值为0, 每出现一次const, iota就重置为0，每多<code>一行</code>常量声明，iota在这一行后就会+1。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span>{<br>	a1 = <span class="hljs-literal">iota</span><br>    _<br>	a2<br>	a3<br>    a4 = <span class="hljs-number">100</span><br>    a5<br>}<span class="hljs-comment">// a1 = 0 , 由于后面没有标，默认也是iota嗷</span><br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>定义数量级:</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span>(<br>	_ = <span class="hljs-literal">iota</span><br>	KB = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span>*<span class="hljs-literal">iota</span>)<br>	MB = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span>*<span class="hljs-literal">iota</span>)<br>	GB = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span>*<span class="hljs-literal">iota</span>)<br>    TB = <span class="hljs-number">1</span> &lt;&lt; (<span class="hljs-number">10</span>*<span class="hljs-literal">iota</span>)<br>)<br></code></pre></td></tr></tbody></table></figure>



<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><ul>
<li><p>int8 , int16 , int32 ,int 64</p>
</li>
<li><p>uint8 , uint16…</p>
</li>
<li><p>uint类型会根据操作系统自己决定</p>
</li>
<li><p>int也是这样</p>
</li>
<li><p>uintptr 存放一个指针嗷！</p>
</li>
<li><p>float32 , float64</p>
</li>
<li><p>bool - true , false</p>
</li>
<li><p>二进制数在go语言中无法直接定义，只能转换</p>
</li>
<li><p>八进制前面带有0 ， 十六进制带有0x ，是可以直接声明的。</p>
</li>
</ul>
<p>%d , %o , %x这三个都是常用的十进制，八进制和十六进制,</p>
<p>%b 是二进制。</p>
<p>%#v 会自动帮你的类型加一个双引号。</p>
<ul>
<li><p>查看变量类型: <code>%T</code></p>
</li>
<li><p>强制类型转换: <code>a := int8(9)</code></p>
</li>
<li><p>%v 打印输出的是变量的值，不用管type , 很有用哦。</p>
</li>
<li><p>浮点数: float32 , float64</p>
</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">math.Mathfloat32<br>math.Mathfloat64<br></code></pre></td></tr></tbody></table></figure>

<p>默认也是64</p>
<h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><ul>
<li><p>go语言中的字符串只能用<code>""</code>来包裹</p>
</li>
<li><p>go语言中的<code>''</code>用来包裹字符</p>
</li>
<li><p>一个中文一般占三个字节</p>
</li>
<li><p>转义符用法一样的</p>
</li>
<li><p>多行字符串：</p>
</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">s2 : = <span class="hljs-string">`</span><br><span class="hljs-string">	a</span><br><span class="hljs-string">	b</span><br><span class="hljs-string">	c</span><br><span class="hljs-string">`</span><br></code></pre></td></tr></tbody></table></figure>

<ul>
<li><p>反引号``中的东西原样子输出，是不会变的。</p>
</li>
<li><p>字符串的拼接: 用加号</p>
</li>
<li><p><code>Printf</code>和<code>Sprintf</code>第一个直接在终端答应输出，第二个是以字符串的形式返回。</p>
</li>
<li><p>strings包里有好多的像是Split和Contains和HasPrefix , Index , lastIndex , Join等函数方法用来调用。</p>
</li>
<li><p>字符串不能修改的，只能转换成切片然后再进行转换哦。</p>
</li>
<li><p><code>""</code>和<code>''</code>对应的类型是不一样的嗷</p>
</li>
<li><p>go 使用了rune 类型来处理Unicode , 所以如果要处理中文等，都转换成rune类型嗷。</p>
</li>
</ul>
<h1 id="if和for等结构"><a href="#if和for等结构" class="headerlink" title="if和for等结构"></a>if和for等结构</h1><ul>
<li>非常特别：</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">if</span> a := <span class="hljs-number">19</span>; age &gt; <span class="hljs-number">18</span>{<br>	body<br>}<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li><p>go语言中只有for循环:</p>
<ul>
<li><pre><code class="go">for i := 0; i&lt;10 ; i++{
    body
}
<figure class="highlight css"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css"><br>- ```go<br>  <span class="hljs-selector-tag">i</span> := <span class="hljs-number">0</span><br>  for ;<span class="hljs-selector-tag">i</span>&lt;<span class="hljs-number">10</span>;<span class="hljs-selector-tag">i</span>++{<br>  	<span class="hljs-selector-tag">body</span><br>  }<br></code></pre></td></tr></tbody></table></figure>
</code></pre>
</li>
<li><pre><code class="go">i := 0
for i&lt;10{
    body
    i++
}
<figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- ```go<br>  for{<br>      body<br>      if(condition){<br>          <span class="hljs-keyword">break</span><br>      }<br>  }<br></code></pre></td></tr></tbody></table></figure>
</code></pre>
</li>
<li><p>range好重要！！！</p>
</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">s := <span class="hljs-string">"hello沙河"</span><br><span class="hljs-keyword">for</span> i,v := <span class="hljs-keyword">range</span> s{<br>	body<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>i获得的是索引，v获得的是value</p>
</li>
</ul>
<h1 id="switch和goto"><a href="#switch和goto" class="headerlink" title="switch和goto"></a>switch和goto</h1><ul>
<li><pre><code class="go">switch n:=1 ; n{
    body
}
<figure class="highlight excel"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs excel"><br>- ```go<br>  <span class="hljs-built_in">switch</span> <span class="hljs-built_in">n</span>{<br>      case <span class="hljs-built_in">n</span>&lt;<span class="hljs-symbol">26:</span><br>      	body...<br>  }<br></code></pre></td></tr></tbody></table></figure>
</code></pre>
</li>
<li><p>fallthrough可以像c语言一样下穿，就是为了满足c语言。（最好不要用嗷！）</p>
</li>
<li><p>goto可以跳到某些代码块儿上，也不常用了。</p>
</li>
<li><p>```go<br>xx:<br>fmt.Println(“asjdkfs”)<br>goto xx // 这样就完成了跳转</p>
<figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey">  <br>- 同样 <span class="hljs-keyword">break</span> 和 <span class="hljs-keyword">continue</span> 也可以接上<span class="hljs-keyword">goto</span>语句<br><br><br><br><br><br># 运算符<br><br>- `a++`里面是单独的语句，不能放在等号的右边赋值<br><span class="hljs-title">- 位运算:</span><br><br>```go<br>&amp; 按位与<br>| 按位或<br>&lt;&lt; 左移n位<br>&gt;&gt; 右移n位<br>^ 按位异或<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<p>默认是二进制进行计算的</p>
<ul>
<li>要注意范围哦，像是int8你如果左移了10位就可能出问题，但是16位就不一定会嗷。</li>
<li>同样的也可以进行赋值的:</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">+= -=  =  *=  /=  %=  &lt;&lt;=<span class="hljs-number">2</span> &gt;&gt;=<span class="hljs-number">2</span>  &amp;=<span class="hljs-number">2</span> |=<span class="hljs-number">2</span>  ^=<span class="hljs-number">2</span><br></code></pre></td></tr></tbody></table></figure>





<h1 id="复合数据类型"><a href="#复合数据类型" class="headerlink" title="复合数据类型:"></a>复合数据类型:</h1><h2 id="数组："><a href="#数组：" class="headerlink" title="数组："></a>数组：</h2><ul>
<li>长度和类型</li>
<li>就类似于其他语言中的列表</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> name [num]<span class="hljs-keyword">type</span><br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>对用的type就是[3]int</li>
<li>初始化：</li>
</ul>
<p>默认元素都是零值</p>
<ol>
<li><pre><code class="go">a1 = [3]int{0,1,2}
<figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br><span class="hljs-number">2</span>. ```go<br>   a2 := [...]int{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">34</span>,<span class="hljs-number">545</span>,<span class="hljs-number">456</span>...}<br></code></pre></td></tr></tbody></table></figure>
</code></pre>
</li>
<li><p>```go<br>a3 := [5]int{1,2}   //自动补零</p>
<figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br><span class="hljs-number">4</span>. ```go<br><span class="hljs-title">   a3 := [5]int{0:5,2:</span><span class="hljs-number">8</span>}<br></code></pre></td></tr></tbody></table></figure></li>
</ol>
<ul>
<li>数组的传递:</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">x := [<span class="hljs-number">3</span>]<span class="hljs-type">int</span>{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>}<br>y := x<br><span class="hljs-comment">//这个时候得到的y是x的一个副本嗷呜！！！</span><br></code></pre></td></tr></tbody></table></figure>



<ul>
<li>数组的遍历：</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">len</span>(array);i++{<br>	body<br>}<br></code></pre></td></tr></tbody></table></figure>

<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> i,v := <span class="hljs-keyword">range</span> ArrayName{<br>	body<br>}<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li><p>多维数组:</p>
<ul>
<li><pre><code class="go">var all [3][2]int
all = [3][2]int{
    [2]int{1,2},
    [2]int{3,4},
    [2]int{5,6}
} //和numpy差不多嗷呜
<figure class="highlight armasm"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><br>- 多维数组的遍历:<br><br>```go<br><span class="hljs-symbol">for</span> _, <span class="hljs-built_in">v1</span> := range all{<br>	fmt.Println(<span class="hljs-built_in">v1</span>)<br>	for _,<span class="hljs-built_in">v2</span> := range <span class="hljs-built_in">v1</span>{<br>		fmt.Println(<span class="hljs-built_in">v2</span>)<br>	}<br>} <span class="hljs-comment">//两层遍历，这里的v1实际上是内层数组</span><br></code></pre></td></tr></tbody></table></figure>
</code></pre>
</li>
<li><p>多维数组也可以这样定义</p>
</li>
</ul>
<p><code>var a1 [...][2]int</code> , 最外层才可以… , 内层是不可以加的哦。</p>
</li>
<li><p>在go语言中，对于数组的赋值，实质上是值应用，相当于复制了一个数组给我们要引用的对象。</p>
</li>
</ul>
<h2 id="切片："><a href="#切片：" class="headerlink" title="切片："></a>切片：</h2><h3 id="切片基础操作："><a href="#切片基础操作：" class="headerlink" title="切片基础操作："></a>切片基础操作：</h3><ul>
<li>可变长度的，并且是引用类型</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s []<span class="hljs-type">int</span>   <span class="hljs-comment">// 切片不存在为nil</span><br>s1 := []<span class="hljs-type">int</span>()   <span class="hljs-comment">// 切片存在且len和cap都为0</span><br>s2 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">0</span>)   <span class="hljs-comment">//和上面一样没啥区别</span><br></code></pre></td></tr></tbody></table></figure>

<p>由于是可变的，声明切片的时候可以这样声明</p>
<ul>
<li>切片和数组最大的区别就是切片声明的时候是不带长度的，因为切片长度是可变的，初始化的时候就得以体现。</li>
<li>nil类似于其他语言中的空</li>
<li>切片没有初始化时默认为空，即没有分配内存空间</li>
<li>len长度，cap为容量</li>
<li>初始化:</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-number">1.</span> <br><span class="hljs-keyword">var</span> s []<span class="hljs-type">int</span><br>s = []<span class="hljs-type">int</span>{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>}<br><span class="hljs-comment">// 本质也是造一个数组，返回切片给你</span><br><span class="hljs-number">2.</span><br>s1 = [...]<span class="hljs-type">int</span>{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>}<br>s = s1[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>] <span class="hljs-comment">//和py中一样，左开右闭。</span><br><span class="hljs-number">3.</span><br>s2 := s3[<span class="hljs-number">3</span>:]<br><span class="hljs-comment">// 切片的切片</span><br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>切片容量是从切片第一个元素对应底层数组到末尾的元素的个数</li>
<li>切片是引用，指向一个指定的数组，切片和数组都是相互影响的。</li>
<li>make函数构造切片:</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">s1 := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>) <span class="hljs-comment">//默认切片元素都为0，如果不加第二个参数，默认cap和len相同，本质也是底层数组的分配。</span><br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>切片的内存: 一块儿连续的内存</li>
<li>一个nil值的切片是没有底层数组的，切片的长度和容量都是0</li>
<li>切片的遍历:</li>
</ul>
<ol>
<li>```go<br>//和c语言里面一样<br>for i:=0;i&lt;len(s);i++{<br>body<br>}<figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br><span class="hljs-number">2</span>. ```go<br>   for i,v := range s{<br>   	fmt.Println(l,v)<br>   }<br></code></pre></td></tr></tbody></table></figure></li>
</ol>
<h3 id="切片高级操作："><a href="#切片高级操作：" class="headerlink" title="切片高级操作："></a>切片高级操作：</h3><ul>
<li><p>切片的扩容：</p>
<ul>
<li>相关操作:</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">s := []<span class="hljs-type">string</span>(<span class="hljs-string">"北京"</span>,<span class="hljs-string">"上海"</span>)<br>s[<span class="hljs-number">2</span>] = <span class="hljs-string">"上海"</span> <span class="hljs-comment">// 这个是错误的,index out of range</span><br>s := s.<span class="hljs-built_in">append</span>(s,<span class="hljs-string">"广州"</span>,<span class="hljs-string">"成都"</span>)<br><span class="hljs-comment">// 这个时候底层数组的长度直接翻倍，找了一个新的地址直接分配新的内存，原来的底层数组就gg了，重新用了一块儿新的，s如果不接收新的数组的话，就废了，所以最好就是用原来的变量接收新的值。拓展容量有自己的方法的,感兴趣可以百度嗷！</span><br><br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<p>s1 := []string(“武汉”,”成都”)<br>  s = s.append(s.s1…)// 这样也可以哦, …表示拆开，把每个单独的元素拿出来，这样也可以达到拓展的目的</p>
<ul>
<li><p>调用append必须要用原来的变量接收返回值。</p>
</li>
<li><p>切片的复制:</p>
<ul>
<li>copy(destination , source)</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a3 []<span class="hljs-type">int</span><br>a1 := []<span class="hljs-type">int</span>(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>)<br><span class="hljs-built_in">copy</span>(a3,a1)<br></code></pre></td></tr></tbody></table></figure>
</li>
<li><p>元素的删除:</p>
<ul>
<li>可以通过切片来实现，没有专门的实现方法。</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">a1 = <span class="hljs-built_in">append</span>(a[:<span class="hljs-number">1</span>].a1[<span class="hljs-number">2</span>:]...)<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>注意传递切片的时候要拆开。</li>
<li>一般不是直接操作数组，因为数组长度固定不可变，所以一般都是操作切片，常用的操作方法有:</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">a1 = s[:]<br></code></pre></td></tr></tbody></table></figure>

<p>然后再对a1进行操作。</p>
<ul>
<li>经典例子:</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">x1 = [...]<span class="hljs-type">int</span>{<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>}<br>s1 = x1[:]<br>s1 = s1.<span class="hljs-built_in">append</span>(s1[:<span class="hljs-number">1</span>],s1[<span class="hljs-number">2</span>:]...)<br><span class="hljs-comment">//这个时候x1就变成了(1,5,5)</span><br></code></pre></td></tr></tbody></table></figure>

<p>由于底层是切片，这样s1变成了[1,5]，按照顺序保存在数组的位置上，但数组的元素个数是不变的，相当于切片有改变了前两个元素。</p>
<ul>
<li>面试题:</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>,<span class="hljs-number">5</span>,<span class="hljs-number">10</span>)<br><br><span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++{<br>    a = a.<span class="hljs-built_in">append</span>(a,i)<br>}<br><br><span class="hljs-comment">//结果为[0,0,0,0,0,0,1,2,3,4,5,6,7,8,9]</span><br></code></pre></td></tr></tbody></table></figure>

<p>一开始初始化make时就已经存在a为[0,0,0,0,0]了，再往后append就是这个结果。</p>
</li>
</ul>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><ul>
<li>比较简单（不存在指针操作）</li>
<li><code>&amp;</code>和<code>*</code>就这两个操作</li>
<li>bugs:<ul>
<li><code>var a *int</code>这个声明了一个指针，但没有初始化，默认指向nil , <code>*a = 100</code>这样赋值是不可以的。因为这个时候，a指针指向一个空地址，连地址指向哪里都不知道无法赋值。</li>
</ul>
</li>
<li>用new函数分配内存地址:</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> a = <span class="hljs-built_in">new</span>(<span class="hljs-type">int</span>)<br>*a = <span class="hljs-number">100</span><br></code></pre></td></tr></tbody></table></figure>

<p>默认给a申请了指针的空间</p>
<ul>
<li><p>new一般用于给基本数据类型申请内存，返回的是对应类型的指针。</p>
</li>
<li><p>make也是用来分配地址的：</p>
<ul>
<li>用于为slice , map , chan申请内存 , make返回的是对应类型本身。</li>
</ul>
</li>
<li><p>go语言中指针有个用法，就是用指针指示成员变量的时候是可以类似于成员对象一样调用的。</p>
</li>
</ul>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><ul>
<li>映射关系，map是应用类型</li>
<li>map[key]value</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m1 <span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span> <span class="hljs-comment">// 这样不行，默认map是空，因为没有为map分配内存</span><br>m1 = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">string</span>]<span class="hljs-type">int</span>,<span class="hljs-number">10</span>) <span class="hljs-comment">// 初始化要估算好内存，最好一次到位，避免动态扩容。</span><br>m1[<span class="hljs-string">"rabbit"</span>] = <span class="hljs-number">18</span><br></code></pre></td></tr></tbody></table></figure>

<ul>
<li><code>v, ok = m1["rabbit"]</code>因为自动返回两个值嗷</li>
<li>map的遍历:</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> m1{<br>	body<br>}<br><span class="hljs-comment">// k是key , v是value</span><br><span class="hljs-comment">// 注意可以用_来取得我们需要的值即可</span><br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>删除:</li>
</ul>
<p><code>delete(mapname,keyname)</code></p>
<ul>
<li>其他一些用法：</li>
</ul>
<p>比如按照指定顺序遍历map:</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">make</span>([]<span class="hljs-type">string</span>,<span class="hljs-number">0</span>,<span class="hljs-number">200</span>)<br><span class="hljs-keyword">for</span> key := <span class="hljs-keyword">range</span> scoreMap{<br>	keys = <span class="hljs-built_in">append</span>(keys,key)<br>}<br><br>sort.Strings(keys)<br><br><span class="hljs-keyword">for</span> _, key := <span class="hljs-keyword">range</span> keys{<br>	fmt.Println(key,scoreMap[key])<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>利用切片对于map元素进行处理。(利用循环单独提取key存在切片里面，然后对于切片进行操作嗷呜！)。</p>
<ul>
<li><p>map可以和切片等其他的数据类型相组合：</p>
<ul>
<li>注意初始化!!!</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s1 = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>)<br>s1[<span class="hljs-number">0</span>] = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-type">int</span>]<span class="hljs-type">string</span>,<span class="hljs-number">1</span>)<br><span class="hljs-comment">//注意多重结构多重初始化哦，和java中一样样的，基本不用，但是复杂结构要哦。</span><br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>```go<br>var m1 = make(map[string][]int,10)<br>m1[“homework”] = []int{1,2,3}<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><br>- 切片和<span class="hljs-built_in">map</span>在一起一定要记得初始化嗷。<br><br><br><br><br><br><span class="hljs-comment"># 函数（非常非常重要嗷呜！！！）</span><br><br>- ```go<br>  func <span class="hljs-built_in">sum</span>(x, y <span class="hljs-built_in">int</span>) (ret <span class="hljs-built_in">int</span>){<br>  	body<br>  }<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><pre><code class="go">func sum() int{
    body
}
<figure class="highlight vim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs vim"><br>- 两个对比<br><br>```<span class="hljs-keyword">go</span><br>func sum(<span class="hljs-keyword">x</span>, <span class="hljs-keyword">y</span> <span class="hljs-keyword">int</span>) (<span class="hljs-keyword">ret</span> <span class="hljs-keyword">int</span>){<br>	<span class="hljs-keyword">ret</span> = <span class="hljs-keyword">x</span>+<span class="hljs-keyword">y</span><br>	<span class="hljs-keyword">return</span><br>}<br>//使用命名返回值可以省略<br>func sum(<span class="hljs-keyword">x</span>, <span class="hljs-keyword">y</span> <span class="hljs-keyword">int</span>) <span class="hljs-keyword">int</span>{<br>	<span class="hljs-keyword">ret</span> := <span class="hljs-keyword">x</span>+<span class="hljs-keyword">y</span><br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">ret</span><br>}<br></code></pre></td></tr></tbody></table></figure>
</code></pre>
</li>
<li><p>可变长参数:</p>
<ul>
<li><code>fun f7(x string, y ...int){}</code></li>
<li>这里的y…处可以传入零个或者多个参数，非常有用</li>
<li>y这个时候为一个slice</li>
<li>可变长参数必须放在参数的最后</li>
</ul>
</li>
<li><p>go语言中没有默认参数这个概念。</p>
</li>
<li><p>go语言中的函数传递的都是值哦，都是传递的副本，和java中差不多嗷</p>
</li>
<li><p>go语言中支持多个返回值嗷呜！</p>
</li>
<li><p>返回值要不都不命名要不都命名。</p>
</li>
</ul>
<h3 id="重点难点-defer语句"><a href="#重点难点-defer语句" class="headerlink" title="重点难点: defer语句"></a>重点难点: defer语句</h3><ul>
<li>多个defer的时候其实上是根据栈来执行的，先进后出的原则嗷呜！</li>
<li>多用于函数结束之前释放资源的时候使用，还用于记录时间啊，文件关闭啊等等。</li>
<li>go语言中的return不是原子操作，在函数中先返回值赋值，然后执行defer语句，最后才真正结束函数。</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> (x <span class="hljs-type">int</span>){<br>	<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>{<br>		x++<br>	}()<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">5</span><br>}<br><span class="hljs-comment">//最终的答案是6哦</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> (y <span class="hljs-type">int</span>){<br>    x := <span class="hljs-number">5</span><br>	<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>{<br>		x++<br>	}()<br>	<span class="hljs-keyword">return</span> x<br>}<br><span class="hljs-comment">//答案是5</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">()</span></span> (x <span class="hljs-type">int</span>){<br>	<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>{<br>		x++<br>	}(x)<br>	<span class="hljs-keyword">return</span> <span class="hljs-number">5</span><br>}<br><span class="hljs-comment">//答案是5</span><br></code></pre></td></tr></tbody></table></figure>

<ul>
<li><code>defer calc("1",a,b,calc("10",a,b))</code></li>
</ul>
<p>这里先调用内层函数算出内部确切的值，例如内部的a和clac都赋予了此刻值，然后才会把外层函数defer延迟调用，就是说defer作用只有一层，其余的依旧会在本步实现。</p>
<h3 id="变量作用域"><a href="#变量作用域" class="headerlink" title="变量作用域"></a>变量作用域</h3><ul>
<li>和其他的函数差不多</li>
<li>查找变量从内向外查找</li>
</ul>
<h3 id="函数作为返回值"><a href="#函数作为返回值" class="headerlink" title="函数作为返回值"></a>函数作为返回值</h3><ul>
<li>函数类型的区分，按照参数和返回值来区分的‘</li>
<li>函数接收函数:</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(x []<span class="hljs-type">int</span>)</span></span>{<br>	body<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(x <span class="hljs-keyword">func</span>(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span></span><span class="hljs-type">int</span>){<br>	<span class="hljs-comment">//直接调用函数</span><br>}<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>函数还可以作为返回值:</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f</span><span class="hljs-params">(x <span class="hljs-keyword">func</span>()</span></span><span class="hljs-type">int</span>) <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>{<br>	body<br>} <span class="hljs-comment">// 满足参数要求的都可以返回。</span><br></code></pre></td></tr></tbody></table></figure>

<h3 id="匿名函数与立即执行函数"><a href="#匿名函数与立即执行函数" class="headerlink" title="匿名函数与立即执行函数"></a>匿名函数与立即执行函数</h3><ul>
<li>定义一个匿名函数</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> f1 = <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(x,y <span class="hljs-type">int</span>)</span></span>{<br>	body<br>}<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>函数内部不能再定义函数（但是匿名函数可以），用于这种情况。通常和java中一样用于只使用一次的函数或者使用次数较少的函数。</li>
<li>立即执行函数：</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go">fun main(){<br><br>	<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>{<br>		fmt.Println(<span class="hljs-string">"hello this is here"</span>)<br>	}()<br>	<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>//这里的fun函数声明之后立刻使用，只使用一次，之后就找不到了。</p>
<ul>
<li>函数内部定义函数一般用匿名函数，只使用一次的直接用立即执行函数</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><ul>
<li>包装函数，使得函数之间的接口相匹配。</li>
<li>函数名加上了()代表函数的执行</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">adder</span><span class="hljs-params">(x <span class="hljs-type">int</span>)</span></span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-type">int</span>)</span></span> <span class="hljs-type">int</span>{<br>	<span class="hljs-keyword">return</span> fun(y <span class="hljs-type">int</span>) <span class="hljs-type">int</span>{<br>		x += y<br>		<span class="hljs-keyword">return</span> x<br>	}<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>{<br>	ret := adder(<span class="hljs-number">100</span>)<br>	ret2 = ret(<span class="hljs-number">200</span>)<br>}<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>人为构造函数接口，函数内部定义的函数</li>
<li>闭包是： <ul>
<li>一个函数</li>
<li>函数包含其外部作用域的一个函数，把x包含进去了，再接下来的过程中再继续调用。</li>
<li>闭包 = 函数 + 外部变量的引用</li>
</ul>
</li>
<li>原理：<ul>
<li>函数可以作为返回值</li>
<li>查找变量的顺序</li>
</ul>
</li>
<li>外部传入的变量被包起来了，在调用内层函数的时候实现再次访问。</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go">fun f1(f <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>){<br>	f()<br>}<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f2</span><span class="hljs-params">(x,y <span class="hljs-type">int</span>)</span></span>{<br>	fmt.Println x+y<br>}<br><br><span class="hljs-comment">//想把f2传入f1中但模式不匹配，这时候要把f2包起来，把参数的接收分开来！f1(f2)</span><br><span class="hljs-comment">//构建闭包函数f3，目标是返回一个能传入f1的函数，但是又要保留f2的参数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">f3</span><span class="hljs-params">(f2(<span class="hljs-type">int</span>,<span class="hljs-type">int</span>)</span></span>,x,y <span class="hljs-type">int</span>) <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>{<br>    temp := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>{<br>        f2(x,y)<br>    }<br>    <span class="hljs-keyword">return</span> temp<br>}<br><span class="hljs-comment">// 传入目的f2，进行处理后得到能被f1接收的函数</span><br><span class="hljs-comment">// f3老子帮你f2要处理的数据处理好，然后帮你构造好，以你需要的形式给你吐出来！！！</span><br></code></pre></td></tr></tbody></table></figure>





<h1 id="内置函数简介"><a href="#内置函数简介" class="headerlink" title="内置函数简介"></a>内置函数简介</h1><h2 id="panic和defer和recover-错误处理"><a href="#panic和defer和recover-错误处理" class="headerlink" title="panic和defer和recover(错误处理)"></a>panic和defer和recover(错误处理)</h2><ul>
<li>大致有<code>close len new make append panic recover</code></li>
<li>go语言中没有异常机制</li>
<li>panic直接让程序崩溃退出</li>
<li>防止程序占用资源可以用defer来解决panic , recover则可以尝试恢复错误</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>{<br>	err := <span class="hljs-built_in">recover</span>()<br>	fmt.Println(err)<br>	fmt.Println(<span class="hljs-string">"释放网络连接"</span>)<br>}()<br><br><span class="hljs-built_in">panic</span>(<span class="hljs-string">"出现了严重的错误。"</span>)<br></code></pre></td></tr></tbody></table></figure>

<p>recover会尝试着修复panic，跳过panic的部分然后往后走。recover尽量少用嗷呜！！！该panic还是要panic</p>
<ul>
<li>recover()一定要搭配defer使用，defer一定要在可以能会panic的语句之前调用</li>
</ul>
<h2 id="fmt标准库简介"><a href="#fmt标准库简介" class="headerlink" title="fmt标准库简介"></a>fmt标准库简介</h2><ul>
<li><p>fmt主要用于打印输出和获取输入的时候使用的嗷！</p>
</li>
<li><p><code>Print Printf Println</code> , <code>printf</code>用于格式化输出字符串</p>
</li>
<li><p>注意一下 <code>%T %v %#v %% %+v</code>等等（这几个是通用的，不管什么类型都可以用）</p>
</li>
<li><p><code>%t %p</code>等类似于布尔值，指针等类型</p>
</li>
<li><p><code>fmt.Scan fmt.Scanf fmt.Scanln</code></p>
</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span><br>fmt.Scan(&amp;s)<br><br>fmt.Scanf(<span class="hljs-string">"%s %d %s\n"</span>,&amp;a,&amp;b,&amp;c)<br><span class="hljs-comment">// 扫描完换行</span><br><br>fmt.Scanln(&amp;a,&amp;b,&amp;c)<br><span class="hljs-comment">//注意这里不能接收格式化的值嗷</span><br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>Sprint 拼接</li>
</ul>
<h1 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h1><ul>
<li>老递归了，乖娃子好家伙你差点整死你爹。</li>
<li>和别的语言差不多，找到规律和递归出口，节能写出来，没啥区别orz</li>
</ul>
<h1 id="自定义类型and类型别名"><a href="#自定义类型and类型别名" class="headerlink" title="自定义类型and类型别名"></a>自定义类型and类型别名</h1><ul>
<li>type是用来定义类型的</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myInt <span class="hljs-type">int</span>     <span class="hljs-comment">//自定义类型</span><br><span class="hljs-keyword">type</span> yourInt = <span class="hljs-type">int</span> <span class="hljs-comment">//类型别名</span><br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>别名会使得默写情况下表达更加清晰（例如<code>rume</code>和<code>int32</code>）</li>
</ul>
<h1 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h1><ul>
<li>定义一个结构体的方法：</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> 类型名 <span class="hljs-keyword">struct</span>{<br>	body<br>}<br><br><span class="hljs-keyword">var</span> varname 类型名<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li><p>打印输出的话是按顺序输出每个字段的值</p>
</li>
<li><p>匿名结构体：</p>
<ul>
<li>```go<br>var s = struct{<br>name string<br>age int<br>}<figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>  - 临时使用的时候用的到。<br><br>  - 结构体要用花括号。<br><br>  - 这样也可以临时声明一个结构体并且返回给一个变量。<br><br>- 和c语言一样，函数是传值操作，结构体同样，如果要改变结构体中的变量的话，一样要传递结构体指针。<br><br>- 取得结构体的指针：<br><br>  - `var p2 = <span class="hljs-keyword">new</span>(person)`(<span class="hljs-keyword">new</span>直接返回对应类型的指针)<br>  - `%p`能够打印输出对应的指针的地址<br><br>  ```go<br>  fmt.Println(<span class="hljs-string">"%p\n"</span>,&amp;a)<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
<li><p>结构体初始化：</p>
<ul>
<li>直接声明结构体然后依次赋值</li>
</ul>
 <figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> p = person(<br>    name: <span class="hljs-string">"rabbit"</span><br>    age: <span class="hljs-number">19</span><br>)<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>使用值列表（按照声明的顺序来初始化）进行初始化:</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go">p := person(<br>	<span class="hljs-string">"rabbit"</span>，<br>    <span class="hljs-number">19</span>，<br>)<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">  <br>- 结构体内的内存是连续的<br><br>- 可以设置一个构造函数来进行初始化也可以鸭<br><br>​```go<br>func <span class="hljs-keyword">new</span><span class="hljs-constructor">Person(<span class="hljs-params">name</span> <span class="hljs-params">string</span> , <span class="hljs-params">age</span> <span class="hljs-params">int</span>)</span> *Person{<br>	return &amp;person{<br>		name: name<br>		age: age<br>	}<br>}<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>注意哦，这里返回的是原构造函数中的一个拷贝之后的版本，当占用内存多的时候，可以考虑使用结构体指针。</li>
</ul>
<h2 id="结构体匿名字段"><a href="#结构体匿名字段" class="headerlink" title="结构体匿名字段"></a>结构体匿名字段</h2><ul>
<li><pre><code class="go">type person struct{
    string
    int
}//相同类型只能写一个
<figure class="highlight nim"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs nim"><br>- 适用于字段少，简单且不常用的情况<br><br>- 访问特定元素时，例如访问<span class="hljs-type">string</span>，这个时候把<span class="hljs-type">string</span>作为成员的名字，可以通过.名字直接进行访问。<br><br><span class="hljs-comment">## 嵌套嗷呜!</span><br><br>- 禁止套娃？（结构体套用结构体）<br><br>- ```go<br>  <span class="hljs-keyword">type</span> address struct{<br>  	province <span class="hljs-type">string</span><br>      city <span class="hljs-type">string</span><br>  }<br>  <br>  <span class="hljs-keyword">type</span> person struct{<br>      name <span class="hljs-type">string</span><br>      age <span class="hljs-type">int</span><br>      <span class="hljs-keyword">addr</span> address<br>  }<br>  <br>  p1 := person{<br>      name : <span class="hljs-string">""</span><br>      age : <br>      <span class="hljs-keyword">addr</span>: address{<br>          province: <span class="hljs-string">""</span><br>          city: <span class="hljs-string">""</span><br>      }<br>  }<br></code></pre></td></tr></tbody></table></figure>
</code></pre>
</li>
<li><p>匿名嵌套结构体:(感觉很好用的样子嗷呜！！！)</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span>{<br>	province <span class="hljs-type">string</span><br>	city <span class="hljs-type">string</span><br>	address<br>}<br><br><br>p1 := person{<br>    name : <span class="hljs-string">""</span><br>    age : <br>    address: address{<br>        province: <span class="hljs-string">""</span><br>        city: <span class="hljs-string">""</span><br>    }<br>}<br></code></pre></td></tr></tbody></table></figure>

<p>这样之后就能够直接通过<code>p1.city</code>等方式访问内部元素</p>
<p>步过要注意，有可能产生匿名结构体的冲突，比如说几个都有city这个元素，嵌套一个可以，多个的话为了防止冲突最好不用。</p>
</li>
<li><p>构造结构体的函数，可以专门写一个构造函数<code>return struct</code>，然后每次调用这个构造函数就会十分的方便简单。</p>
</li>
</ul>
<h1 id="方法和接收者"><a href="#方法和接收者" class="headerlink" title="方法和接收者"></a>方法和接收者</h1><ul>
<li>有点像类的方法那种感觉啦(方法是作用于特定类型的函数)</li>
<li>声明: <code>func (d dng) wang()</code>，推荐用类型的首字母小写来声明这个类型的一个变量。</li>
<li>go语言中如果标识符首字母是大写的，就表示对外部包可见，类似于java中的public。</li>
<li>注意，如果函数的首字母大写对外可见，那么函数的返回值首字母也要大写，不然类型就不匹配。</li>
<li>对于这种标识符都应该加上注释</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//Dog 是一个关于狗的结构体</span><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span>{<br>	name <span class="hljs-type">string</span><br>}<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li><p>接收者只能有一个嗷呜</p>
</li>
<li><p>同时还是要注意函数传值传址嗷呜，就算是方法传址也才能改变对象的值。</p>
</li>
<li><p>使用指针传递内容的情况：</p>
<ul>
<li>需要修改接收者中的值</li>
<li>接收者是拷贝开销比较大的大对象</li>
<li>一致性，某个方法传入指针，最后其他的都一样传入指针。</li>
</ul>
</li>
<li><p>添加方法只能给自己定义的type添加方法，不能给别的包定义方法。比如说你想给int设置方法，是不可以的，但是你可以自己写一个对象为int，<code>type myInt int</code>这样构造一个然后再定义方法就可以。</p>
</li>
<li><p><code>var x int32 = 10</code>与<code>x := int32(10)</code>与<code>var a = myInt(100)</code>，这个东西是强制类型准换哈，这个不是方法函数。</p>
</li>
<li><pre><code class="go">s1 := map[string]int{
    "liu" : 5,
    "yi" : 10
    "hao" : 23
}
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><br><br><br><br><br><br># 结构体模拟实现继承<br><br>- <br><br>```go<br>func animal <span class="hljs-keyword">struct</span>{<br>	name <span class="hljs-built_in">string</span><br>}<br><br>func (a animal) move<span class="hljs-literal">()</span>{<br>    fmt.<span class="hljs-constructor">Println(<span class="hljs-string">"唱跳rap篮球"</span>)</span><br>}<br><br><span class="hljs-keyword">type</span> dog <span class="hljs-keyword">struct</span>{<br>	feet uint8<br>	animal<br>}<br><br>func (d dog) wang<span class="hljs-literal">()</span>{<br>	fmt.<span class="hljs-constructor">Printf(<span class="hljs-string">"%s在叫：汪汪汪~"</span>,<span class="hljs-params">d</span>.<span class="hljs-params">name</span>)</span><br>}<br><span class="hljs-comment">//可以用dog调用animal方法</span><br><span class="hljs-comment">//可以用dog来调用animal属性</span><br></code></pre></td></tr></tbody></table></figure>
</code></pre>
</li>
<li><p>dog中拥有了animal就相当于继承了animal</p>
</li>
</ul>
<h1 id="结构体与JSON"><a href="#结构体与JSON" class="headerlink" title="结构体与JSON"></a>结构体与JSON</h1><ul>
<li>把go语言中的结构体转换为json格式，并且把json格式能转回go语言</li>
<li><code>json.Marshal(struct)</code></li>
<li>格式化功能在json包里面做的，要在json包里拿到属性和字段，注意要用大写嗷。或者还有一种做法：</li>
<li>反引号引号起来就可以以自定义的名字访问</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">Name <span class="hljs-type">string</span> <span class="hljs-string">'json:"name" db:"name"'</span><br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>反序列化: <code>json.Unmarshal(type,&amp;target)</code>（这里要是指针哦，得到了一个值然后传入要地址鸭！）</li>
<li>target为一个指针嗷呜！</li>
</ul>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><ul>
<li><p>接口是一种类型，和普通的类型没有差别，可以作为返回值啊等等等等。（面向接口编程的趋势）</p>
</li>
<li><p>应用场景： 给出一个模板，需要的类实现这个模板，规定了变量有哪些方法</p>
</li>
<li><pre><code class="go">type speaker interface{
    speak()  //只要实现了speak方法都是speaker类型
}

func (c cat) speak(){
    fmt.Println("miao~")
}

func da(x speaker){
    x.speak()
}
<figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> 只要实现了接口中规定的所有类型，那么这个变量就可以当作接口实现的类型的变量。<br><br><span class="hljs-bullet">-</span> 但你想到有多个对象有同一个方法的时候，就可用接口了，实现了接口就实现了方法。<br><br><span class="hljs-bullet">-</span> 甚至可以用接口变量来接收实现的接口,可以指向实现的接口。<br><br><span class="hljs-bullet">-</span> 多个类型可以实现一个接口，一个类型也可以实现多个接口。<br><br><span class="hljs-bullet">-</span> 接口可以嵌套！<br><br><span class="hljs-section">## 使用值和指针接收者不同嗷</span><br><br><span class="hljs-bullet">-</span> 实现值接收者，结构体和结构体指针的变量都能存。<br><span class="hljs-bullet">-</span> 实现指针接收者，只能拿存结构体类型的变量。<br><span class="hljs-bullet">-</span> 用指针接收者往往更加常用嗷！<br><br><span class="hljs-section">## 空接口</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-code">`type xx interface{}`</span><br><br><span class="hljs-bullet">-</span> 接口中啥都没有，意味着所有类型都实现了这个接口，意味着这个接口能接收所有的对象。（有点像Object?）<br><br><span class="hljs-bullet">-</span> 空接口没有必要起名<br><br><span class="hljs-bullet">-</span> <span class="hljs-code">```go</span><br><span class="hljs-code">  m1 := map[string]interface{}</span><br><span class="hljs-code">  m1 = make(map[string]interface{},10)</span><br><span class="hljs-code">  m1["hobby"] = [...]string{"a","b"}</span><br></code></pre></td></tr></tbody></table></figure>
</code></pre>
</li>
<li><p>相当于多种类型的集合！！！传入啥类型都可以！！！</p>
</li>
<li><p>类型断言： </p>
<ul>
<li><p>```go<br>a.(type)</p>
<p>func assign(a interface{}){<br>switch v := a.(type){<br>    case string:<br>        body1<br>    case int:<br>        body2<br>    case bool:<br>        body3<br>    default:<br>        body4<br>}<br>}// switch a.(type){}也可以</p>
<figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">  -</span> int64与int是两个完全不同的类型<br><br><span class="hljs-section"># package</span><br><br><br><br><span class="hljs-bullet">-</span> 组织go语言的一个单位。<br><br><span class="hljs-bullet">-</span> 只有main包才能组织成一个文件。<br><span class="hljs-bullet">-</span> 只有大写的元素和函数才能被跨包访问，小写表示私有。<br><span class="hljs-bullet">-</span> 导入的包名应该紧接在package后面。<br><span class="hljs-bullet">-</span> 禁止套娃，不能相互嵌套。<br><span class="hljs-bullet">-</span> <span class="hljs-code">`import 别名 "包的路径"`</span>。<br><span class="hljs-bullet">-</span> 匿名导入包 <span class="hljs-code">`import _ "路径"`</span>。<br><span class="hljs-bullet">-</span> 导入会自动触发init()函数，当import恶的时候会自动调用。<br><span class="hljs-bullet">-</span> init在导入的全局声明和main之间执行。<br><span class="hljs-bullet">-</span> 从外往里调用import本质上是从里往外调用<span class="hljs-code">`init()`</span>方法。<br><br><br><br><br><br><span class="hljs-section"># 文件操作(日志库作业)</span><br><br><span class="hljs-bullet">-</span> 接口：不同的模式对应的文件操作不一样，可以输出到终端和文件中<br><br><span class="hljs-section">## 打开/关闭文件</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-code">```go</span><br><span class="hljs-code">  // 打开文件</span><br><span class="hljs-code">  fileObj,ok := os.Open("./main.go")// 返回一个文件指针，可以用绝对路径</span><br><span class="hljs-code">  if ok != nil{</span><br><span class="hljs-code">      fmt.Printf("Open file failed , err:%v",err)</span><br><span class="hljs-code">      return</span><br><span class="hljs-code">  }</span><br><span class="hljs-code">  defer fileObj.close()</span><br></code></pre></td></tr></tbody></table></figure></li>
</ul>
</li>
</ul>
<h2 id="读写文件"><a href="#读写文件" class="headerlink" title="读写文件"></a>读写文件</h2><h3 id="读文件："><a href="#读文件：" class="headerlink" title="读文件："></a>读文件：</h3><ul>
<li><pre><code class="go">var temp = make([]byte,128) //指定读的长度
// 或者是:var temp = [128]byte
n , error = fileObj.Read(temp[:])// 一次读128个进入切片(n是读入的数，error是出的问题)
if error != nil{
    body
}
fmt.Println(string(temp[:n]))读取文件需要一个切片作为参数，先构造切片，然后读入切片中即可
<figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- `bufio`读取文件（一样要先`os`打开文件）<br><br>```go<br>reader := bufio.NewReader(fileObj)//创建对象<br><span class="hljs-built_in">line ,</span> err := reader.ReadnString('\n')<br>if err == io.EOF{<br>    <span class="hljs-keyword">return</span><br>}<br>if err != nil{<br>    body<br>}<br>// 这里可以从reader中选择读取方式并返回<br></code></pre></td></tr></tbody></table></figure>
</code></pre>
</li>
<li><p><code>ioutil</code>读取文件：</p>
<ul>
<li><code>ret , err := ioutil.ReadFile(Filename)</code>直接读取整个文件 , 这里readfile后买你的参数直接接的就是文件，不需要像上面一样先打开文件哦。</li>
</ul>
</li>
</ul>
<h3 id="写文件"><a href="#写文件" class="headerlink" title="写文件:"></a>写文件:</h3><ul>
<li>```go<br>os.OpenFile(name,flag,mode)//打开文件的模式<figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- 这里的flag本质上为十六进制数（其实底层为二进制），可以指定多种状态`os.O_APPEND|os.O_CREATE `， 可用二进制中的<span class="hljs-string">"|"</span>来表示，本质为二进制的位运算来确定模式。哪一位为<span class="hljs-number">1</span> ， 代表着激活了那种模式。<br><br>- 用`fileObj.write(切片)`和`fileObj.WriteString(sting)`可以写入文件<br><br>- 注意哈，文件开完了之后要关上的！<br><br>- 默认好多模式嗷，对着模式去选择就好啦<br><br>- 和上面读文件一样，这里需要写文件也有三种方式<br><br>```go<br>bufio.NewWriter(fileObj)<br>wr.WriteString(<span class="hljs-string">"..."</span>)<br>wr.Flush() // 将缓存中的内容写入文件中<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">err := ioutil<span class="hljs-selector-class">.WriteFile</span>(filename,<span class="hljs-selector-attr">[]</span><span class="hljs-built_in">byte</span>(str),<span class="hljs-number">0666</span>)<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>注意, Scanln只要读到空白符就停止了，如果想读入空白符怎么做？</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s <span class="hljs-type">string</span><br>reader := bufio.NewReader(os.Stdin)<br>s, _ = reader.ReadString(<span class="hljs-string">'\n'</span>)<br>fmt.Printf(<span class="hljs-string">"..."</span>)<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>bufio.Reader本质上为一个接口类型</li>
</ul>
<h2 id="文件中间插入内容"><a href="#文件中间插入内容" class="headerlink" title="文件中间插入内容"></a>文件中间插入内容</h2><ul>
<li>原理用脑子想一想</li>
<li>可以在库中找到对应的方法嗷呜！</li>
<li>可以用fileObj.seek(跨过的长度，文件的初始位置)，光标移动到要插入内容的位置。</li>
<li><code>os.O_RDWR</code>设置文件可读可写，然后借助seek定位</li>
<li>再向文件中写入内容即可</li>
<li>切片不能用new初始化哦</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> s []<span class="hljs-type">byte</span><br>s = []<span class="hljs-type">byte</span>{<span class="hljs-string">'c'</span>}<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>新写的内容会覆盖原有的内容哦</li>
<li>要实现插入内容，一般都要新建中间文件，在中间文件中实现之后再导入到目标文件中。（读入之前的，插入目的数，紧接后面的）</li>
<li>文件关了之后再操作哦，比如可以把中间文件重命名为我要的目的文件即可，把以前的文件直接覆盖哦。</li>
</ul>
<h1 id="time标准库"><a href="#time标准库" class="headerlink" title="time标准库"></a>time标准库</h1><ul>
<li>常用函数: <code>time.Now()/Year()/Date()/Hour()/Minute()/Second()/Day()</code></li>
<li>时间戳: <code>.Unix()或者是.UnixNano()</code>,从1970年一月一日到现在的时间</li>
<li>时间间隔：</li>
</ul>
<p><code>.Second</code>啊等等属性</p>
<ul>
<li>一些操作：<ul>
<li>.Add   e.g.  <code>now.Add(24 * time.Hour)</code></li>
<li>.Sub</li>
<li>.Equal</li>
<li>.Before</li>
<li>.After</li>
</ul>
</li>
<li>定时器</li>
</ul>
<p><code>timer := time.Tick(time.Second)</code> // 每隔一秒钟执行一次</p>
<ul>
<li><p>时间格式化：</p>
<ul>
<li><p>2006 1 2 3 4 5   这个是go诞生的时间，用于格式化时间</p>
</li>
<li><pre><code class="go">fmt.Println(now.Format("2006-01-02"))
<figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- ```go<br>  fmt.Println(now.Format(<span class="hljs-string">"2006/01/02 15:04:05"</span>))<br></code></pre></td></tr></tbody></table></figure>
</code></pre>
</li>
<li><pre><code class="go">fmt.Println(now.Format("2006/01/02 15:04:05 PM"))
<figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- ```<br>  fmt.Println(now.Format(<span class="hljs-string">"2006/01/02 15:04:05.000"</span>))<br></code></pre></td></tr></tbody></table></figure>
</code></pre>
</li>
<li><p><code>.Parse</code>函数用于格式化把字符串转换为时间</p>
</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">time := time.Parse(<span class="hljs-string">"2006-01-02 15:04:05"</span>,<span class="hljs-string">"2020-10-27 19:12:39"</span>)<br></code></pre></td></tr></tbody></table></figure></li>
</ul>
<h2 id="time库的补充内容"><a href="#time库的补充内容" class="headerlink" title="time库的补充内容"></a>time库的补充内容</h2><ul>
<li>一些标准化的内容:</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go">Microsecond<br>Millisecond<br>Second<br>Minute<br>Hour     <span class="hljs-comment">//这些都是定义好的标准时间嗷！</span><br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>Sub函数的调用:</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">nextYear , err := time.Parse(<span class="hljs-string">"2006-01-02,2020-01-01"</span>)<br><br>now.Sub(nextYear)<br></code></pre></td></tr></tbody></table></figure>

<p>注意，这里减的是一个时间对象嗷，不是减去时间。</p>
<ul>
<li><p>时区指定</p>
</li>
<li><p><code>sleep(d duration)</code>(本质为int64)</p>
</li>
<li><pre><code class="go">n := 100
time.Sleep(time.Duration(n))

time.Sleep(100)
<figure class="highlight stylus"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><br>如果直接传入参数，直接帮你传。如果用变量则需要手动住那换一样嗷！！！<br><br>- ```go<br>  n := <span class="hljs-number">5</span><br>  <span class="hljs-selector-tag">time</span><span class="hljs-selector-class">.Sleep</span>(<span class="hljs-selector-tag">time</span><span class="hljs-selector-class">.Duration</span>(n)*<span class="hljs-selector-tag">time</span>.Second)<br></code></pre></td></tr></tbody></table></figure>
</code></pre>
</li>
<li><p>时区的确定和转换:</p>
</li>
</ul>
<p><code>Parse</code>这个玩意没有时区的概念，就是标准时间，不是东八区的时间，这个时候就要获取时区。</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">loc , err := time.LoadLocation(<span class="hljs-string">"Asia/Shanghai"</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span>{<br>    fmt.Println(<span class="hljs-string">"Load loc failed, err:%v\n"</span>,err)<br>    <span class="hljs-keyword">return</span><br>}<br><br>timeObj , err := time.ParseInLoaction(<span class="hljs-string">"2006-01-02 15:04:05"</span>,<span class="hljs-string">"2019-08-04 14:41:50"</span>,loc)<br><br>fmt.Println(time.Obj)<br></code></pre></td></tr></tbody></table></figure>

<p>只有在时区相同的情况下做加减计算才有意义啊！</p>
<h1 id="runtime-Caller"><a href="#runtime-Caller" class="headerlink" title="runtime.Caller"></a><code>runtime.Caller</code></h1><ul>
<li><p>```go<br>pc , file , line , ok := runtime.Caller(0)</p>
<p>if !ok{<br>body<br>}</p>
<p>// 这里的0表示调用层数，0表示调用函数的第一层，1就表示调用函数的第二层（由内往外找层数）。<br>// file表示调用的文件名 , line表示调用的函数所在的行，ok表示时候调用成功</p>
</li>
</ul>
<p>funcname := runtime.FuncForPC(pc).Name()<br>  //拿到对应层的函数名<br>  path.Base(file)<br>  //拿到对应的文件名<br>  </p><figure class="highlight fortran"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs fortran">  <br>- 这就是一个库能够拿到调用它的函数对应的行，还有函数名等等，比如在日志库中有相应的应用<br><br><br><br><br><br># 反射<br><br>- 用的少但是原理要知道<br><br>- ```go<br>  func reflectType(x <span class="hljs-keyword">interface</span>{}){<br>      v := reflect.TypeOf(x)<br>      <span class="hljs-keyword">name</span> := v.<span class="hljs-keyword">Name</span>()<br>      <span class="hljs-keyword">kind</span> := v.<span class="hljs-keyword">Kind</span>()<br>  }<br></code></pre></td></tr></tbody></table></figure><p></p>
<ul>
<li><pre><code class="go">v := reflect.ValueOf(x)
v.Kind() // 值的类型种类
v.Int() / v.Float()
reflect.Int64 / reflect.Float32
// 这里取了一个v作为value的种类,它可以去和reflect下的值比较，但是调用的时候，只有第三行两种形式，如果需要int64 , 还需要int64(v.Int())这种方式强制类型转换。
<figure class="highlight scss"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scss"><br>- 通过反射设置变量的值，一样要用指针<br><br>```go<br>func <span class="hljs-built_in">reflectSetValue</span>(x interface{}){<br>	v := reflect.<span class="hljs-built_in">ValueOf</span>(x)<br>    if v.<span class="hljs-built_in">Elem</span>().<span class="hljs-built_in">kind</span>() == reflect.Int64{<br>		v<span class="hljs-selector-class">.Elem</span>()<span class="hljs-selector-class">.SetInt</span>(<span class="hljs-number">200</span>)<br>	}<br>}<br><span class="hljs-comment">// 这里的x要是指针</span><br></code></pre></td></tr></tbody></table></figure>
</code></pre>
</li>
<li><p>还有类似的函数 : <code>isNil() , isValid()</code></p>
</li>
</ul>
<figure class="highlight reasonml"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">reflect.<span class="hljs-constructor">ValueOf(<span class="hljs-params">a</span>)</span>.is<span class="hljs-constructor">Valid()</span><br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>结构体指针</li>
</ul>
<h1 id="strconv标准库简介"><a href="#strconv标准库简介" class="headerlink" title="strconv标准库简介"></a>strconv标准库简介</h1><ul>
<li>用于类型转换，有的时候不能进行强制类型转换</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">ret2 := <span class="hljs-type">string</span>(<span class="hljs-number">97</span>)<br></code></pre></td></tr></tbody></table></figure>

<p>这里就是把97转换为对应的char类型，就有问题</p>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">fmt.Sprintf(<span class="hljs-string">"%d"</span>,<span class="hljs-number">97</span>)<br></code></pre></td></tr></tbody></table></figure>

<p>这里返回一个字符串嗷，可以获得数字对应的字符串</p>
<ul>
<li><pre><code class="go">fmt.ParseInt(str,10,64)
<figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>这里表示把str转换为十进制六十四位 , 如果传入的是<span class="hljs-number">0</span>的话就变成int<br><br>- `strconv.Atoi()`字符串转换为int类型可以直接用这个<br>- `strconv.Itoa()`int类型转换为字符串<br>- `boolValue , _ := strconv.ParseBool(boolstr)`<br>- `.ParseFloat()`<br><br># 并发<br><br>## goroutine<br><br>- ```go<br>  func hello(){<br>  	fmt.Println(<span class="hljs-string">"hello"</span>)<br>  }<br>  <br>  func main(){<br>      go hello()<br>      time.Sleep(time.Second)<br>      fmt.Println(<span class="hljs-string">"main"</span>)<br>  }<br></code></pre></td></tr></tbody></table></figure>
</code></pre>
</li>
<li><p>传入go的要是一个包装好的函数哦</p>
</li>
<li><p>main函数结束了，它生成的所有线程都会结束</p>
</li>
<li><p>见<code>vscode</code>中的例子有更加深入的理解哦</p>
</li>
</ul>
<h3 id="关于goroutine的一些底层的知识"><a href="#关于goroutine的一些底层的知识" class="headerlink" title="关于goroutine的一些底层的知识"></a>关于goroutine的一些底层的知识</h3><ul>
<li>goroutine和线程:<ul>
<li>goroutine和os线程的栈内存不一样，goroutine内存很小，但是可以扩容。（可扩展的栈）</li>
<li>GMP调度 ， g为goroutine的，存了goroutine信息和与P绑定的信息，这里p管理一组goroutine队列，为队列做调度，保证最大效率的利用goroutine队列。m是go运行时对于操作系统内核线程的虚拟，是一一映射的关系，一个goroutine最终是要放在M上执行的。p和m也一般是一一对应的</li>
<li>goroutine初始栈的大小是2k.</li>
</ul>
</li>
</ul>
<h2 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h2><ul>
<li>goroutine对应的函数执行结束的时候，goroutine就结束了。</li>
<li>main函数结束了，main函数创建的goroutine就都结束了</li>
</ul>
<p>那么怎么样协调时间呢？</p>
<h3 id="如何优雅的等其它线程结束"><a href="#如何优雅的等其它线程结束" class="headerlink" title="如何优雅的等其它线程结束"></a>如何优雅的等其它线程结束</h3><ul>
<li><code>var wg sync.WaitGroup</code></li>
<li>只能有一个这种计数器，不能有多个。只有当计数器为0的时候，main函数才能退出</li>
<li>在每一个线程中: <code>wg.Add(1)</code> ， 当一个线程结束了之后，wg才会减一。<code>wg.Done()</code>，在线程结束的时候添加，推荐在线程执行的函数中第一行用<code>defer wg.Done()</code>。</li>
<li>每一个线程开始时，Add记录一下，结束时Done()删除一下。</li>
<li>函数的最后要用<code>wg.Wait()</code></li>
</ul>
<h3 id="math-x2F-rand"><a href="#math-x2F-rand" class="headerlink" title="math/rand"></a>math/rand</h3><ul>
<li><pre><code class="go">rand.Seed()
rand.Int()
rand.Intn(n)//生成一个[0，n)之间的整数
<figure class="highlight autohotkey"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><br>- 在go里面编译好了之后，种子就固定了，如果想每次生成的不一样，那么要在函数中设置种子并且传入不同的值，比如时间。（注意这里和c语言不同哦。）<br><br>- 默认生成的都是正数，如果需要负数的话`0-rand.Int()`类似于这样即可<br><br>- .Sleep接受的是duration类型  time.Sleep(time.Millisecond * time.Duration(rand.Intn(<span class="hljs-number">300</span>)))这样返回的就是Duration类型，可以这么转换整数为duration.<br><br>## `runtime.GOMAXPROCS`<br><br>- 设置处理的cpu的数量，如果作为日志监控等可以占用的少一点<br>- `runtime.NumCPU()`返回使用的CPU的个数<br>- 一个线程对应多个goroutine<br>- 一个程序可以使用多个操作系统线程<br><span class="hljs-title">- goroutine和os线程时多对多的关系,  m:</span>n , 把m个goroutine分配个n个操作系统线程去执行<br><br><br><br># Channel(通道)<br><br>### 初始化<br><br>- 共享内存进行数据交换时，可能发生问题，这个时候就应该加锁，要改成通过通信来共享内存。goroutine是go程序并发的执行体，channel就是他们之间的连接。channel是可以让一个goroutine发送到另外一个goroutine的通信机制。<br>- `var 变量 chan 元素类型`，channel是一种特殊的类型，本质为一个队列，遵循First in first out的规则。<br>- 通道的初始化   `b = make(chan int)`<br>- 通道必须初始化才能使用<br>- `var ch3 chan []int` 声明一个传递int切片的通道<br>- `make(chan 元素类型，[缓冲大小])` 含有带有缓冲区的通道的初始化 , 缓冲区如果不存在的话，无法向里面传递信息，因为无位置接收。<br>- 通道里面的类型小一点好，如果大的话，用指针会好哦。<br><br>### 发送与接收<br><br>- `ch &lt;- <span class="hljs-number">10</span>`<br>- `x := &lt;- ch `<br>- 可以跨越线程进行值的输入与输出<br>- 只有`b&lt;-`，如果b没有缓冲区，则无法成功输入，如果`x := &lt;-b`，b中还没有值，则程序会等待b的输入<br><span class="hljs-title">- 通道的关闭 :</span> `close(channel)` ， 不关也没问题的<br>- `f<span class="hljs-literal">or</span> i := range ch1{}` 这个也是作用于通道<br>- 关闭通道后不可以往通道里面再写数据，但是可以从通道里面读数据。往线程里写完数据之后还是最好, close(线程)这样来保证线程的安全。<br><br>### 单向通道<br><br>- 只能读入或者输出，常用于一些函数，限制通道的功能(当通道只能进行某一些操作时)<br>- `func f1(ch1 &lt;-chan int) || func f2(ch2 chan&lt;- int)`<br><br>### 数据读取<br><br>- ```go<br>  for{<br><span class="hljs-built_in">  	x ,</span> ok := &lt;-channel<br>  	if !ok{<br>  		<span class="hljs-keyword">break</span><span class="hljs-comment">;</span><br>  	}<br>  	else{<br>  		fmt.Println(x)<br>  	}<br>  }<br></code></pre></td></tr></tbody></table></figure>
</code></pre>
</li>
<li><p>这里如果channel为空，会等待，直到channel中没有值才会退出</p>
</li>
<li><p>什么时候ok是false , 直到通道close掉，这个才为false,所以要人为去close掉通道，才能退出！</p>
</li>
<li><p>for , range是一样的，会等待通道内的值，只有通道关闭才会退出循环，所以在程序中要记得close嗷！</p>
</li>
</ul>
<h3 id="其它的一些操作"><a href="#其它的一些操作" class="headerlink" title="其它的一些操作"></a>其它的一些操作</h3><ul>
<li><code>var once sync.Once</code>然后<code>once.Do(func(){...})</code>这样就可以使得某一段函数只执行一次，例如多个容器接收，一次关闭某个特定的通道</li>
<li>关于关闭的通道可以继续读取通道，当读取完元素之后依旧可以继续读取，读取的是对应类型的零值。</li>
<li>通道由两个返回值，一个是真正的返回值，第二个是true或者false即是否读取到了值，就算ok为false，一样可以读取到对应的返回值。</li>
</ul>
<h3 id="通道的状态"><a href="#通道的状态" class="headerlink" title="通道的状态"></a>通道的状态</h3><p>![image-20201105184844101](C:\Users\Alexander Liu\AppData\Roaming\Typora\typora-user-images\image-20201105184844101.png)</p>
<ul>
<li>关闭已经关闭的channel就会panic</li>
<li>如果所有的goroutine都在等一个阻塞的channel这个时候程序会发生死锁。</li>
<li>goroutine的泄露，如果后台在等一个阻塞的channel，主程序能够运行，这个时候可以正常运行，但是后台goroutine占着一块儿内存始终不会释放，这个时候造成了goroutine的泄露。</li>
</ul>
<h3 id="匿名结构体计数通道"><a href="#匿名结构体计数通道" class="headerlink" title="匿名结构体计数通道"></a>匿名结构体计数通道</h3><figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go">notifyCh  &lt;-  <span class="hljs-keyword">struct</span>{}{}<br><span class="hljs-comment">//不占任何内存，构造出来用于记录数量</span><br>	<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>{<br>    <span class="hljs-keyword">for</span> i:=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++{<br>        &lt;-notifyCh<br>    }<br>    <span class="hljs-built_in">close</span>(results)<br>}()<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>如果能取到5个值，说明这个通道里面目的数据量都被传满了，这个时候就可以去取真实的值了。这这个线程也会一直等着，直到目标容量被存满之后，才会关闭对应的通道。非常非常有用。</li>
</ul>
<h1 id="select多路复用"><a href="#select多路复用" class="headerlink" title="select多路复用"></a>select多路复用</h1><ul>
<li><pre><code class="go">select{
    case &lt;-ch1:
    
    case data := &lt;-ch2:
    
    case ch3&lt;-data:
    
    default:
}
<figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> 哪个能成走哪个，若多个能走从中随便选一个嗷。<br><br><span class="hljs-bullet">-</span> 空的select可以用于阻塞main函数，程序会运行到这里然后一直等哦<br><br><span class="hljs-section"># Channel重大发现嗷</span><br><br><span class="hljs-bullet">-</span> 当多个任务无法区分时，可以用多个线程分别执行，思考之间的关系，在主程序中去进行wait和close之类的操作，可以很好的解决通道的问题！！！<br><br><br><br><br><br><span class="hljs-section"># sync包中的互斥锁</span><br><br><span class="hljs-bullet">-</span> 实现了对于公共空间的元素的访问的操作,对于公共资源的操作和访问时，就先加锁。<br><span class="hljs-bullet">-</span> <span class="hljs-code">`var lock sync.Mutex`</span>and<span class="hljs-code">`lock.Lock()`</span>and<span class="hljs-code">`lock.Unlock()`</span><br><br><span class="hljs-section">## 读写互斥锁</span><br><br><span class="hljs-bullet">-</span> 用于读的次数远大与写的次数<br><span class="hljs-bullet">-</span> 分为读锁和写锁两个锁，读锁的时候可以继续获取，写锁的时候别的锁就要先等一等。<br><span class="hljs-bullet">-</span> <span class="hljs-code">`sync.RWMutex`</span><br><br><br><br><span class="hljs-section"># sync.Once</span><br><br><span class="hljs-bullet">-</span> <span class="hljs-code">`.Do(func())`</span>只做一次，once.Do()保证了某个函数仅仅执行一次，要求函数苛刻，传入的函数要求没有参数也没有返回值，因此这个时候，可能会使用到函数闭包。<br><br><span class="hljs-code">`f := func(){close(channel)}`</span><br><br><br><br><span class="hljs-section"># sync.Map</span><br><br><span class="hljs-bullet">-</span> Go内置的map不是并发安全的<br><span class="hljs-bullet">-</span> 这个时候自己可以加锁嘛，go内置了一些开箱即用的map - <span class="hljs-code">`sync.Map`</span>，定义了一些Store和Load等方法<br><br><span class="hljs-bullet">-</span> 开箱即用意味着map不用初始化<br><br><span class="hljs-code">```go</span><br><span class="hljs-code">var m2 = sync.Map{}</span><br><span class="hljs-code">var wg sync.Waitgroup</span><br><span class="hljs-code"></span><br><span class="hljs-code">func main(){</span><br><span class="hljs-code">    for i:=0;i&lt;21;i++{</span><br><span class="hljs-code">        wg.Add(1)</span><br><span class="hljs-code">        go func(n int){</span><br><span class="hljs-code">            key := strconv.Itoa(n)</span><br><span class="hljs-code">            m2.Store(key, n)</span><br><span class="hljs-code">            value,_ := m2.Load(key)</span><br><span class="hljs-code">            wg.Done()</span><br><span class="hljs-code">        }(i)</span><br><span class="hljs-code">    }</span><br><span class="hljs-code">}</span><br></code></pre></td></tr></tbody></table></figure>
</code></pre>
</li>
<li><p>必须使用sync.map内部自带的Store来存值，用Load来取值，用特定的方法来取值。</p>
</li>
</ul>
<h1 id="atomic原子性操作"><a href="#atomic原子性操作" class="headerlink" title="atomic原子性操作"></a>atomic原子性操作</h1><ul>
<li><p>原子性操作自动帮你加锁，去锁。</p>
</li>
<li><pre><code class="go">func main(){
    atomic.AddInt64(&amp;x,1)
}
//内置的加法函数
<figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> 有一系列的相关操作来保证功能的实现。<br><br><br><br><br><br><span class="hljs-section"># 网络编程</span><br><br><span class="hljs-section">## 协议和层</span><br><br><span class="hljs-bullet">-</span> 物理层：把电脑连接起来的物理手段，传送0，1信号<br><span class="hljs-bullet">-</span> 数据链路层：规定解读电信号的方式，“以太网”协议占据主导，然后将数据分为帧发送。以太网规定了网卡接口有唯一的地址，就可以确定某一个网卡。<br><span class="hljs-bullet">-</span> 网络层：网络地址和MAC协议，IPv4和IPv6两个协议，最多发65535个字节<br><span class="hljs-bullet">-</span> 传输层：通过MAC地址和IP地址，可以建立通信，还有一个参数叫端口，确定是电脑哪个程序，上述三个确定了唯一一个电脑上的某个程序。TCP和UCP两种，三次握手，四次挥手等等orz , 时效性高用UCP , TCP则保证数据的稳定性<br><span class="hljs-bullet">-</span> 应用层：建立在传输层之上，不停的加上不同的协议，最后得到一个物理层的传输数据。<br><br><br><br><span class="hljs-section">## socket编程</span><br><br><span class="hljs-bullet">-</span> TCP/IP都要用到socket , socket是一个抽象层，处于传输层和应用层之间。<br><span class="hljs-bullet">-</span> 一个TCP连接多个客户端，go中的并发性高<br><span class="hljs-bullet">-</span> TCP处理流程：<br><span class="hljs-bullet">  -</span> 监听端口<br><span class="hljs-bullet">  -</span> 接收客户端请求建立来凝结<br><span class="hljs-bullet">  -</span> 创建goroutine处理链接<br><br><br><br><br><br><br><br><span class="hljs-section"># os.Args</span><br><br><span class="hljs-bullet">-</span> 获取命令行参数<br><span class="hljs-bullet">-</span> 可以以os.Args[num]的方式获取某个输入参数<br><br><span class="hljs-section"># Flag</span><br><br><span class="hljs-bullet">-</span> 创建一个标志位参数<br><br><span class="hljs-code">`name := flag.String("name","ask","b")`</span>,这个时候的name时一个指针，指向某个分配了位置的内存地址。<br><br><span class="hljs-bullet">-</span> 可以通过<span class="hljs-code">`--help`</span>来体现到底有哪些方法<br><br><span class="hljs-bullet">-</span> <span class="hljs-code">```go</span><br><span class="hljs-code">  name := flag.String("name","ask","Enter your name")</span><br><span class="hljs-code">  flag.Parse()</span><br><span class="hljs-code">  fmt.Println(*name)</span><br></code></pre></td></tr></tbody></table></figure>
</code></pre>
</li>
<li><p><code>age := flag.Int("age",18,"请输入真实姓名")</code></p>
</li>
<li><p>有Int , Sting ,Bool ,Duration等方法，这些方法都用于构造某个标志位，可以返回一个指针，通过特定的指针访问某个用户输入的特定的属性。</p>
</li>
<li><p><code>flag.exe -name=兔子姐姐 -age=10000</code>这样即为用户端输入。</p>
</li>
<li><p><code>var name string</code> , <code>flag.StringVar(&amp;name,"name","ask","Enter your name")</code></p>
</li>
</ul>
<p>这种方式也可以，并且不用执政，得到的就是纯纯的变量本身嗷。</p>
<ul>
<li><code>flag.Args() , flag.NArg() , flag.NFlag()</code></li>
<li>第一个时返回[]string参数，返回命令行后面其它参数；第二个时返回其它参数的个数，第三个时返回命令行参数的个数</li>
</ul>
<h1 id="TCP粘包"><a href="#TCP粘包" class="headerlink" title="TCP粘包"></a>TCP粘包</h1><ul>
<li>传送数据的时候，可能会同时发送多个数据</li>
<li>如果发送的时间间隔长的话，一次就只会发送一个数据</li>
<li>可以自己定义协议来定义包头和长度</li>
<li>详情参见代码</li>
</ul>
<h1 id="net-http"><a href="#net-http" class="headerlink" title="net/http"></a><code>net/http</code></h1><ul>
<li>首先这个包写的非常好，可以直接用来写一些小型的服务端</li>
<li>和前端的知识有的融合在一起了，<code>HandleFunc(request,func)</code>可以获得对应字段进行数据处理，读取对应的页面文件和CSS文件并传输给服务端。详情参见vscode中的例子</li>
<li><code>ListenAndServe</code>函数可以用于监听某一个端口号，作为服务端等待客户端向其发送的请求</li>
<li><code>http-client</code>中，url的构建可以采用，新建一个<code>url.Values{}</code>，然后再再不断地set元素的值，最后采用<code>urlStr = data.Encode()</code>，这个时候再去get就可以使用<code>http.NewRequest("GET",urlStr,nil)</code>这个方式来获得新的url。下面为构建url对象：</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go">apiUrl := <span class="hljs-string">"http://127.0.0.1:9090/get"</span><br><br>data := url.Values{}<br>data.Set(<span class="hljs-string">"name"</span>,<span class="hljs-string">"小王子"</span>)<br>data.Set(<span class="hljs-string">"age"</span>,<span class="hljs-number">18</span>)<br>urlObj , err := url.ParseRequestURL(apiUrl)<br><br>queryStr := data.Encode()<br>urlObj.RawQuery = queryStr<br>req , _ := http.NewRequest(<span class="hljs-string">"GET"</span>, urlObj.String(),<span class="hljs-literal">nil</span>)<br><br>http.DefaultClient.Do(req)<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>上述为个性请求的定制</li>
<li>response读取完成之后记得要关闭</li>
<li>后端发请求频繁的时候，可以考虑公用一个Client，这个时候可以通过声明全局变量的形式来操作，可以通过var把关键字提前到最前面，然后剪辑出来，让其保证长连接,<code>DisableKeepAlives: false</code>。</li>
<li>拉起的频率的非常低时，就应该禁用长连接，上面那个设置为true，用完client后马上进行释放，就会非常方便。</li>
</ul>
<h1 id="Context单元测试和pprof调试工具"><a href="#Context单元测试和pprof调试工具" class="headerlink" title="Context单元测试和pprof调试工具"></a>Context单元测试和pprof调试工具</h1><h2 id="go语言中单元测试"><a href="#go语言中单元测试" class="headerlink" title="go语言中单元测试"></a>go语言中单元测试</h2><ul>
<li><code>go test</code>命令</li>
<li>每个函数必须导入test包，文件必须以_test.go命名，测试函数必须以Test开头，后缀就是特定的函数名，大写开头，写法如下:</li>
<li><code>func TestName(t *testing.T)</code></li>
<li>可以看一看测试组，有’Run’这种函数可以有很多花哨的操作</li>
<li>可以通过<code>go test -cover</code>来查看覆盖率，甚至可以生成覆盖率的文件，通过go语言中的tool工具再浏览器中打开查看，画面很炫酷</li>
<li>一般情况下各个函数模块的测试覆盖率要达到100% , 整体覆盖率要达到60%</li>
</ul>
<h2 id="go语言中的基准测试"><a href="#go语言中的基准测试" class="headerlink" title="go语言中的基准测试"></a>go语言中的基准测试</h2><ul>
<li><p><code>func BenchmarkName()</code></p>
</li>
<li><p>执行时使用<code>go test -bench=Split</code></p>
</li>
<li><p>要用循环反复执行一个函数来进行操作效率分析</p>
</li>
<li><p>具体的例如基准测试使用的proxy的量，都可以找到对应的博客来操作对应的值。</p>
</li>
<li><pre><code class="go">func BenchmarkSplit(b *testing.B){
    for i:=0;i&lt;b.N;i++{
        Split("A:B:C",":")
    }
}
<figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br><span class="hljs-bullet">-</span> 上述就是一个测试的例子，可以通过结果来分析各个值，然后再次去优化代码。例如内存申请的次数等会影响到代码的效率。<br><br><span class="hljs-section">### 性能比较函数</span><br><br><span class="hljs-bullet">-</span> 例如斐波那契数列<br><span class="hljs-bullet">-</span> 可以通过封装函数来实现多次跑一个函数来达到目的，传入的参数可以为<span class="hljs-code">`b *testing.B , int n`</span>，第二个参数是执行特定函数的次数。<br><span class="hljs-bullet">-</span> b.N是循环的次数，不要传入函数中，是错误的用法。是一个随着函数和执行次数在该改变的变量。<br><span class="hljs-bullet">-</span> 默认情况下，每个基准测试最少运行一秒，若没有到疫苗，b.N的值会1，2，5，10，20...这样一直增加，并且函数可以继续运行。<br><span class="hljs-bullet">-</span> 可以用<span class="hljs-code">`-benchtime`</span>来获得标志增加的最小基准时间，还有其它类似的用法等等。<br><span class="hljs-bullet">-</span> 还可以并行测试，指定CPU的数量之类的。<br><br><span class="hljs-section">### setup和teardown等专业工具</span><br><br><span class="hljs-bullet">-</span> setup和teardown函数，一个是初始化操作，一个是结尾首位操作<br><br><span class="hljs-section">## go语言中的示例函数</span><br><br><span class="hljs-bullet">-</span> 以ExampleName这种形式开头，可以自动产生文档嗷！<br><span class="hljs-bullet">-</span> 具体的在单元测试这一章的网上是有的。<br><span class="hljs-bullet">-</span> go语言可以自动拉一个文档出来，骚得很。<br><br><br><br><span class="hljs-section">## pprof工具的使用(go性能调优)</span><br><br><span class="hljs-bullet">-</span> aspects: CPU profile , Memory , block , goroutine<br><span class="hljs-bullet">-</span> <span class="hljs-code">`runtime/pprof`</span> , <span class="hljs-code">`net/http/pprof`</span>等运行时数据进行分析<br><span class="hljs-bullet">-</span> 只有在代码测试优化时才进行调用<br><span class="hljs-bullet">-</span> <span class="hljs-code">`isCPUPprof , isMemPprof`</span>是否开启标志位<br><br>![<span class="hljs-string">image-20201201220143773</span>](<span class="hljs-link">C:\Users\Alexander Liu\AppData\Roaming\Typora\typora-user-images\image-20201201220143773.png</span>)<br><br><span class="hljs-bullet">-</span> 上述往文件中写入对应的信息<br><br><span class="hljs-bullet">-</span> 结合flag包判断是否开启性能检测<br><br><span class="hljs-code">```go</span><br><span class="hljs-code">var isCPUPprof bool</span><br><span class="hljs-code"></span><br><span class="hljs-code">flag.BoolVar(&amp;isCPUPprof,"cpu",false,"turn cpu pprof on")</span><br><span class="hljs-code">flag.Parse()</span><br><span class="hljs-code"></span><br><span class="hljs-code">if isCPUPprof{</span><br><span class="hljs-code">	file, err := os.Create("./cpu.pprof")</span><br><span class="hljs-code">	if err != nil{</span><br><span class="hljs-code">		fmt.Printf("create cpu failed , err: 			%v\n",err)</span><br><span class="hljs-code">		return</span><br><span class="hljs-code">	}</span><br><span class="hljs-code">	pprof.StartCPUPprof(file)</span><br><span class="hljs-code">	defer func(){</span><br><span class="hljs-code">		pprof.StopCPUProfile()</span><br><span class="hljs-code">		file.Close()</span><br><span class="hljs-code">	}()</span><br><span class="hljs-code">}</span><br></code></pre></td></tr></tbody></table></figure>
</code></pre>
</li>
<li><p>对于模型进行分析的时候，命令行:<code>xx.exe -cpu=true</code>，三十秒后就会自动生成相关的文件</p>
</li>
<li><p><code>go tool pprof xx.pprof</code>可以使用内置的go工具对于特定的值进行分析。进入交互界面后，输入top3或者top4就可以查看占用cpu最多的几个东东，这些东东可以帮助你了解自己函数的性能，从而进行优化！(quit可以退出交换界面嗷！)</p>
</li>
<li><p>还有<code>go-torch</code>等操作使得图特别选炫酷，可以看blog去看看怎么去操作那些东西。</p>
</li>
</ul>
<h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><ul>
<li><p>用<code>MySQL</code></p>
</li>
<li><p><code>DDL,DML,DCL</code>之类的</p>
</li>
<li><p>支持插件式的搜索引擎。常见的有:<code>MyISAM</code>和<code>InnoDB</code></p>
<ul>
<li>MyISAM:</li>
</ul>
<ol>
<li>查询速度快</li>
<li>只支持表锁</li>
<li>不支持事务</li>
</ol>
<ul>
<li>InnoDB:</li>
</ul>
<ol>
<li>整体速度快</li>
<li>支持表锁和行锁</li>
<li>支持事务</li>
</ol>
<ul>
<li><p>事务：把多个SQL操作当成一个整体</p>
</li>
<li><p>ACID:</p>
</li>
</ul>
<ol>
<li>原子性：只有成功或者失败</li>
<li>一致性</li>
<li>隔离性：事务之间相互独立</li>
<li>持久性：事务操作结果不会丢失</li>
</ol>
</li>
<li><p>关系型数据库：用表来存放一类的数据</p>
</li>
<li><p>《漫画数据库》可以康康嗷！</p>
</li>
<li><p>隔离的四个级别：Read uncommitted , read committed , repeatable read , serializable</p>
</li>
<li><p>索引的原理： B5树和B+树</p>
</li>
<li><p>MySQL主从：</p>
<ul>
<li>binlog，把某个</li>
</ul>
</li>
<li><p>读写分离：从从库里面读，往主库里面写</p>
</li>
</ul>
<h1 id="Go对于MySQL的操作"><a href="#Go对于MySQL的操作" class="headerlink" title="Go对于MySQL的操作"></a>Go对于MySQL的操作</h1><h2 id="连接数据库："><a href="#连接数据库：" class="headerlink" title="连接数据库："></a>连接数据库：</h2><ul>
<li><p>database/sql ，这个库并没有具体实现，不提供数据库驱动，因此要装第三方的驱动。</p>
</li>
<li><img src="C:\Users\Alexander Liu\AppData\Roaming\Typora\typora-user-images\image-20201207163310289.png" srcset="/img/loading.gif" lazyload alt="image-20201207163310289" style="zoom: 200%;">
</li>
<li><p>```bash<br>go get -u github.com/go-sql-driver/mysql</p>
<figure class="highlight markdown"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><br>下载依赖管理<br><br><span class="hljs-section">## 读取某一行的数据：</span><br><br>![<span class="hljs-string">image-20201207172109804</span>](<span class="hljs-link">C:\Users\Alexander Liu\AppData\Roaming\Typora\typora-user-images\image-20201207172109804.png</span>)<br><br><span class="hljs-bullet">-</span> 必须对于<span class="hljs-code">`rowobj`</span>调用scan方法，这样才能释放链接，不然就会一直占有连接资源。<br><br><span class="hljs-bullet">-</span> <span class="hljs-code">`SetMaxOpenConns`</span>可以设置与数据库连接的最大数目<br><span class="hljs-bullet">-</span> <span class="hljs-code">`SetMaxIdleConn`</span>设置连接池中的最大闲置连接数<br><span class="hljs-bullet">-</span> <span class="hljs-code">`db.QueryRow(sqlStr, 2).Scan(&amp;u1.id, &amp;u1.name, &amp;u1.age) *//从连接池拿出一个连接去数据库查询数据*`</span>高级写法<br><br><span class="hljs-bullet">-</span> 不要用:=去处理db，db这里是一个全局变量，要对于全局db进行处理。<br><br><span class="hljs-section">## 增删改查：</span><br><br>详情看相关的go代码嗷！ <br><br><span class="hljs-section">## 数据预处理</span><br><br><span class="hljs-bullet">-</span> sql语句分开成为命令部分和数据部分，先把命令部分发送非服务端，然后数据给服务端进行替换。<br><span class="hljs-bullet">-</span> reason: 让服务器提前编译，一次白你要多次执行，时间花费少，以及避免用户输入恶意数据这种情况的发生。<br><br><span class="hljs-section">## go语言实现事务</span><br><br><span class="hljs-bullet">-</span> 两个或者多个操作揉成一个整体<br><span class="hljs-bullet">-</span> <span class="hljs-code">`Begin(*Tx, error) Commit Rollback()`</span>这三个来实现<br><span class="hljs-bullet">-</span> 只要有错误就回滚<br><span class="hljs-bullet">-</span> 相当于多个事务打包一起，除了问题就回退，保证表原来的状态，只有所有过程都没问题才能正常更新表嗷！！！<br><br><span class="hljs-section">## sqlx的使用</span><br><br><span class="hljs-bullet">-</span> [<span class="hljs-string">具体使用方法</span>](<span class="hljs-link">https://www.liwenzhou.com/posts/Go/sqlx/</span>)<br><br><span class="hljs-bullet">-</span> 注意，这里的get方法用到了反射，取了指针，所以变量定义的时候要是大写，才能够被别的包的reflect检索到。<br><span class="hljs-bullet">-</span> 注意传递指针注意注意注意嗷！<br><span class="hljs-bullet">-</span> 不同的数据库占位符是不一样的。<br><br><span class="hljs-section">## sql注入</span><br><br><br><br><span class="hljs-section"># GO MODULE</span><br><br><span class="hljs-bullet">-</span> go mod init<br><span class="hljs-bullet">-</span> go get<br><span class="hljs-bullet">-</span> go env<br><br><span class="hljs-section"># Context</span><br><br><span class="hljs-bullet">-</span> 非常重要:<br><span class="hljs-bullet">  -</span> 如何优雅控制子goroutine退出？<br><span class="hljs-bullet">    -</span> 可以和C语言中一样，去中间break一下就退出了。<br><span class="hljs-bullet">    -</span> <span class="hljs-code">`var exitChan chan bool`</span>， 然后用select去检查channel中有没有值，这样来控制退出。<br><span class="hljs-bullet">    -</span> <span class="hljs-code">`ctx , cancel := context.WithCancel(context.Background)`</span><br><span class="hljs-code">    </span><br><span class="hljs-code">    完整版:</span><br><span class="hljs-code">    </span><br><span class="hljs-code">    ```go</span><br><span class="hljs-code">    func f(ctx context.Context){</span><br><span class="hljs-code">    	def wg.Done</span><br><span class="hljs-code">        FORLOOP:</span><br><span class="hljs-code">        for{</span><br><span class="hljs-code">            fmt.Println("退出")</span><br><span class="hljs-code">            time.Sleep(time.Millisecond * 500)</span><br><span class="hljs-code">            select{</span><br><span class="hljs-code">                case &lt;- ctx.Done():</span><br><span class="hljs-code">                	break FORLOOP</span><br><span class="hljs-code">            	default:</span><br><span class="hljs-code">            }</span><br><span class="hljs-code">        }</span><br><span class="hljs-code">    }</span><br><span class="hljs-code">    </span><br><span class="hljs-code">    func main(){</span><br><span class="hljs-code">        ctx , cancel := context.WithCancel(context.Background())</span><br><span class="hljs-code">        wg.Add(1)</span><br><span class="hljs-code">        go f(ctx)</span><br><span class="hljs-code">        time.Sleep(time.Second*5)</span><br><span class="hljs-code">        cancel()</span><br><span class="hljs-code">        wg.Wait()</span><br><span class="hljs-code">    }</span><br></code></pre></td></tr></tbody></table></figure>
<p>  一个根的ctx一级级往下传，可以控制嵌套的进程的暂停和退出</p>
</li>
</ul>
<h1 id="服务端Agent开发"><a href="#服务端Agent开发" class="headerlink" title="服务端Agent开发"></a>服务端Agent开发</h1><h2 id="项目架构设计"><a href="#项目架构设计" class="headerlink" title="项目架构设计"></a>项目架构设计</h2><h2 id="Kafka-and-zookeeper"><a href="#Kafka-and-zookeeper" class="headerlink" title="Kafka and zookeeper"></a>Kafka and zookeeper</h2><h2 id="tailf接受"><a href="#tailf接受" class="headerlink" title="tailf接受"></a>tailf接受</h2><h1 id="gin框架"><a href="#gin框架" class="headerlink" title="gin框架"></a>gin框架</h1><ul>
<li>github上有源码，直接上去copy下来</li>
<li>路由初始化：<ul>
<li><ol>
<li>gin.Default()获取路由</li>
<li>绑定路由规则，执行的函数,<code>r.GET("/",func(c *gin.Context))</code> , Context里面封装了request,response之类的东西。使得更加为一个整体。</li>
<li>使服务器监听端口</li>
</ol>
</li>
</ul>
</li>
<li>gin路由：<ul>
<li>由httprouter做的</li>
<li><code>Restful风格的API</code>:<ul>
<li>获取文章 <code>/blog/getXxx</code> =&gt; Get   blog/Xxx</li>
<li>添加 <code>/blog/addXxx</code>=&gt;  Post   blog/Xxx</li>
<li>修改 <code>/blog/updateXxx</code> =&gt; Put   blog/Xxx</li>
<li>删除 <code>/blog/delXxx</code> =&gt;  Delete   blog/Xxx</li>
</ul>
</li>
</ul>
</li>
<li>剩下的例子去看代码</li>
<li>httproter原理可以去github上看源码，构造前缀树啊之类的东西</li>
<li>![image-20201215152054557](C:\Users\Alexander Liu\AppData\Roaming\Typora\typora-user-images\image-20201215152054557.png)</li>
</ul>
<h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><ul>
<li>HTTP是无状态的协议，为了区分是否为同一个客户端发出，才有了cookie。</li>
<li>client请求服务器，服务器除了返回信息还会返回一个cookie，cookie保存在本地的浏览器上，起到身份识别的作用。当client再次请求server时，会携带cookie</li>
<li>作用：<ul>
<li>保持用户登录状态</li>
<li>保持用户的信息(比如说京东的购物车)</li>
</ul>
</li>
<li>缺点：<ul>
<li>安全性不高</li>
<li>增加访问带宽消耗</li>
<li>可以被禁用</li>
<li>cookie有上限的</li>
</ul>
</li>
</ul>
<h1 id="Redis数据库"><a href="#Redis数据库" class="headerlink" title="Redis数据库"></a>Redis数据库</h1><ul>
<li>应用场景:<ul>
<li>缓存系统，减轻mysql的压力</li>
<li>cache缓存</li>
<li>热门排行榜</li>
<li>利用LIST实现队列的功能</li>
</ul>
</li>
<li>Session的过期时间，可以在set的时候使用</li>
<li>我们用的库是自带连接池的库嗷！</li>
<li>《Redis实战》好书啊！</li>
</ul>
<h1 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h1><ul>
<li><p>弥补Cookie的不足，只存session的id， session是离不开cookie的，session保存在cookie里面</p>
</li>
<li><p>要用到redis数据库嗷！</p>
</li>
<li><p>![image-20201216200209531](C:\Users\Alexander Liu\AppData\Roaming\Typora\typora-user-images\image-20201216200209531.png)</p>
</li>
<li><p>session接口设计：</p>
<ul>
<li>Set()</li>
<li>Get()</li>
<li>Del()</li>
<li>Save():  session存储</li>
</ul>
</li>
</ul>
<h1 id="一些偷学到的小技巧"><a href="#一些偷学到的小技巧" class="headerlink" title="一些偷学到的小技巧:"></a>一些偷学到的小技巧:</h1><h2 id="vscode中用户代码片段打开设置"><a href="#vscode中用户代码片段打开设置" class="headerlink" title="vscode中用户代码片段打开设置"></a>vscode中用户代码片段打开设置</h2><ul>
<li>在vscode中:<ul>
<li>ctrl + shift + p</li>
<li>snippets</li>
<li>选含有preferences那一项</li>
<li>选中go</li>
<li>然后用json格式就可以自定义代码格式<ul>
<li>前面的名字为你想定义的模板名</li>
<li>prefix为快捷键的方式</li>
<li>body为你要输出的内容</li>
<li>description为描述貌似没啥用???</li>
<li>$为最后光标停留的位置</li>
<li>关于json怎么写之类的我收藏了的，可以直接康收藏。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="相关代码含义查找"><a href="#相关代码含义查找" class="headerlink" title="相关代码含义查找"></a>相关代码含义查找</h2><ul>
<li>上go语言官网（已在收藏夹中）</li>
<li>找到对应的import函数</li>
<li>找到对应的用法即可</li>
</ul>
<h1 id="一些小而重要的知识点"><a href="#一些小而重要的知识点" class="headerlink" title="一些小而重要的知识点"></a>一些小而重要的知识点</h1><h2 id="文件中defer的用法"><a href="#文件中defer的用法" class="headerlink" title="文件中defer的用法"></a>文件中defer的用法</h2><p>![image-20201026172410243](C:\Users\Alexander Liu\AppData\Roaming\Typora\typora-user-images\image-20201026172410243.png)</p>
<p>下面才是对的，由于出问题时，fileObj为nil ， 而err有值，所以调用fileObj.Close()会引发错误造成panic ， 所以直接退出程序这个时候反而是对的，因为对应文件根本没有打开，只有打开了对应文件才应该关闭。相当于固定搭配，记住就好啦！</p>
<h2 id="使用go-module导入包"><a href="#使用go-module导入包" class="headerlink" title="使用go module导入包"></a>使用go module导入包</h2><ul>
<li>对于需要包管理的文件夹，要先<code>go mod init name</code>这阿姨那个对于包管理初始化，这个name是起的名字。这名字对于以后的调用中都用得到，而且是从<code>demoname</code>开始调用相对路径的，注意不是从文件夹开始调用，是从<code>demoname</code>开始调用</li>
</ul>
<h2 id="一些快捷键补充"><a href="#一些快捷键补充" class="headerlink" title="一些快捷键补充"></a>一些快捷键补充</h2><ul>
<li>按住alt用鼠标选中多个位置，可以多行一起操作</li>
</ul>
<h2 id="面试题分享"><a href="#面试题分享" class="headerlink" title="面试题分享"></a>面试题分享</h2><ul>
<li>判断链表有循环？</li>
</ul>
<p>从头开始走，一次走一步，一次走两步，看两者有没有机会相遇</p>
<ul>
<li>走台阶问题</li>
</ul>
<p>问题归纳，使用递归可以解决</p>
<h1 id="大作业"><a href="#大作业" class="headerlink" title="大作业"></a>大作业</h1><h2 id="日志库"><a href="#日志库" class="headerlink" title="日志库"></a>日志库</h2><h3 id="需求分析"><a href="#需求分析" class="headerlink" title="需求分析"></a>需求分析</h3><ul>
<li>不同的地方输出日志</li>
<li>日志的分级别:<ul>
<li>debug</li>
<li>trace</li>
<li>info</li>
<li>warning</li>
<li>error</li>
<li>fatal</li>
</ul>
</li>
<li>日志要支持开关控制</li>
<li>日志要有时间，行号，文件名，日志级别，日志信息</li>
<li>日志文件要切割:<ul>
<li>按照文件大小切割<ul>
<li>每次记录日志之前都判断一下文件大小</li>
</ul>
</li>
<li>按照日期切割<ul>
<li>每次记录日志之前都判断一下时间（在日志结构体中设置一个字段记录上一次切割的小时数）</li>
<li>写日志前判断一下小时数是否和结构体中的小时数一致即可</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="日志库的异步实现"><a href="#日志库的异步实现" class="headerlink" title="日志库的异步实现:"></a>日志库的异步实现:</h3><ul>
<li>在线程写入的时候，启用其它的线程来执行其它功能保证不会卡。</li>
</ul>
<h2 id="worker-pool-goroutine池"><a href="#worker-pool-goroutine池" class="headerlink" title="worker pool(goroutine池)"></a>worker pool(goroutine池)</h2><ul>
<li>使用goroutine来实现int64位中各位和的计算</li>
</ul>
<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips:"></a>Tips:</h1><ul>
<li>一个用了指针，全部都用指针嗷，这样才能保证对象对应的结构体或者方法能够被修改！！！要么全是指针接收者，要么全是值接收者。</li>
<li>传递参数的时候:</li>
</ul>
<figure class="highlight go"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a ...<span class="hljs-keyword">interface</span>{})</span></span>{<br>	body<br>}<br><br><span class="hljs-keyword">var</span> s = []<span class="hljs-keyword">interface</span>{<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>}<br>add(s)<br>add(s...)<br><br><span class="hljs-comment">//这里s传递是一个slice,s...传递的则是切片中的每一个元素，这个很重要嗷。</span><br></code></pre></td></tr></tbody></table></figure>


                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E5%90%8E%E7%AB%AF/">#后端</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Go究极李文周网课学习</div>
      <div>http://example.com/2021/02/20/go-di-er-ci-cha-que-bu-lou/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Alexander Liu</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2021年2月20日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2021/02/20/python-shu-ju-fen-xi-yu-zhan-shi-pandas/" title="Pandas相关内容">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Pandas相关内容</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2021/02/20/markdown-zi-xue/" title="Markdown系统学习">
                        <span class="hidden-mobile">Markdown系统学习</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  





  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.events.registerRefreshCallback(function() {
      if ('mermaid' in window) {
        mermaid.init();
      }
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
