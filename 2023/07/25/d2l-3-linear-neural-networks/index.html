

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/tuzi.png">
  <link rel="icon" href="/img/tuzi.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Alexander Liu">
  <meta name="keywords" content="分布式系统,后端研发,数据协同">
  
    <meta name="description" content="本章我们将介绍神经网络的整个训练过程， 包括：定义简单的神经网络架构、数据处理、指定损失函数和如何训练模型。 为了更容易学习，我们将从经典算法————线性神经网络开始，介绍神经网络的基础知识。 经典统计学习技术中的线性回归和softmax回归可以视为线性神经网络， 这些知识将为本书其他部分中更复杂的技术奠定基础。">
<meta property="og:type" content="article">
<meta property="og:title" content="D2L-3-Linear Neural Networks">
<meta property="og:url" content="http://example.com/2023/07/25/d2l-3-linear-neural-networks/index.html">
<meta property="og:site_name" content="兔の博客">
<meta property="og:description" content="本章我们将介绍神经网络的整个训练过程， 包括：定义简单的神经网络架构、数据处理、指定损失函数和如何训练模型。 为了更容易学习，我们将从经典算法————线性神经网络开始，介绍神经网络的基础知识。 经典统计学习技术中的线性回归和softmax回归可以视为线性神经网络， 这些知识将为本书其他部分中更复杂的技术奠定基础。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202307231956594.jpg">
<meta property="article:published_time" content="2023-07-25T09:01:02.000Z">
<meta property="article:modified_time" content="2023-08-03T02:11:44.093Z">
<meta property="article:author" content="Alexander Liu">
<meta property="article:tag" content="研0自学">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202307231956594.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>D2L-3-Linear Neural Networks - 兔の博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="兔の博客" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>兔的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/background_post.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="D2L-3-Linear Neural Networks"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Alexander Liu
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-07-25 17:01" pubdate>
          2023年7月25日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          48k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          403 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">D2L-3-Linear Neural Networks</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：22 天前
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p> 本章我们将介绍神经网络的整个训练过程， 包括：定义简单的神经网络架构、数据处理、指定损失函数和如何训练模型。 为了更容易学习，我们将从经典算法————<em>线性</em>神经网络开始，介绍神经网络的基础知识。 经典统计学习技术中的线性回归和softmax回归可以视为线性神经网络， 这些知识将为本书其他部分中更复杂的技术奠定基础。</p>
<span id="more"></span>



<h1 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h1><ul>
<li><p><em>回归</em>（regression）是能为一个或多个自变量与因变量之间关系建模的一类方法。 在自然科学和社会科学领域，回归经常用来表示输入和输出之间的关系。</p>
</li>
<li><p>在机器学习领域中的大多数任务通常都与<em>预测</em>（prediction）有关。 当我们想预测一个数值时，就会涉及到回归问题。 常见的例子包括：预测价格（房屋、股票等）、预测住院时间（针对住院病人等）、 预测需求（零售销量等）。 <strong>但不是所有的<em>预测</em>都是回归问题。</strong></p>
</li>
</ul>
<h2 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h2><ul>
<li><em>线性回归</em>（linear regression）可以追溯到19世纪初， 它在回归的各种标准工具中最简单而且最流行。 线性回归基于几个简单的假设： 首先，假设自变量$\mathbf{x}$和因变量$y$之间的关系是线性的， 即$y$可以表示为$\mathbf{x}$中元素的加权和，这里通常允许包含观测值的一些噪声； 其次，我们假设任何噪声都比较正常，如噪声遵循正态分布。</li>
<li>通常，我们使用$n$来表示数据集中的样本数。 对索引为$i$的样本，其输入表示为$\mathbf{x}^{(i)} = [x_1^{(i)}, x_2^{(i)}]^\top$， 其对应的标签是$y^{(i)}$。</li>
</ul>
<h3 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h3><ul>
<li>线性假设是指目标（房屋价格）可以表示为特征（面积和房龄）的加权和，如：$\mathrm{price} = w_{\mathrm{area}} \cdot \mathrm{area} + w_{\mathrm{age}} \cdot \mathrm{age} + b.$。$w_{\mathrm{area}}$和$w_{\mathrm{age}}$是<em>权重</em>（weight），权重决定了每个特征对我们预测值的影响。$b$称为<em>偏置</em>（bias）、<em>偏移量</em>（offset）或<em>截距</em>（intercept）。偏置是指当所有特征都取值为0时，预测值应该为多少。 即使现实中不会有任何房子的面积是0或房龄正好是0年，我们仍然需要偏置项。 如果没有偏置项，我们模型的表达能力将受到限制。</li>
</ul>
<blockquote>
<p>输入特征的一个 <em>仿射变换</em>（affine transformation）。 仿射变换的特点是通过加权和对特征进行<em>线性变换</em>（linear transformation）， 并通过偏置项来进行<em>平移</em>（translation）。</p>
</blockquote>
<ul>
<li>给定一个数据集，我们的目标是寻找模型的权重$\mathbf{w}$和偏置$b$， 使得根据模型做出的预测大体符合数据里的真实价格。 输出的预测值由输入特征通过<em>线性模型</em>的仿射变换决定，仿射变换由所选权重和偏置确定。</li>
<li>而在机器学习领域，我们通常使用的是高维数据集，建模时采用线性代数表示法会比较方便。 当我们的输入包含$d$个特征时，我们将预测结果$\hat{y}$（通常使用“尖角”符号表示$y$的估计值）表示为：</li>
</ul>
<p>$$<br>\hat{y} = w_1  x_1 + … + w_d  x_d + b.<br>$$</p>
<blockquote>
<p>特征放入$\mathbf{x} \in \mathbb{R}^d$，权重放入$\mathbf{w} \in \mathbb{R}^d$，我们可以用点积形式来简洁地表达模型：</p>
</blockquote>
<p>$$<br>\hat{y} = \mathbf{w}^\top \mathbf{x} + b.<br>$$</p>
<ul>
<li>$\mathbf{x}$对应于单个数据样本的特征。 用符号表示的矩阵$\mathbf{X} \in \mathbb{R}^{n \times d}$可以很方便地引用我们整个数据集的$n$个样本。 $\mathbf{X}$的每一行是一个样本，每一列是一种特征。对于特征集合$\mathbf{X}$，预测值$\hat{\mathbf{y}} \in \mathbb{R}^n$可以通过矩阵-向量乘法表示为：</li>
</ul>
<p>$$<br>{\hat{\mathbf{y}}} = \mathbf{X} \mathbf{w} + b<br>$$</p>
<blockquote>
<p>这个过程中的求和将使用广播机制 （广播机制在 <a target="_blank" rel="noopener" href="https://zh.d2l.ai/chapter_preliminaries/ndarray.html#subsec-broadcasting">2.1.3节</a>中有详细介绍）。 给定训练数据特征$\mathbf{X}$和对应的已知标签$\mathbf{y}$， 线性回归的目标是找到一组权重向量$w$和偏置$b$： 当给定从$\mathbf{X}$的同分布中取样的新样本特征时， 这组权重向量和偏置能够使得新样本预测标签的误差尽可能小。</p>
</blockquote>
<ul>
<li><p>虽然我们相信给定$\mathbf{x}$预测$y$的最佳模型会是线性的， 但我们很难找到一个有$n$个样本的真实数据集，其中对于所有的$1 \leq i \leq n$，$y^{(i)}$完全等于$\mathbf{w}^\top \mathbf{x}^{(i)}+b$。 无论我们使用什么手段来观察特征$\mathbf{X}$和标签$y$， 都可能会出现少量的观测误差。 因此，即使确信特征与标签的潜在关系是线性的， 我们也会加入一个噪声项来考虑观测误差带来的影响。</p>
</li>
<li><p>在开始寻找最好的<em>模型参数</em>（model parameters）$\mathbf{w}$和$b$之前， 我们还需要两个东西： （1）一种模型质量的度量方式； （2）一种能够更新模型以提高模型预测质量的方法。</p>
</li>
</ul>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><ul>
<li>我们需要确定一个拟合程度的度量。 <em>损失函数</em>（loss function）能够量化目标的<em>实际</em>值与<em>预测</em>值之间的差距。 通常我们会选择非负数作为损失，且数值越小表示损失越小，完美预测时的损失为0。 回归问题中最常用的损失函数是平方误差函数。 当样本$i$的预测值为$\hat{y}^{(i)}$，其相应的真实标签为$y^{(i)}$时， 平方误差可以定义为以下公式：</li>
</ul>
<p>$$<br>l^{(i)}(\mathbf{w}, b) = \frac{1}{2} \left(\hat{y}^{(i)} - y^{(i)}\right)^2.<br>$$</p>
<blockquote>
<p>常数$\frac{1}{2}$不会带来本质的差别，但这样在形式上稍微简单一些 （因为当我们对损失函数求导后常数系数为1）。 由于训练数据集并不受我们控制，所以经验误差只是关于模型参数的函数。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202307261014650.svg" srcset="/img/loading.gif" lazyload alt="../_images/fit-linreg.svg"></p>
<ul>
<li>由于平方误差函数中的二次方项， 估计值$\hat{y}^{(i)}$和观测值$y^{(i)}$之间较大的差异将导致更大的损失。 为了度量模型在整个数据集上的质量，我们需计算在训练集$n$个样本上的损失均值（也等价于求和）。</li>
</ul>
<p>$$<br>L(\mathbf{w}, b) =\frac{1}{n}\sum_{i=1}^n l^{(i)}(\mathbf{w}, b) =\frac{1}{n} \sum_{i=1}^n \frac{1}{2}\left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right)^2.<br>$$</p>
<blockquote>
<p>在训练模型时，我们希望寻找一组参数$(\mathbf{w}^*, b^*)$， 这组参数能最小化在所有训练样本上的总损失。如下式：</p>
</blockquote>
<p>$$<br>\mathbf{w}^*, b^* = \operatorname*{argmin}_{\mathbf{w}, b}\  L(\mathbf{w}, b).<br>$$</p>
<h3 id="解析解"><a href="#解析解" class="headerlink" title="解析解"></a>解析解</h3><ul>
<li>线性回归刚好是一个很简单的优化问题。 与我们将在本书中所讲到的其他大部分模型不同，线性回归的解可以用一个公式简单地表达出来， 这类解叫作解析解（analytical solution）。 首先，我们将偏置$b$合并到参数$\mathbf{w}$中，合并方法是在包含所有参数的矩阵中附加一列。 我们的预测问题是最小化$|\mathbf{y} - \mathbf{X}\mathbf{w}|^2$。 这在损失平面上只有一个临界点，这个临界点对应于整个区域的损失极小点。 将损失关于$\mathbf{w}$的导数设为0，得到解析解：</li>
</ul>
<p>$$<br>\mathbf{w}^* = (\mathbf X^\top \mathbf X)^{-1}\mathbf X^\top \mathbf{y}.<br>$$</p>
<blockquote>
<p><strong>像线性回归这样的简单问题存在解析解，但并不是所有的问题都存在解析解。</strong> 解析解可以进行很好的数学分析，但解析解对问题的限制很严格，导致它无法广泛应用在深度学习里。</p>
</blockquote>
<h3 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h3><ul>
<li>我们用到一种名为<em>梯度下降</em>（gradient descent）的方法， 这种方法几乎可以优化所有深度学习模型。 它通过不断地在损失函数递减的方向上更新参数来降低误差。</li>
<li>梯度下降最简单的用法是计算损失函数（数据集中所有样本的损失均值） 关于模型参数的导数（在这里也可以称为梯度）。 但实际中的执行可能会非常慢：因为在每一次更新参数之前，我们必须遍历整个数据集。 因此，我们通常会在每次需要计算更新的时候随机抽取一小批样本， 这种变体叫做<em>小批量随机梯度下降</em>（minibatch stochastic gradient descent）。</li>
<li>在每次迭代中，我们首先随机抽样一个小批量$\mathcal{B}$， 它是由固定数量的训练样本组成的。 然后，我们计算小批量的平均损失关于模型参数的导数（也可以称为梯度）。 最后，我们将梯度乘以一个预先确定的正数$\eta$，并从当前参数的值中减掉。我们用下面的数学公式来表示这一更新过程（$\partial$表示偏导数）：</li>
</ul>
<p>$$<br>(\mathbf{w},b) \leftarrow (\mathbf{w},b) - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \partial_{(\mathbf{w},b)} l^{(i)}(\mathbf{w},b).<br>$$</p>
<ul>
<li>总结一下，算法的步骤如下： <ul>
<li>（1）初始化模型参数的值，如随机初始化； </li>
<li>（2）从数据集中随机抽取小批量样本且在负梯度的方向上更新参数，并不断迭代这一步骤。</li>
</ul>
</li>
<li>对于平方损失和仿射变换，我们可以明确地写成如下形式:</li>
</ul>
<p>$$<br>\begin{split}\begin{aligned} \mathbf{w} &amp;\leftarrow \mathbf{w} -   \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \partial_{\mathbf{w}} l^{(i)}(\mathbf{w}, b) = \mathbf{w} - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \mathbf{x}^{(i)} \left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right),\ b &amp;\leftarrow b -  \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \partial_b l^{(i)}(\mathbf{w}, b)  = b - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right). \end{aligned}\end{split}<br>$$</p>
<blockquote>
<p>$\mathbf{w}$和$x$都是向量，更优雅的向量表示法比系数表示法（如$w_1, w_2, \ldots, w_d$）更具可读性。 $|\mathcal{B}|$表示每个小批量中的样本数，这也称为<em>批量大小</em>（batch size）。 $\eta$表示<em>学习率</em>（learning rate）。 批量大小和学习率的值通常是手动预先指定，而不是通过模型训练得到的。 这些可以调整但不在训练过程中更新的参数称为<em>超参数</em>（hyperparameter）。 <em>调参</em>（hyperparameter tuning）是选择超参数的过程。 超参数通常是我们根据训练迭代结果来调整的， 而训练迭代结果是在独立的<em>验证数据集</em>（validation dataset）上评估得到的。</p>
</blockquote>
<ul>
<li><p>在训练了预先确定的若干迭代次数后（或者直到满足某些其他停止条件后）， 我们记录下模型参数的估计值，表示为$\hat{\mathbf{w}}, \hat{b}$。 但是，即使我们的函数确实是线性的且无噪声，这些估计值也不会使损失函数真正地达到最小值。 因为算法会使得损失向最小值缓慢收敛，但却不能在有限的步数内非常精确地达到最小值。</p>
</li>
<li><p>线性回归恰好是一个在整个域中只有一个最小值的学习问题。 但是对像深度神经网络这样复杂的模型来说，损失平面上通常包含多个最小值。 深度学习实践者很少会去花费大力气寻找这样一组参数，使得在<em>训练集</em>上的损失达到最小。 事实上，更难做到的是找到一组参数，这组参数能够在我们从未见过的数据上实现较低的损失， 这一挑战被称为<em>泛化</em>（generalization）。</p>
</li>
</ul>
<h3 id="用模型预测"><a href="#用模型预测" class="headerlink" title="用模型预测"></a>用模型预测</h3><ul>
<li>“已学习”的线性回归模型$\hat{\mathbf{w}}^\top \mathbf{x} + \hat{b}$，就可以通过新的$\mathbf{x}$，来估计一个$y$。给定特征估计目标的过程通常称为<em>预测</em>（prediction）或<em>推断</em>（inference）。</li>
<li>本书将尝试坚持使用<em>预测</em>这个词。 虽然<em>推断</em>这个词已经成为深度学习的标准术语，但其实<em>推断</em>这个词有些用词不当。 在统计学中，<em>推断</em>更多地表示基于数据集估计参数。</li>
</ul>
<h2 id="矢量化加速"><a href="#矢量化加速" class="headerlink" title="矢量化加速"></a>矢量化加速</h2><ul>
<li>在训练我们的模型时，我们经常希望能够同时处理整个小批量的样本。 为了实现这一点，需要我们对计算进行矢量化， 从而利用线性代数库，而不是在Python中编写开销高昂的for循环。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">%matplotlib inline<br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> d2l <span class="hljs-keyword">import</span> torch <span class="hljs-keyword">as</span> d2l<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>线性代数库与for循环性能对比：</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># test case</span><br>n = <span class="hljs-number">10000</span><br>a = torch.ones([n])<br>b = torch.ones([n])<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span>:  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""记录多次运行时间"""</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.times = []<br>        self.start()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">"""启动计时器"""</span><br>        self.tik = time.time()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">stop</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">"""停止计时器并将时间记录在列表中"""</span><br>        self.times.append(time.time() - self.tik)<br>        <span class="hljs-keyword">return</span> self.times[-<span class="hljs-number">1</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">avg</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">"""返回平均时间"""</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(self.times) / <span class="hljs-built_in">len</span>(self.times)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">"""返回时间总和"""</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(self.times)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cumsum</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">"""返回累计时间"""</span><br>        <span class="hljs-keyword">return</span> np.array(self.times).cumsum().tolist()<br><br><span class="hljs-comment"># for循环</span><br>c = torch.zeros(n)<br>timer = Timer()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    c[i] = a[i] + b[i]<br><span class="hljs-string">f'<span class="hljs-subst">{timer.stop():<span class="hljs-number">.5</span>f}</span> sec'</span><br><span class="hljs-comment"># result</span><br><span class="hljs-string">'0.09661 sec'</span><br><br><br><span class="hljs-comment"># 线性代数库</span><br>timer.start()<br>d = a + b<br><span class="hljs-string">f'<span class="hljs-subst">{timer.stop():<span class="hljs-number">.5</span>f}</span> sec'</span><br><span class="hljs-comment"># result</span><br><span class="hljs-string">'0.00021 sec'</span><br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>矢量化代码通常会带来数量级的加速。 另外，我们将更多的数学运算放到库中，而无须自己编写那么多的计算，从而减少了出错的可能性。</p>
</blockquote>
<h2 id="正态分布与平方损失"><a href="#正态分布与平方损失" class="headerlink" title="正态分布与平方损失"></a>正态分布与平方损失</h2><ul>
<li>正态分布和线性回归之间的关系很密切。 正态分布（normal distribution），也称为<em>高斯分布</em>（Gaussian distribution）， 最早由德国数学家高斯（Gauss）应用于天文学研究。 简单的说，若随机变量$x$具有均值$\mu$和方差$\sigma^2$（标准差$\sigma$），其正态分布概率密度函数如下：</li>
</ul>
<p>$$<br>p(x) = \frac{1}{\sqrt{2 \pi \sigma^2}} \exp\left(-\frac{1}{2 \sigma^2} (x - \mu)^2\right).<br>$$</p>
<ul>
<li>可视化正态分布：</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">normal</span>(<span class="hljs-params">x, mu, sigma</span>):<br>    p = <span class="hljs-number">1</span> / math.sqrt(<span class="hljs-number">2</span> * math.pi * sigma**<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> p * np.exp(-<span class="hljs-number">0.5</span> / sigma**<span class="hljs-number">2</span> * (x - mu)**<span class="hljs-number">2</span>)<br>  <br><span class="hljs-comment"># 再次使用numpy进行可视化</span><br>x = np.arange(-<span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0.01</span>)<br><br><span class="hljs-comment"># 均值和标准差对</span><br>params = [(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)]<br>d2l.plot(x, [normal(x, mu, sigma) <span class="hljs-keyword">for</span> mu, sigma <span class="hljs-keyword">in</span> params], xlabel=<span class="hljs-string">'x'</span>,<br>         ylabel=<span class="hljs-string">'p(x)'</span>, figsize=(<span class="hljs-number">4.5</span>, <span class="hljs-number">2.5</span>),<br>         legend=[<span class="hljs-string">f'mean <span class="hljs-subst">{mu}</span>, std <span class="hljs-subst">{sigma}</span>'</span> <span class="hljs-keyword">for</span> mu, sigma <span class="hljs-keyword">in</span> params])<br></code></pre></td></tr></tbody></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202307261041887.svg" srcset="/img/loading.gif" lazyload alt="../_images/output_linear-regression_216540_70_0.svg"></p>
<ul>
<li>就像我们所看到的，改变均值会产生沿$x$轴的偏移，增加方差将会分散分布、降低其峰值。均方误差损失函数（简称均方损失）可以用于线性回归的一个原因是： 我们假设了观测中包含噪声，其中噪声服从正态分布。 噪声正态分布如下式:</li>
</ul>
<p>$$<br>y = \mathbf{w}^\top \mathbf{x} + b + \epsilon,<br>$$</p>
<blockquote>
<p>其中，$\epsilon \sim \mathcal{N}(0, \sigma^2)$。因此，我们现在可以写出通过给定的$\mathbf{x}$观测到特定$y$的<em>似然</em>（likelihood）：</p>
</blockquote>
<p>$$<br>P(y \mid \mathbf{x}) = \frac{1}{\sqrt{2 \pi \sigma^2}} \exp\left(-\frac{1}{2 \sigma^2} (y - \mathbf{w}^\top \mathbf{x} - b)^2\right).<br>$$</p>
<blockquote>
<p>现在，根据极大似然估计法，最优值是使整个数据集的<em>似然</em>最大的值：</p>
</blockquote>
<p>$$<br>P(\mathbf y \mid \mathbf X) = \prod_{i=1}^{n} p(y^{(i)}|\mathbf{x}^{(i)}).<br>$$</p>
<blockquote>
<p>根据极大似然估计法选择的估计量称为<em>极大似然估计量</em>。 虽然使许多指数函数的乘积最大化看起来很困难， 但是我们可以在不改变目标的前提下，通过最大化似然对数来简化。 由于历史原因，优化通常是说最小化而不是最大化。 我们可以改为<em>最小化负对数似然</em>$-\log P(\mathbf y \mid \mathbf X)$。 由此可以得到的数学公式是：</p>
</blockquote>
<p>$$<br>-\log P(\mathbf y \mid \mathbf X) = \sum_{i=1}^n \frac{1}{2} \log(2 \pi \sigma^2) + \frac{1}{2 \sigma^2} \left(y^{(i)} - \mathbf{w}^\top \mathbf{x}^{(i)} - b\right)^2.<br>$$</p>
<blockquote>
<p>现在我们只需要假设$\sigma$是某个固定常数就可以忽略第一项， 因为第一项不依赖于$\mathbf{w}$和$b$。 现在第二项除了常数$\frac{1}{\sigma^2}$外，其余部分和前面介绍的均方误差是一样的。 幸运的是，上面式子的解并不依赖于$\sigma$。 因此，在高斯噪声的假设下，最小化均方误差等价于对线性模型的极大似然估计。</p>
</blockquote>
<h2 id="从线性回归到深度网络"><a href="#从线性回归到深度网络" class="headerlink" title="从线性回归到深度网络"></a>从线性回归到深度网络</h2><ul>
<li>尽管神经网络涵盖了更多更为丰富的模型，我们依然可以用描述神经网络的方式来描述线性模型， 从而把线性模型看作一个神经网络。 首先，我们用“层”符号来重写这个模型。</li>
</ul>
<h3 id="神经网络图"><a href="#神经网络图" class="headerlink" title="神经网络图"></a>神经网络图</h3><p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202307261046793.svg" srcset="/img/loading.gif" lazyload alt="../_images/singleneuron.svg"></p>
<blockquote>
<p>输入为$x_1, \ldots, x_d$， 因此输入层中的<em>输入数</em>（或称为<em>特征维度</em>，feature dimensionality）为$d$。 网络的输出为$o_1$，因此输出层中的<em>输出数</em>是1。 需要注意的是，输入值都是已经给定的，并且只有一个<em>计算</em>神经元。 由于模型重点在发生计算的地方，所以通常我们在计算层数时不考虑输入层。 也就是说，图中神经网络的<em>层数</em>为1。 我们可以将线性回归模型视为仅由单个人工神经元组成的神经网络，或称为单层神经网络。</p>
</blockquote>
<ul>
<li>对于线性回归，每个输入都与每个输出（在本例中只有一个输出）相连， 我们将这种变换称为<em>全连接层</em>（fully-connected layer）或称为<em>稠密层</em>（dense layer）。</li>
</ul>
<h3 id="生物学"><a href="#生物学" class="headerlink" title="生物学"></a>生物学</h3><p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202307261049045.svg" srcset="/img/loading.gif" lazyload alt="../_images/neuron.svg"></p>
<blockquote>
<p>树突中接收到来自其他神经元（或视网膜等环境传感器）的信息$x_i$。 该信息通过<em>突触权重</em>$w_i$来加权，以确定输入的影响（即，通过$x_i w_i$相乘来激活或抑制）。 来自多个源的加权输入以加权和$y = \sum_i x_i w_i + b$的形式汇聚在细胞核中， 然后将这些信息发送到轴突$y$中进一步处理，通常会通过$\sigma(y)$进行一些非线性处理。 之后，它要么到达目的地（例如肌肉），要么通过树突进入另一个神经元。</p>
</blockquote>
<ul>
<li>当今大多数深度学习的研究几乎没有直接从神经科学中获得灵感。在深度学习中的灵感同样或更多地来自数学、统计学和计算机科学。</li>
</ul>
<p><strong>Tips: 具体的Linear Regression推导，可以看看下面那一篇知乎的reference昂！！！</strong></p>
<h1 id="线性回归的从零开始实现"><a href="#线性回归的从零开始实现" class="headerlink" title="线性回归的从零开始实现"></a>线性回归的从零开始实现</h1><ul>
<li>代码实现：</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">%matplotlib inline<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> d2l <span class="hljs-keyword">import</span> torch <span class="hljs-keyword">as</span> d2l<br></code></pre></td></tr></tbody></table></figure>



<h2 id="生成数据集"><a href="#生成数据集" class="headerlink" title="生成数据集"></a>生成数据集</h2><blockquote>
<p>我们将根据带有噪声的线性模型构造一个人造数据集。 我们的任务是使用这个有限样本的数据集来恢复这个模型的参数。 我们将使用低维数据，这样可以很容易地将其可视化。</p>
</blockquote>
<ul>
<li>我们生成一个包含1000个样本的数据集， 每个样本包含从标准正态分布中采样的2个特征。 我们的合成数据集是一个矩阵$\mathbf{X}\in \mathbb{R}^{1000 \times 2}$，我们使用线性模型参数$\mathbf{w} = [2, -3.4]^\top$、$b = 4.2$和噪声项$\epsilon$生成数据集及其标签：</li>
</ul>
<p>$$<br>\mathbf{y}= \mathbf{X} \mathbf{w} + b + \mathbf\epsilon.<br>$$</p>
<blockquote>
<p>$\epsilon$可以视为模型预测和标签时的潜在观测误差。 在这里我们认为标准假设成立，即$\epsilon$服从均值为0的正态分布。 为了简化问题，我们将标准差设为0.01。 下面的代码生成合成数据集。</p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">synthetic_data</span>(<span class="hljs-params">w, b, num_examples</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""生成y=Xw+b+噪声"""</span><br>    X = torch.normal(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, (num_examples, <span class="hljs-built_in">len</span>(w)))<br>    y = torch.matmul(X, w) + b<br>    y += torch.normal(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>, y.shape)<br>    <span class="hljs-keyword">return</span> X, y.reshape((-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br><br>true_w = torch.tensor([<span class="hljs-number">2</span>, -<span class="hljs-number">3.4</span>])<br>true_b = <span class="hljs-number">4.2</span><br>features, labels = synthetic_data(true_w, true_b, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意，<code>features</code>中的每一行都包含一个二维数据样本， <code>labels</code>中的每一行都包含一维标签值（一个标量）。</p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">'features:'</span>, features[<span class="hljs-number">0</span>],<span class="hljs-string">'\nlabel:'</span>, labels[<span class="hljs-number">0</span>])<br><br><span class="hljs-comment"># result</span><br>features: tensor([-<span class="hljs-number">0.3679</span>, -<span class="hljs-number">1.8471</span>])<br>label: tensor([<span class="hljs-number">9.7361</span>])<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>通过生成第二个特征<code>features[:, 1]</code>和<code>labels</code>的散点图， 可以直观观察到两者之间的线性关系。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">d2l.set_figsize()<br>d2l.plt.scatter(features[:, <span class="hljs-number">1</span>].detach().numpy(), labels.detach().numpy(), <span class="hljs-number">1</span>);<br></code></pre></td></tr></tbody></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202307271011392.svg" srcset="/img/loading.gif" lazyload alt="../_images/output_linear-regression-scratch_58de05_51_0.svg"></p>
<h2 id="读取数据集"><a href="#读取数据集" class="headerlink" title="读取数据集"></a>读取数据集</h2><ul>
<li>训练模型时要对数据集进行遍历，每次抽取一小批量样本，并使用它们来更新我们的模型。 有必要定义一个函数， 该函数能打乱数据集中的样本并以小批量方式获取数据。我们定义一个<code>data_iter</code>函数， 该函数接收批量大小、特征矩阵和标签向量作为输入，生成大小为<code>batch_size</code>的小批量。 每个小批量包含一组特征和标签。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">data_iter</span>(<span class="hljs-params">batch_size, features, labels</span>):<br>    num_examples = <span class="hljs-built_in">len</span>(features)<br>    indices = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(num_examples))<br>    <span class="hljs-comment"># 这些样本是随机读取的，没有特定的顺序</span><br>    random.shuffle(indices)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, num_examples, batch_size):<br>        batch_indices = torch.tensor(<br>            indices[i: <span class="hljs-built_in">min</span>(i + batch_size, num_examples)])<br>        <span class="hljs-keyword">yield</span> features[batch_indices], labels[batch_indices]<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>通常，我们利用GPU并行运算的优势，处理合理大小的“小批量”。 每个样本都可以并行地进行模型计算，且每个样本损失函数的梯度也可以被并行计算。 GPU可以在处理几百个样本时，所花费的时间不比处理一个样本时多太多。</p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python">batch_size = <span class="hljs-number">10</span><br><br><span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> data_iter(batch_size, features, labels):<br>    <span class="hljs-built_in">print</span>(X, <span class="hljs-string">'\n'</span>, y)<br>    <span class="hljs-keyword">break</span><br><br><span class="hljs-comment"># result</span><br>tensor([[ <span class="hljs-number">0.1649</span>, -<span class="hljs-number">1.1651</span>],<br>        [-<span class="hljs-number">2.0755</span>, -<span class="hljs-number">1.0165</span>],<br>        [-<span class="hljs-number">0.2189</span>,  <span class="hljs-number">0.7607</span>],<br>        [ <span class="hljs-number">0.6833</span>,  <span class="hljs-number">0.3537</span>],<br>        [-<span class="hljs-number">0.2736</span>, -<span class="hljs-number">2.0485</span>],<br>        [-<span class="hljs-number">0.3026</span>,  <span class="hljs-number">0.9771</span>],<br>        [ <span class="hljs-number">2.4795</span>,  <span class="hljs-number">0.6881</span>],<br>        [-<span class="hljs-number">0.2045</span>, -<span class="hljs-number">0.8509</span>],<br>        [-<span class="hljs-number">0.1353</span>,  <span class="hljs-number">0.5476</span>],<br>        [ <span class="hljs-number">0.3371</span>, -<span class="hljs-number">0.0479</span>]])<br> tensor([[ <span class="hljs-number">8.4901</span>],<br>        [ <span class="hljs-number">3.5015</span>],<br>        [ <span class="hljs-number">1.1779</span>],<br>        [ <span class="hljs-number">4.3752</span>],<br>        [<span class="hljs-number">10.6125</span>],<br>        [ <span class="hljs-number">0.2845</span>],<br>        [ <span class="hljs-number">6.8094</span>],<br>        [ <span class="hljs-number">6.6776</span>],<br>        [ <span class="hljs-number">2.0598</span>],<br>        [ <span class="hljs-number">5.0189</span>]])<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>当我们运行迭代时，我们会连续地获得不同的小批量，直至遍历完整个数据集。 上面实现的迭代对教学来说很好，但它的执行效率很低，可能会在实际问题上陷入麻烦。 例如，它要求我们将所有数据加载到内存中，并执行大量的随机内存访问。 在深度学习框架中实现的内置迭代器效率要高得多， 它可以处理存储在文件中的数据和数据流提供的数据。</p>
<p>Tips: 深度学习框架很好用！！！性能很好捏！！！</p>
</blockquote>
<h2 id="初始化模型参数"><a href="#初始化模型参数" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h2><ul>
<li>我们通过从均值为0、标准差为0.01的正态分布中采样随机数来初始化权重， 并将偏置初始化为0。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">w = torch.normal(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>, size=(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>), requires_grad=<span class="hljs-literal">True</span>)<br>b = torch.zeros(<span class="hljs-number">1</span>, requires_grad=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>在初始化参数之后，我们的任务是更新这些参数，直到这些参数足够拟合我们的数据。 每次更新都需要计算损失函数关于模型参数的梯度。 有了这个梯度，我们就可以向减小损失的方向更新每个参数。 因为手动计算梯度很枯燥而且容易出错，所以没有人会手动计算梯度。 </p>
</blockquote>
<h2 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h2><ul>
<li>我们必须定义模型，将模型的输入和参数同模型的输出关联起来。 回想一下，要计算线性模型的输出， 我们只需计算输入特征$\mathbf{X}$和模型权重$\mathbf{w}$的矩阵-向量乘法后加上偏置$b$。 注意，上面的$\mathbf{Xw}$是一个向量，而$b$是一个标量。 回想一下 <a target="_blank" rel="noopener" href="https://zh-v2.d2l.ai/chapter_preliminaries/ndarray.html#subsec-broadcasting">2.1.3节</a>中描述的广播机制： 当我们用一个向量加一个标量时，标量会被加到向量的每个分量上。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">linreg</span>(<span class="hljs-params">X, w, b</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""线性回归模型"""</span><br>    <span class="hljs-keyword">return</span> torch.matmul(X, w) + b<br></code></pre></td></tr></tbody></table></figure>



<h2 id="定义损失函数"><a href="#定义损失函数" class="headerlink" title="定义损失函数"></a>定义损失函数</h2><ul>
<li>平方损失函数，我们需要将真实值<code>y</code>的形状转换为和预测值<code>y_hat</code>的形状相同。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">squared_loss</span>(<span class="hljs-params">y_hat, y</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""均方损失"""</span><br>    <span class="hljs-keyword">return</span> (y_hat - y.reshape(y_hat.shape)) ** <span class="hljs-number">2</span> / <span class="hljs-number">2</span><br></code></pre></td></tr></tbody></table></figure>



<h2 id="定义优化算法"><a href="#定义优化算法" class="headerlink" title="定义优化算法"></a>定义优化算法</h2><ul>
<li>线性回归有解析解，其他模型不一定有， 这里我们介绍小批量随机梯度下降。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sgd</span>(<span class="hljs-params">params, lr, batch_size</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""小批量随机梯度下降"""</span><br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        <span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> params:<br>            param -= lr * param.grad / batch_size<br>            param.grad.zero_()<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>在每一步中，使用从数据集中随机抽取的一个小批量，然后根据参数计算损失的梯度。 接下来，朝着减少损失的方向更新我们的参数。 下面的函数实现小批量随机梯度下降更新。 该函数接受模型参数集合、学习速率和批量大小作为输入。每 一步更新的大小由学习速率<code>lr</code>决定。 因为我们计算的损失是一个批量样本的总和，所以我们用批量大小（<code>batch_size</code>） 来规范化步长，这样步长大小就不会取决于我们对批量大小的选择。</p>
</blockquote>
<h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><blockquote>
<p>在每次迭代中，我们读取一小批量训练样本，并通过我们的模型来获得一组预测。 计算完损失后，我们开始反向传播，存储每个参数的梯度。 最后，我们调用优化算法<code>sgd</code>来更新模型参数。</p>
</blockquote>
<ul>
<li><p>我们将执行以下循环：</p>
<ul>
<li>初始化参数</li>
<li>重复以下训练，直到完成<ul>
<li>计算梯度$\mathbf{g} \leftarrow \partial_{(\mathbf{w},b)} \frac{1}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} l(\mathbf{x}^{(i)}, y^{(i)}, \mathbf{w}, b)$</li>
<li>更新参数$(\mathbf{w}, b) \leftarrow (\mathbf{w}, b) - \eta \mathbf{g}$</li>
</ul>
</li>
</ul>
</li>
<li><p>在每个<em>迭代周期</em>（epoch）中，我们使用<code>data_iter</code>函数遍历整个数据集， 并将训练数据集中所有样本都使用一次（假设样本数能够被批量大小整除）。 这里的迭代周期个数<code>num_epochs</code>和学习率<code>lr</code>都是超参数，分别设为3和0.03。 设置超参数很棘手，需要通过反复试验进行调整，我们现在忽略这些细节。</p>
</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">lr = <span class="hljs-number">0.03</span><br>num_epochs = <span class="hljs-number">3</span><br>net = linreg<br>loss = squared_loss<br><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):<br>    <span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> data_iter(batch_size, features, labels):<br>        l = loss(net(X, w, b), y)  <span class="hljs-comment"># X和y的小批量损失</span><br>        <span class="hljs-comment"># 因为l形状是(batch_size,1)，而不是一个标量。l中的所有元素被加到一起，</span><br>        <span class="hljs-comment"># 并以此计算关于[w,b]的梯度</span><br>        l.<span class="hljs-built_in">sum</span>().backward()<br>        sgd([w, b], lr, batch_size)  <span class="hljs-comment"># 使用参数的梯度更新参数</span><br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        train_l = loss(net(features, w, b), labels)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f'epoch <span class="hljs-subst">{epoch + <span class="hljs-number">1</span>}</span>, loss <span class="hljs-subst">{<span class="hljs-built_in">float</span>(train_l.mean()):f}</span>'</span>)<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>还是一样的，先通过构造损失函数l，然后通过l来执行backward()函数，进行更新。</p>
</blockquote>
<ul>
<li>因为我们使用的是自己合成的数据集，所以我们知道真正的参数是什么。 因此，我们可以通过比较真实参数和通过训练学到的参数来评估训练的成功程度。 事实上，真实参数和通过训练学到的参数确实非常接近。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f'w的估计误差: <span class="hljs-subst">{true_w - w.reshape(true_w.shape)}</span>'</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f'b的估计误差: <span class="hljs-subst">{true_b - b}</span>'</span>)<br><br><span class="hljs-comment"># result</span><br>w的估计误差: tensor([ <span class="hljs-number">0.0003</span>, -<span class="hljs-number">0.0002</span>], grad_fn=&lt;SubBackward0&gt;)<br>b的估计误差: tensor([<span class="hljs-number">0.0010</span>], grad_fn=&lt;RsubBackward1&gt;)<br></code></pre></td></tr></tbody></table></figure>









<h1 id="线性回归的简洁实现"><a href="#线性回归的简洁实现" class="headerlink" title="线性回归的简洁实现"></a>线性回归的简洁实现</h1><h2 id="数据集生成"><a href="#数据集生成" class="headerlink" title="数据集生成"></a>数据集生成</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch.utils <span class="hljs-keyword">import</span> data<br><span class="hljs-keyword">from</span> d2l <span class="hljs-keyword">import</span> torch <span class="hljs-keyword">as</span> d2l<br><br>true_w = torch.tensor([<span class="hljs-number">2</span>, -<span class="hljs-number">3.4</span>])<br>true_b = <span class="hljs-number">4.2</span><br>features, labels = d2l.synthetic_data(true_w, true_b, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>和上面的一致捏</p>
</blockquote>
<h2 id="读取数据集-1"><a href="#读取数据集-1" class="headerlink" title="读取数据集"></a>读取数据集</h2><ul>
<li>我们可以调用框架中现有的API来读取数据。 我们将<code>features</code>和<code>labels</code>作为API的参数传递，并通过数据迭代器指定<code>batch_size</code>。 此外，布尔值<code>is_train</code>表示是否希望数据迭代器对象在每个迭代周期内打乱数据。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_array</span>(<span class="hljs-params">data_arrays, batch_size, is_train=<span class="hljs-literal">True</span></span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""构造一个PyTorch数据迭代器"""</span><br>    dataset = data.TensorDataset(*data_arrays)<br>    <span class="hljs-keyword">return</span> data.DataLoader(dataset, batch_size, shuffle=is_train)<br><br>batch_size = <span class="hljs-number">10</span><br>data_iter = load_array((features, labels), batch_size)<br></code></pre></td></tr></tbody></table></figure>



<h2 id="定义模型-1"><a href="#定义模型-1" class="headerlink" title="定义模型"></a>定义模型</h2><ul>
<li>对于标准深度学习模型，我们可以使用框架的预定义好的层。这使我们只需关注使用哪些层来构造模型，而不必关注层的实现细节。 我们首先定义一个模型变量<code>net</code>，它是一个<code>Sequential</code>类的实例。 <code>Sequential</code>类将多个层串联在一起。 当给定输入数据时，<code>Sequential</code>实例将数据传入到第一层， 然后将第一层的输出作为第二层的输入，以此类推。 在下面的例子中，我们的模型只包含一个层，因此实际上不需要<code>Sequential</code>。 但是由于以后几乎所有的模型都是多层的，在这里使用<code>Sequential</code>。</li>
</ul>
<blockquote>
<p>示例图</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202307272154971.svg" srcset="/img/loading.gif" lazyload alt="../_images/singleneuron.svg"></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># nn是神经网络的缩写</span><br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><br>net = nn.Sequential(nn.Linear(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>))<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>在PyTorch中，全连接层在<code>Linear</code>类中定义。 值得注意的是，我们将两个参数传递到<code>nn.Linear</code>中。 第一个指定输入特征形状，即2，第二个指定输出特征形状，输出特征形状为单个标量，因此为1。</p>
</blockquote>
<h2 id="初始化模型参数-1"><a href="#初始化模型参数-1" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h2><ul>
<li>在使用<code>net</code>之前，我们需要初始化模型参数。 如在线性回归模型中的权重和偏置。 深度学习框架通常有预定义的方法来初始化参数。 在这里，我们指定每个权重参数应该从均值为0、标准差为0.01的正态分布中随机采样， 偏置参数将初始化为零。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">net[<span class="hljs-number">0</span>].weight.data.normal_(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>)<br>net[<span class="hljs-number">0</span>].bias.data.fill_(<span class="hljs-number">0</span>)<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>正如我们在构造<code>nn.Linear</code>时指定输入和输出尺寸一样， 现在我们能直接访问参数以设定它们的初始值。 我们通过<code>net[0]</code>选择网络中的第一个图层， 然后使用<code>weight.data</code>和<code>bias.data</code>方法访问参数。 我们还可以使用替换方法<code>normal_</code>和<code>fill_</code>来重写参数值。</p>
</blockquote>
<h2 id="定义损失函数-1"><a href="#定义损失函数-1" class="headerlink" title="定义损失函数"></a>定义损失函数</h2><ul>
<li>计算均方误差使用的是<code>MSELoss</code>类，也称为平方$L_2$范数。 默认情况下，它返回所有样本损失的平均值。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">loss = nn.MSELoss()<br></code></pre></td></tr></tbody></table></figure>



<h2 id="定义优化算法-1"><a href="#定义优化算法-1" class="headerlink" title="定义优化算法"></a>定义优化算法</h2><ul>
<li>小批量随机梯度下降算法是一种优化神经网络的标准工具， PyTorch在<code>optim</code>模块中实现了该算法的许多变种。 当我们实例化一个<code>SGD</code>实例时，我们要指定优化的参数 （可通过<code>net.parameters()</code>从我们的模型中获得）以及优化算法所需的超参数字典。 小批量随机梯度下降只需要设置<code>lr</code>值，这里设置为0.03。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">trainer = torch.optim.SGD(net.parameters(), lr=<span class="hljs-number">0.03</span>)<br></code></pre></td></tr></tbody></table></figure>



<h2 id="训练-1"><a href="#训练-1" class="headerlink" title="训练"></a>训练</h2><p>通过深度学习框架的高级API来实现我们的模型只需要相对较少的代码。 我们不必单独分配参数、不必定义我们的损失函数，也不必手动实现小批量随机梯度下降。 当我们需要更复杂的模型时，高级API的优势将大大增加。 当我们有了所有的基本组件，训练过程代码与我们从零开始实现时所做的非常相似。</p>
<p>回顾一下：在每个迭代周期里，我们将完整遍历一次数据集（<code>train_data</code>）， 不停地从中获取一个小批量的输入和相应的标签。 对于每一个小批量，我们会进行以下步骤:</p>
<ul>
<li>通过调用<code>net(X)</code>生成预测并计算损失<code>l</code>（前向传播）。</li>
<li>通过进行反向传播来计算梯度。</li>
<li>通过调用优化器来更新模型参数。</li>
</ul>
<p>为了更好的衡量训练效果，我们计算每个迭代周期后的损失，并打印它来监控训练过程。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">num_epochs = <span class="hljs-number">3</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):<br>    <span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> data_iter:<br>        l = loss(net(X) ,y)<br>        trainer.zero_grad()<br>        l.backward()<br>        trainer.step()<br>    l = loss(net(features), labels)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f'epoch <span class="hljs-subst">{epoch + <span class="hljs-number">1</span>}</span>, loss <span class="hljs-subst">{l:f}</span>'</span>)<br>    <br><span class="hljs-comment"># result</span><br>epoch <span class="hljs-number">1</span>, loss <span class="hljs-number">0.000183</span><br>epoch <span class="hljs-number">2</span>, loss <span class="hljs-number">0.000101</span><br>epoch <span class="hljs-number">3</span>, loss <span class="hljs-number">0.000101</span><br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>下面我们比较生成数据集的真实参数和通过有限数据训练获得的模型参数。 要访问参数，我们首先从<code>net</code>访问所需的层，然后读取该层的权重和偏置。 正如在从零开始实现中一样，我们估计得到的参数与生成数据的真实参数非常接近。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">w = net[<span class="hljs-number">0</span>].weight.data<br><span class="hljs-built_in">print</span>(<span class="hljs-string">'w的估计误差：'</span>, true_w - w.reshape(true_w.shape))<br>b = net[<span class="hljs-number">0</span>].bias.data<br><span class="hljs-built_in">print</span>(<span class="hljs-string">'b的估计误差：'</span>, true_b - b)<br><br><span class="hljs-comment"># result</span><br>w的估计误差： tensor([-<span class="hljs-number">0.0003</span>, -<span class="hljs-number">0.0002</span>])<br>b的估计误差： tensor([<span class="hljs-number">8.1062e-06</span>])<br></code></pre></td></tr></tbody></table></figure>







<h1 id="softmax回归"><a href="#softmax回归" class="headerlink" title="softmax回归"></a>softmax回归</h1><blockquote>
<p>回归可以用于预测<em>多少</em>的问题。 比如预测房屋被售出价格，或者棒球队可能获得的胜场数，又或者患者住院的天数。</p>
<ul>
<li>机器学习实践者用<em>分类</em>这个词来描述两个有微妙差别的问题： <ol>
<li>我们只对样本的“硬性”类别感兴趣，即属于哪个类别</li>
<li>我们希望得到“软性”类别，即得到属于每个类别的概率。 这两者的界限往往很模糊。其中的一个原因是：即使我们只关心硬类别，我们仍然使用软类别的模型。</li>
</ol>
</li>
</ul>
</blockquote>
<h2 id="分类问题"><a href="#分类问题" class="headerlink" title="分类问题"></a>分类问题</h2><ul>
<li>一般的分类问题并不与类别之间的自然顺序有关。 幸运的是，统计学家很早以前就发明了一种表示分类数据的简单方法：<em>独热编码</em>（one-hot encoding）。 独热编码是一个向量，它的分量和类别一样多。 类别对应的分量设置为1，其他所有分量设置为0。 在我们的例子中，标签$y$将是一个三维向量， 其中(1,0,0)对应于“猫”、(0,1,0)对应于“鸡”、(0,0,1)对应于“狗”：</li>
</ul>
<p>$$<br>y \in {(1, 0, 0), (0, 1, 0), (0, 0, 1)}.<br>$$</p>
<h2 id="网络架构"><a href="#网络架构" class="headerlink" title="网络架构"></a>网络架构</h2><ul>
<li>为了估计所有可能类别的条件概率，我们需要一个有多个输出的模型，每个类别对应一个输出。 为了解决线性模型的分类问题，我们需要和输出一样多的<em>仿射函数</em>（affine function）。 每个输出对应于它自己的仿射函数。 在我们的例子中，由于我们有4个特征和3个可能的输出类别， 我们将需要12个标量来表示权重（带下标的$w$）， 3个标量来表示偏置（带下标的$b$）。 下面我们为每个输入计算三个<em>未规范化的预测</em>（logit）：$o_1$、$o_2$和$o_3$。</li>
</ul>
<p>$$<br>\begin{split}\begin{aligned}<br>o_1 &amp;= x_1 w_{11} + x_2 w_{12} + x_3 w_{13} + x_4 w_{14} + b_1,\<br>o_2 &amp;= x_1 w_{21} + x_2 w_{22} + x_3 w_{23} + x_4 w_{24} + b_2,\<br>o_3 &amp;= x_1 w_{31} + x_2 w_{32} + x_3 w_{33} + x_4 w_{34} + b_3.<br>\end{aligned}\end{split}<br>$$</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202307281111798.svg" srcset="/img/loading.gif" lazyload alt="../_images/softmaxreg.svg"></p>
<blockquote>
<p>为了更简洁地表达模型，我们仍然使用线性代数符号。 通过向量形式表达为$\mathbf{o} = \mathbf{W} \mathbf{x} + \mathbf{b}$， 这是一种更适合数学和编写代码的形式。 由此，我们已经将所有权重放到一个3×4矩阵中。 对于给定数据样本的特征$\mathbf{x}$， 我们的输出是由权重与输入特征进行矩阵-向量乘法再加上偏置$\mathbf{b}$得到的。</p>
</blockquote>
<h2 id="全连接层的参数开销"><a href="#全连接层的参数开销" class="headerlink" title="全连接层的参数开销"></a>全连接层的参数开销</h2><ul>
<li>在深度学习中，全连接层无处不在。 然而，顾名思义，全连接层是“完全”连接的，可能有很多可学习的参数。 具体来说，对于任何具有$d$个输入和$q$个输出的全连接层， 参数开销为$\mathcal{O}(dq)$，这个数字在实践中可能高得令人望而却步。 幸运的是，将$d$个输入转换为$q$个输出的成本可以减少到$\mathcal{O}(\frac{dq}{n})$， 其中超参数$n$可以由我们灵活指定，以在实际应用中平衡参数节约和模型有效性。</li>
</ul>
<h2 id="softmax运算"><a href="#softmax运算" class="headerlink" title="softmax运算"></a>softmax运算</h2><blockquote>
<p>现在我们将优化参数以最大化观测数据的概率。 为了得到预测结果，我们将设置一个阈值，如选择具有最大概率的标签。</p>
</blockquote>
<ul>
<li>我们不能将未规范化的预测$o$直接视作我们感兴趣的输出，将线性层的输出直接视为概率时存在一些问题： 一方面，我们没有限制这些输出数字的总和为1。 另一方面，根据输入的不同，它们可以为负值。 </li>
<li>要将输出视为概率，我们必须保证在任何数据上的输出都是非负的且总和为1。 此外，我们需要一个训练的目标函数，来激励模型精准地估计概率。 例如， 在分类器输出0.5的所有样本中，我们希望这些样本是刚好有一半实际上属于预测的类别。 这个属性叫做<em>校准</em>（calibration）。</li>
<li>softmax函数能够将未规范化的预测变换为非负数并且总和为1，同时让模型保持可导的性质。  为了完成这一目标，我们首先对每个未规范化的预测求幂，这样可以确保输出非负。 为了确保最终输出的概率值总和为1，我们再让每个求幂后的结果除以它们的总和。</li>
</ul>
<p>$$<br>\hat{\mathbf{y}} = \mathrm{softmax}(\mathbf{o})\quad \text{其中}\quad \hat{y}_j = \frac{\exp(o_j)}{\sum_k \exp(o_k)}<br>$$</p>
<blockquote>
<p>这里，对于所有的$j$总有$0 \leq \hat{y}_j \leq 1$。 因此，$\hat{\mathbf{y}}$可以视为一个正确的概率分布。 softmax运算不会改变未规范化的预测$\mathbf{o}$之间的大小次序，只会确定分配给每个类别的概率。 因此，在预测过程中，我们仍然可以用下式来选择最有可能的类别。</p>
</blockquote>
<p>$$<br>\operatorname*{argmax}_j \hat y_j = \operatorname*{argmax}_j o_j.<br>$$</p>
<ul>
<li>尽管softmax是一个非线性函数，但softmax回归的输出仍然由输入特征的仿射变换决定。 因此，softmax回归是一个<em>线性模型</em>（linear model）。</li>
</ul>
<h2 id="小批量样本的矢量化"><a href="#小批量样本的矢量化" class="headerlink" title="小批量样本的矢量化"></a>小批量样本的矢量化</h2><ul>
<li>为了提高计算效率并且充分利用GPU，我们通常会对小批量样本的数据执行矢量计算。 假设我们读取了一个批量的样本$\mathbf{X}$， 其中特征维度（输入数量）为$d$，批量大小为$n$。 此外，假设我们在输出中有$q$个类别。 那么小批量样本的特征为$\mathbf{X} \in \mathbb{R}^{n \times d}$， 权重为$\mathbf{W} \in \mathbb{R}^{d \times q}$， 偏置为$\mathbf{b} \in \mathbb{R}^{1\times q}$。 softmax回归的矢量计算表达式为：</li>
</ul>
<p>$$<br>\begin{split}\begin{aligned} \mathbf{O} &amp;= \mathbf{X} \mathbf{W} + \mathbf{b}, \ \hat{\mathbf{Y}} &amp; = \mathrm{softmax}(\mathbf{O}). \end{aligned}\end{split}<br>$$</p>
<blockquote>
<p>相对于一次处理一个样本， 小批量样本的矢量化加快了和$\mathbf{X}和\mathbf{W}$的矩阵-向量乘法。 由于$\mathbf{X}$中的每一行代表一个数据样本， 那么softmax运算可以<em>按行</em>（rowwise）执行： 对于$\mathbf{O}$的每一行，我们先对所有项进行幂运算，然后通过求和对它们进行标准化。 $\mathbf{X} \mathbf{W} + \mathbf{b}$的求和会使用广播机制， 小批量的未规范化预测$\mathbf{O}$和输出概率$\hat{\mathbf{Y}}$都是形状为$n \times q$的矩阵。</p>
</blockquote>
<h2 id="损失函数-1"><a href="#损失函数-1" class="headerlink" title="损失函数"></a>损失函数</h2><blockquote>
<p>接下来，我们需要一个损失函数来度量预测的效果，我们将使用最大似然估计。</p>
</blockquote>
<ul>
<li><strong>上面的其实就是我们的模型和我们的概率预测，我们需要找到一种合适的方式，对于上面给出的“预测”，和我们真实的数据进行对比，进而调优。参考：<a target="_blank" rel="noopener" href="https://www.zhihu.com/tardis/zm/art/35709485?source_id=1003">https://www.zhihu.com/tardis/zm/art/35709485?source_id=1003</a></strong></li>
</ul>
<h3 id="对数似然"><a href="#对数似然" class="headerlink" title="对数似然"></a>对数似然</h3><ul>
<li>softmax函数给出了一个向量$\hat{\mathbf{y}}$， 我们可以将其视为“对给定任意输入$\mathbf{x}$的每个类的条件概率”。 例如，$P(y=\text{猫} \mid \mathbf{x})$。 假设整个数据集${\mathbf{X}, \mathbf{Y}}$具有$n$个样本， 其中索引$i$的样本由特征向量$\mathbf{x}^{(i)}$和独热标签向量$\mathbf{y}^{(i)}$组成。 我们可以将估计值与实际值进行比较：</li>
</ul>
<p>$$<br>P(\mathbf{Y} \mid \mathbf{X}) = \prod_{i=1}^n P(\mathbf{y}^{(i)} \mid \mathbf{x}^{(i)}).<br>$$</p>
<ul>
<li>根据最大似然估计，我们最大化$P(\mathbf{Y} \mid \mathbf{X})$，相当于最小化负对数似然：</li>
</ul>
<p>$$<br>-\log P(\mathbf{Y} \mid \mathbf{X}) = \sum_{i=1}^n -\log P(\mathbf{y}^{(i)} \mid \mathbf{x}^{(i)})<br>= \sum_{i=1}^n l(\mathbf{y}^{(i)}, \hat{\mathbf{y}}^{(i)}),<br>$$</p>
<ul>
<li>其中，对于任何标签$\mathbf{y}$和模型预测$\hat{\mathbf{y}}$，损失函数为：</li>
</ul>
<p>$$<br>l(\mathbf{y}, \hat{\mathbf{y}}) = - \sum_{j=1}^q y_j \log \hat{y}_j.<br>$$</p>
<blockquote>
<p>上面这个损失函数 通常被称为<em>交叉熵损失</em>（cross-entropy loss）。 由于$\mathbf{y}$是一个长度为$q$的独热编码向量， 所以除了一个项以外的所有项$j$都消失了。 由于所有$\hat{y}_j$都是预测的概率，所以它们的对数永远不会大于0。 因此，如果正确地预测实际标签，即如果实际标签$P(\mathbf{y} \mid \mathbf{x})=1$， 则损失函数不能进一步最小化。 注意，这往往是不可能的。 例如，数据集中可能存在标签噪声（比如某些样本可能被误标）， 或输入特征没有足够的信息来完美地对每一个样本分类。</p>
</blockquote>
<h3 id="softmax及其导数"><a href="#softmax及其导数" class="headerlink" title="softmax及其导数"></a>softmax及其导数</h3><ul>
<li>由于softmax和相关的损失函数很常见， 因此我们需要更好地理解它的计算方式。利用softmax的定义，我们得到：</li>
</ul>
<p>$$<br>\begin{split}\begin{aligned}<br>l(\mathbf{y}, \hat{\mathbf{y}}) &amp;=  - \sum_{j=1}^q y_j \log \frac{\exp(o_j)}{\sum_{k=1}^q \exp(o_k)} \<br>&amp;= \sum_{j=1}^q y_j \log \sum_{k=1}^q \exp(o_k) - \sum_{j=1}^q y_j o_j\<br>&amp;= \log \sum_{k=1}^q \exp(o_k) - \sum_{j=1}^q y_j o_j.<br>\end{aligned}\end{split}<br>$$</p>
<ul>
<li>考虑相对于任何未规范化的预测$o_j$的导数，我们得到：</li>
</ul>
<p>$$<br>\partial_{o_j} l(\mathbf{y}, \hat{\mathbf{y}}) = \frac{\exp(o_j)}{\sum_{k=1}^q \exp(o_k)} - y_j = \mathrm{softmax}(\mathbf{o})_j - y_j.<br>$$</p>
<blockquote>
<p>换句话说，导数是我们softmax模型分配的概率与实际发生的情况（由独热标签向量表示）之间的差异。 从这个意义上讲，这与我们在回归中看到的非常相似， 其中梯度是观测值$y$和估计值$\hat{y}$之间的差异。 这不是巧合，在任何指数族分布模型中，对数似然的梯度正是由此得出的。 这使梯度计算在实践中变得容易很多。</p>
</blockquote>
<h3 id="交叉熵损失"><a href="#交叉熵损失" class="headerlink" title="交叉熵损失"></a>交叉熵损失</h3><ul>
<li>现在让我们考虑整个结果分布的情况，即观察到的不仅仅是一个结果。 对于标签$y$，我们可以使用与以前相同的表示形式。 唯一的区别是，我们现在用一个概率向量表示，如(0.1,0.2,0.7)， 而不是仅包含二元项的向量(0,0,1)。 我们使用对数似然损失函数来定义损失$l$， 它是所有标签分布的预期损失值。 此损失称为<em>交叉熵损失</em>（cross-entropy loss），它是分类问题最常用的损失之一。</li>
</ul>
<h2 id="信息论基础"><a href="#信息论基础" class="headerlink" title="信息论基础"></a>信息论基础</h2><blockquote>
<p><em>信息论</em>（information theory）涉及编码、解码、发送以及尽可能简洁地处理信息或数据。</p>
</blockquote>
<h3 id="熵"><a href="#熵" class="headerlink" title="熵"></a>熵</h3><ul>
<li>信息论的核心思想是量化数据中的信息内容。 在信息论中，该数值被称为分布$P$的<em>熵</em>（entropy）。可以通过以下方程得到：</li>
</ul>
<p>$$<br>H[P] = \sum_j - P(j) \log P(j).<br>$$</p>
<blockquote>
<p>信息论的基本定理之一指出，为了对从分布$p$中随机抽取的数据进行编码， 我们至少需要$H[P]$“纳特（nat）”对其进行编码。 “纳特”相当于<em>比特</em>（bit），但是对数底为$e$而不是2。因此，一个纳特是$\frac{1}{\log(2)} \approx 1.44$比特。</p>
</blockquote>
<h3 id="信息量"><a href="#信息量" class="headerlink" title="信息量"></a>信息量</h3><ul>
<li>我们有一个要压缩的数据流。 如果我们很容易预测下一个数据，那么这个数据就很容易压缩。</li>
<li>如果我们不能完全预测每一个事件，那么我们有时可能会感到”惊异”。 克劳德·香农决定用信息量$\log \frac{1}{P(j)} = -\log P(j)$来量化这种惊异程度。 在观察一个事件$j$时，并赋予它（主观）概率$P(j)$。 当我们赋予一个事件较低的概率时，我们的惊异会更大，该事件的信息量也就更大。</li>
<li>定义的熵， 是当分配的概率真正匹配数据生成过程时的<em>信息量的期望</em>。</li>
</ul>
<h2 id="重新审视交叉熵"><a href="#重新审视交叉熵" class="headerlink" title="重新审视交叉熵"></a>重新审视交叉熵</h2><ul>
<li>如果把熵$H(P)$想象为“知道真实概率的人所经历的惊异程度”，那么什么是交叉熵？ 交叉熵<em>从</em>$P$<em>到</em>$Q$，记为$H(P, Q)$。 我们可以把交叉熵想象为“主观概率为$Q$的观察者在看到根据概率$P$生成的数据时的预期惊异”。 当$P=Q$时，交叉熵达到最低。 在这种情况下，从$P$到$Q$的交叉熵是$H(P, P)= H(P)$。</li>
<li>简而言之，我们可以从两方面来考虑交叉熵分类目标<ul>
<li>最大化观测数据的似然</li>
<li>最小化传达标签所需的惊异</li>
</ul>
</li>
</ul>
<h2 id="模型预测和评估"><a href="#模型预测和评估" class="headerlink" title="模型预测和评估"></a>模型预测和评估</h2><ul>
<li>在训练softmax回归模型后，给出任何样本特征，我们可以预测每个输出类别的概率。 通常我们使用预测概率最高的类别作为输出类别。 如果预测与实际类别（标签）一致，则预测是正确的。 在接下来的实验中，我们将使用<em>精度</em>（accuracy）来评估模型的性能。 精度等于正确预测数与预测总数之间的比率。</li>
</ul>
<h1 id="图像分类数据集"><a href="#图像分类数据集" class="headerlink" title="图像分类数据集"></a>图像分类数据集</h1><ul>
<li><p>我们将使用类似但更复杂的Fashion-MNIST数据集，进行图像分类的训练。</p>
</li>
<li><p>依赖安装：</p>
</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">%matplotlib inline<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">from</span> torch.utils <span class="hljs-keyword">import</span> data<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br><span class="hljs-keyword">from</span> d2l <span class="hljs-keyword">import</span> torch <span class="hljs-keyword">as</span> d2l<br><br>d2l.use_svg_display()<br></code></pre></td></tr></tbody></table></figure>



<h2 id="读取数据集-2"><a href="#读取数据集-2" class="headerlink" title="读取数据集"></a>读取数据集</h2><ul>
<li>我们可以通过框架中的内置函数将Fashion-MNIST数据集下载并读取到内存中</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 通过ToTensor实例将图像数据从PIL类型变换成32位浮点数格式，</span><br><span class="hljs-comment"># 并除以255使得所有像素的数值均在0～1之间</span><br>trans = transforms.ToTensor()<br>mnist_train = torchvision.datasets.FashionMNIST(<br>    root=<span class="hljs-string">"../data"</span>, train=<span class="hljs-literal">True</span>, transform=trans, download=<span class="hljs-literal">True</span>)<br>mnist_test = torchvision.datasets.FashionMNIST(<br>    root=<span class="hljs-string">"../data"</span>, train=<span class="hljs-literal">False</span>, transform=trans, download=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>Fashion-MNIST由10个类别的图像组成， 每个类别由<em>训练数据集</em>（train dataset）中的6000张图像 和<em>测试数据集</em>（test dataset）中的1000张图像组成。 因此，训练集和测试集分别包含60000和10000张图像。 测试数据集不会用于训练，只用于评估模型性能。</p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">len</span>(mnist_train), <span class="hljs-built_in">len</span>(mnist_test)<br><br><span class="hljs-comment"># result</span><br>(<span class="hljs-number">60000</span>, <span class="hljs-number">10000</span>)<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>每个输入图像的高度和宽度均为28像素。 数据集由灰度图像组成，其通道数为1。 为了简洁起见，本书将高度$h$像素、宽度$w$像素图像的形状记为$h \times w$。</p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">mnist_train[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].shape<br><br><span class="hljs-comment"># result</span><br>torch.Size([<span class="hljs-number">1</span>, <span class="hljs-number">28</span>, <span class="hljs-number">28</span>])<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>在数字标签索引及其文本名称之间进行转换</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_fashion_mnist_labels</span>(<span class="hljs-params">labels</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""返回Fashion-MNIST数据集的文本标签"""</span><br>    text_labels = [<span class="hljs-string">'t-shirt'</span>, <span class="hljs-string">'trouser'</span>, <span class="hljs-string">'pullover'</span>, <span class="hljs-string">'dress'</span>, <span class="hljs-string">'coat'</span>,<br>                   <span class="hljs-string">'sandal'</span>, <span class="hljs-string">'shirt'</span>, <span class="hljs-string">'sneaker'</span>, <span class="hljs-string">'bag'</span>, <span class="hljs-string">'ankle boot'</span>]<br>    <span class="hljs-keyword">return</span> [text_labels[<span class="hljs-built_in">int</span>(i)] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> labels]<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>我们现在可以创建一个函数来可视化这些样本</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">show_images</span>(<span class="hljs-params">imgs, num_rows, num_cols, titles=<span class="hljs-literal">None</span>, scale=<span class="hljs-number">1.5</span></span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""绘制图像列表"""</span><br>    figsize = (num_cols * scale, num_rows * scale)<br>    _, axes = d2l.plt.subplots(num_rows, num_cols, figsize=figsize)<br>    axes = axes.flatten()<br>    <span class="hljs-keyword">for</span> i, (ax, img) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(axes, imgs)):<br>        <span class="hljs-keyword">if</span> torch.is_tensor(img):<br>            <span class="hljs-comment"># 图片张量</span><br>            ax.imshow(img.numpy())<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># PIL图片</span><br>            ax.imshow(img)<br>        ax.axes.get_xaxis().set_visible(<span class="hljs-literal">False</span>)<br>        ax.axes.get_yaxis().set_visible(<span class="hljs-literal">False</span>)<br>        <span class="hljs-keyword">if</span> titles:<br>            ax.set_title(titles[i])<br>    <span class="hljs-keyword">return</span> axes<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>可视化一把：</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">X, y = <span class="hljs-built_in">next</span>(<span class="hljs-built_in">iter</span>(data.DataLoader(mnist_train, batch_size=<span class="hljs-number">18</span>)))<br>show_images(X.reshape(<span class="hljs-number">18</span>, <span class="hljs-number">28</span>, <span class="hljs-number">28</span>), <span class="hljs-number">2</span>, <span class="hljs-number">9</span>, titles=get_fashion_mnist_labels(y));<br></code></pre></td></tr></tbody></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202307281736426.png" srcset="/img/loading.gif" lazyload alt="image-20230728173637025"></p>
<h2 id="读取小批量"><a href="#读取小批量" class="headerlink" title="读取小批量"></a>读取小批量</h2><ul>
<li>为了使我们在读取训练集和测试集时更容易，我们使用内置的数据迭代器，而不是从零开始创建。 回顾一下，在每次迭代中，数据加载器每次都会读取一小批量数据，大小为<code>batch_size</code>。 通过内置数据迭代器，我们可以随机打乱了所有样本，从而无偏见地读取小批量。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">batch_size = <span class="hljs-number">256</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_dataloader_workers</span>():  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""使用4个进程来读取数据"""</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">4</span><br><br>train_iter = data.DataLoader(mnist_train, batch_size, shuffle=<span class="hljs-literal">True</span>,<br>                             num_workers=get_dataloader_workers())<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>我们看一下读取训练数据所需的时间。</p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">timer = d2l.Timer()<br><span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> train_iter:<br>    <span class="hljs-keyword">continue</span><br><span class="hljs-string">f'<span class="hljs-subst">{timer.stop():<span class="hljs-number">.2</span>f}</span> sec'</span><br><br><span class="hljs-comment"># result</span><br><span class="hljs-string">'2.18 sec'</span><br></code></pre></td></tr></tbody></table></figure>



<h2 id="整合所有组件"><a href="#整合所有组件" class="headerlink" title="整合所有组件"></a>整合所有组件</h2><ul>
<li>现在我们定义<code>load_data_fashion_mnist</code>函数，用于获取和读取Fashion-MNIST数据集。 这个函数返回训练集和验证集的数据迭代器。 此外，这个函数还接受一个可选参数<code>resize</code>，用来将图像大小调整为另一种形状。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_data_fashion_mnist</span>(<span class="hljs-params">batch_size, resize=<span class="hljs-literal">None</span></span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""下载Fashion-MNIST数据集，然后将其加载到内存中"""</span><br>    trans = [transforms.ToTensor()]<br>    <span class="hljs-keyword">if</span> resize:<br>        trans.insert(<span class="hljs-number">0</span>, transforms.Resize(resize))<br>    trans = transforms.Compose(trans)<br>    mnist_train = torchvision.datasets.FashionMNIST(<br>        root=<span class="hljs-string">"../data"</span>, train=<span class="hljs-literal">True</span>, transform=trans, download=<span class="hljs-literal">True</span>)<br>    mnist_test = torchvision.datasets.FashionMNIST(<br>        root=<span class="hljs-string">"../data"</span>, train=<span class="hljs-literal">False</span>, transform=trans, download=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">return</span> (data.DataLoader(mnist_train, batch_size, shuffle=<span class="hljs-literal">True</span>,<br>                            num_workers=get_dataloader_workers()),<br>            data.DataLoader(mnist_test, batch_size, shuffle=<span class="hljs-literal">False</span>,<br>                            num_workers=get_dataloader_workers()))<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>下面，我们通过指定<code>resize</code>参数来测试<code>load_data_fashion_mnist</code>函数的图像大小调整功能。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">train_iter, test_iter = load_data_fashion_mnist(<span class="hljs-number">32</span>, resize=<span class="hljs-number">64</span>)<br><span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> train_iter:<br>    <span class="hljs-built_in">print</span>(X.shape, X.dtype, y.shape, y.dtype)<br>    <span class="hljs-keyword">break</span><br>    <br><span class="hljs-comment"># result</span><br>torch.Size([<span class="hljs-number">32</span>, <span class="hljs-number">1</span>, <span class="hljs-number">64</span>, <span class="hljs-number">64</span>]) torch.float32 torch.Size([<span class="hljs-number">32</span>]) torch.int64<br></code></pre></td></tr></tbody></table></figure>



<h1 id="softmax回归的从零开始实现"><a href="#softmax回归的从零开始实现" class="headerlink" title="softmax回归的从零开始实现"></a>softmax回归的从零开始实现</h1><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> IPython <span class="hljs-keyword">import</span> display<br><span class="hljs-keyword">from</span> d2l <span class="hljs-keyword">import</span> torch <span class="hljs-keyword">as</span> d2l<br><br>batch_size = <span class="hljs-number">256</span><br>train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size)<br></code></pre></td></tr></tbody></table></figure>



<h2 id="初始化模型参数-2"><a href="#初始化模型参数-2" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h2><ul>
<li>原始数据集中的每个样本都是28×28的图像。 本节将展平每个图像，把它们看作长度为784的向量。在后面的章节中，我们将讨论能够利用图像空间结构的特征， 但现在我们暂时只把每个像素位置看作一个特征。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">num_inputs = <span class="hljs-number">784</span><br>num_outputs = <span class="hljs-number">10</span><br><br>W = torch.normal(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>, size=(num_inputs, num_outputs), requires_grad=<span class="hljs-literal">True</span>)<br>b = torch.zeros(num_outputs, requires_grad=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>在softmax回归中，我们的输出与类别一样多。 因为我们的数据集有10个类别，所以网络输出维度为10。 因此，权重将构成一个784×10的矩阵， 偏置将构成一个1×10的行向量。 与线性回归一样，我们将使用正态分布初始化我们的权重<code>W</code>，偏置初始化为0。</p>
</blockquote>
<h2 id="定义softmax操作"><a href="#定义softmax操作" class="headerlink" title="定义softmax操作"></a>定义softmax操作</h2><ul>
<li>回想一下，实现softmax由三个步骤组成：<ol>
<li>对每个项求幂（使用<code>exp</code>）。</li>
<li>对每一行求和（小批量中每个样本是一行），得到每个样本的规范化常数。</li>
<li>将每一行除以其规范化常数，确保结果的和为1。</li>
</ol>
</li>
<li>在查看代码之前，我们回顾一下这个表达式：</li>
</ul>
<p>$$<br>\mathrm{softmax}(\mathbf{X})<em>{ij} = \frac{\exp(\mathbf{X}</em>{ij})}{\sum_k \exp(\mathbf{X}_{ik})}.<br>$$</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">softmax</span>(<span class="hljs-params">X</span>):<br>    X_exp = torch.exp(X)<br>    partition = X_exp.<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">return</span> X_exp / partition  <span class="hljs-comment"># 这里应用了广播机制</span><br></code></pre></td></tr></tbody></table></figure>

<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">X = torch.normal(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, (<span class="hljs-number">2</span>, <span class="hljs-number">5</span>))<br>X_prob = softmax(X)<br>X_prob, X_prob.<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># result</span><br>(tensor([[<span class="hljs-number">0.2968</span>, <span class="hljs-number">0.4115</span>, <span class="hljs-number">0.0945</span>, <span class="hljs-number">0.1603</span>, <span class="hljs-number">0.0368</span>],<br>         [<span class="hljs-number">0.2128</span>, <span class="hljs-number">0.5422</span>, <span class="hljs-number">0.0865</span>, <span class="hljs-number">0.1104</span>, <span class="hljs-number">0.0481</span>]]),<br> tensor([<span class="hljs-number">1.0000</span>, <span class="hljs-number">1.0000</span>]))<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>虽然这在数学上看起来是正确的，但我们在代码实现中有点草率。 矩阵中的非常大或非常小的元素可能造成数值上溢或下溢，但我们没有采取措施来防止这点。</p>
</blockquote>
<h2 id="定义模型-2"><a href="#定义模型-2" class="headerlink" title="定义模型"></a>定义模型</h2><ul>
<li>定义softmax操作后，我们可以实现softmax回归模型。 下面的代码定义了输入如何通过网络映射到输出。 注意，将数据传递到模型之前，我们使用<code>reshape</code>函数将每张原始图像展平为向量。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">net</span>(<span class="hljs-params">X</span>):<br>    <span class="hljs-keyword">return</span> softmax(torch.matmul(X.reshape((-<span class="hljs-number">1</span>, W.shape[<span class="hljs-number">0</span>])), W) + b)<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>本质上这就是$softmax(\mathbf{Xw} + b)$ -&gt; 说白了就是往输出外面套了一层softmax函数而已。 </p>
</blockquote>
<h2 id="定义损失函数-2"><a href="#定义损失函数-2" class="headerlink" title="定义损失函数"></a>定义损失函数</h2><ul>
<li>我们实现中引入的交叉熵损失函数。 这可能是深度学习中最常见的损失函数，因为目前分类问题的数量远远超过回归问题的数量。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">y = torch.tensor([<span class="hljs-number">0</span>, <span class="hljs-number">2</span>])<br>y_hat = torch.tensor([[<span class="hljs-number">0.1</span>, <span class="hljs-number">0.3</span>, <span class="hljs-number">0.6</span>], [<span class="hljs-number">0.3</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.5</span>]])<br>y_hat[[<span class="hljs-number">0</span>, <span class="hljs-number">1</span>], y]<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cross_entropy</span>(<span class="hljs-params">y_hat, y</span>):<br>    <span class="hljs-keyword">return</span> - torch.log(y_hat[<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(y_hat)), y])<br><br>cross_entropy(y_hat, y)<br><br><span class="hljs-comment"># result</span><br>tensor([<span class="hljs-number">2.3026</span>, <span class="hljs-number">0.6931</span>])<br></code></pre></td></tr></tbody></table></figure>





<h2 id="分类精度"><a href="#分类精度" class="headerlink" title="分类精度"></a>分类精度</h2><ul>
<li>给定预测概率分布<code>y_hat</code>，当我们必须输出硬预测（hard prediction）时， 我们通常选择预测概率最高的类。当预测与标签分类<code>y</code>一致时，即是正确的。 分类精度即正确预测数量与总预测数量之比。 虽然直接优化精度可能很困难（因为精度的计算不可导）， 但精度通常是我们最关心的性能衡量标准，我们在训练分类器时几乎总会关注它。</li>
<li>为了计算精度，我们执行以下操作。 首先，如果<code>y_hat</code>是矩阵，那么假定第二个维度存储每个类的预测分数。 我们使用<code>argmax</code>获得每行中最大元素的索引来获得预测类别。 然后我们将预测类别与真实<code>y</code>元素进行比较。 由于等式运算符“<code>==</code>”对数据类型很敏感， 因此我们将<code>y_hat</code>的数据类型转换为与<code>y</code>的数据类型一致。 结果是一个包含0（错）和1（对）的张量。 最后，我们求和会得到正确预测的数量。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">accuracy</span>(<span class="hljs-params">y_hat, y</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""计算预测正确的数量"""</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(y_hat.shape) &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> y_hat.shape[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">1</span>:<br>        y_hat = y_hat.argmax(axis=<span class="hljs-number">1</span>)<br>    cmp = y_hat.<span class="hljs-built_in">type</span>(y.dtype) == y<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">float</span>(cmp.<span class="hljs-built_in">type</span>(y.dtype).<span class="hljs-built_in">sum</span>())<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>我们将继续使用之前定义的变量<code>y_hat</code>和<code>y</code>分别作为预测的概率分布和标签。 可以看到，第一个样本的预测类别是2（该行的最大元素为0.6，索引为2），这与实际标签0不一致。 第二个样本的预测类别是2（该行的最大元素为0.5，索引为2），这与实际标签2一致。 因此，这两个样本的分类精度率为0.5。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">accuracy(y_hat, y) / <span class="hljs-built_in">len</span>(y)<br><br><span class="hljs-comment"># result</span><br><span class="hljs-number">0.5</span><br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>对于任意数据迭代器<code>data_iter</code>可访问的数据集， 我们可以评估在任意模型<code>net</code>的精度。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluate_accuracy</span>(<span class="hljs-params">net, data_iter</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""计算在指定数据集上模型的精度"""</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(net, torch.nn.Module):<br>        net.<span class="hljs-built_in">eval</span>()  <span class="hljs-comment"># 将模型设置为评估模式</span><br>    metric = Accumulator(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 正确预测数、预测总数</span><br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        <span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> data_iter:<br>            metric.add(accuracy(net(X), y), y.numel())<br>    <span class="hljs-keyword">return</span> metric[<span class="hljs-number">0</span>] / metric[<span class="hljs-number">1</span>]<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>这里定义一个实用程序类<code>Accumulator</code>，用于对多个变量进行累加。 在上面的<code>evaluate_accuracy</code>函数中， 我们在<code>Accumulator</code>实例中创建了2个变量， 分别用于存储正确预测的数量和预测的总数量。 当我们遍历数据集时，两者都将随着时间的推移而累加。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Accumulator</span>:  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""在n个变量上累加"""</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, n</span>):<br>        self.data = [<span class="hljs-number">0.0</span>] * n<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, *args</span>):<br>        self.data = [a + <span class="hljs-built_in">float</span>(b) <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(self.data, args)]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reset</span>(<span class="hljs-params">self</span>):<br>        self.data = [<span class="hljs-number">0.0</span>] * <span class="hljs-built_in">len</span>(self.data)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, idx</span>):<br>        <span class="hljs-keyword">return</span> self.data[idx]<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>由于我们使用随机权重初始化<code>net</code>模型， 因此该模型的精度应接近于随机猜测。 例如在有10个类别情况下的精度为0.1。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">evaluate_accuracy(net, test_iter)<br><br><span class="hljs-comment"># result</span><br><span class="hljs-number">0.0598</span><br></code></pre></td></tr></tbody></table></figure>



<h2 id="训练-2"><a href="#训练-2" class="headerlink" title="训练"></a>训练</h2><ul>
<li>我们重构训练过程的实现以使其可重复使用。 首先，我们定义一个函数来训练一个迭代周期。 请注意，<code>updater</code>是更新模型参数的常用函数，它接受批量大小作为参数。 它可以是<code>d2l.sgd</code>函数，也可以是框架的内置优化函数。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_epoch_ch3</span>(<span class="hljs-params">net, train_iter, loss, updater</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""训练模型一个迭代周期（定义见第3章）"""</span><br>    <span class="hljs-comment"># 将模型设置为训练模式</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(net, torch.nn.Module):<br>        net.train()<br>    <span class="hljs-comment"># 训练损失总和、训练准确度总和、样本数</span><br>    metric = Accumulator(<span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> train_iter:<br>        <span class="hljs-comment"># 计算梯度并更新参数</span><br>        y_hat = net(X)<br>        l = loss(y_hat, y)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(updater, torch.optim.Optimizer):<br>            <span class="hljs-comment"># 使用PyTorch内置的优化器和损失函数</span><br>            updater.zero_grad()<br>            l.mean().backward()<br>            updater.step()<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 使用定制的优化器和损失函数</span><br>            l.<span class="hljs-built_in">sum</span>().backward()<br>            updater(X.shape[<span class="hljs-number">0</span>])<br>        metric.add(<span class="hljs-built_in">float</span>(l.<span class="hljs-built_in">sum</span>()), accuracy(y_hat, y), y.numel())<br>    <span class="hljs-comment"># 返回训练损失和训练精度</span><br>    <span class="hljs-keyword">return</span> metric[<span class="hljs-number">0</span>] / metric[<span class="hljs-number">2</span>], metric[<span class="hljs-number">1</span>] / metric[<span class="hljs-number">2</span>]<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>在展示训练函数的实现之前，我们定义一个在动画中绘制数据的实用程序类<code>Animator</code>， 它能够简化本书其余部分的代码。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animator</span>:  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""在动画中绘制数据"""</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, xlabel=<span class="hljs-literal">None</span>, ylabel=<span class="hljs-literal">None</span>, legend=<span class="hljs-literal">None</span>, xlim=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">                 ylim=<span class="hljs-literal">None</span>, xscale=<span class="hljs-string">'linear'</span>, yscale=<span class="hljs-string">'linear'</span>,</span><br><span class="hljs-params">                 fmts=(<span class="hljs-params"><span class="hljs-string">'-'</span>, <span class="hljs-string">'m--'</span>, <span class="hljs-string">'g-.'</span>, <span class="hljs-string">'r:'</span></span>), nrows=<span class="hljs-number">1</span>, ncols=<span class="hljs-number">1</span>,</span><br><span class="hljs-params">                 figsize=(<span class="hljs-params"><span class="hljs-number">3.5</span>, <span class="hljs-number">2.5</span></span>)</span>):<br>        <span class="hljs-comment"># 增量地绘制多条线</span><br>        <span class="hljs-keyword">if</span> legend <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            legend = []<br>        d2l.use_svg_display()<br>        self.fig, self.axes = d2l.plt.subplots(nrows, ncols, figsize=figsize)<br>        <span class="hljs-keyword">if</span> nrows * ncols == <span class="hljs-number">1</span>:<br>            self.axes = [self.axes, ]<br>        <span class="hljs-comment"># 使用lambda函数捕获参数</span><br>        self.config_axes = <span class="hljs-keyword">lambda</span>: d2l.set_axes(<br>            self.axes[<span class="hljs-number">0</span>], xlabel, ylabel, xlim, ylim, xscale, yscale, legend)<br>        self.X, self.Y, self.fmts = <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, fmts<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, x, y</span>):<br>        <span class="hljs-comment"># 向图表中添加多个数据点</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(y, <span class="hljs-string">"__len__"</span>):<br>            y = [y]<br>        n = <span class="hljs-built_in">len</span>(y)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(x, <span class="hljs-string">"__len__"</span>):<br>            x = [x] * n<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.X:<br>            self.X = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.Y:<br>            self.Y = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> i, (a, b) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(x, y)):<br>            <span class="hljs-keyword">if</span> a <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> b <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                self.X[i].append(a)<br>                self.Y[i].append(b)<br>        self.axes[<span class="hljs-number">0</span>].cla()<br>        <span class="hljs-keyword">for</span> x, y, fmt <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(self.X, self.Y, self.fmts):<br>            self.axes[<span class="hljs-number">0</span>].plot(x, y, fmt)<br>        self.config_axes()<br>        display.display(self.fig)<br>        display.clear_output(wait=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>接下来我们实现一个训练函数， 它会在<code>train_iter</code>访问到的训练数据集上训练一个模型<code>net</code>。 该训练函数将会运行多个迭代周期（由<code>num_epochs</code>指定）。 在每个迭代周期结束时，利用<code>test_iter</code>访问到的测试数据集对模型进行评估。 我们将利用<code>Animator</code>类来可视化训练进度。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_ch3</span>(<span class="hljs-params">net, train_iter, test_iter, loss, num_epochs, updater</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""训练模型（定义见第3章）"""</span><br>    animator = Animator(xlabel=<span class="hljs-string">'epoch'</span>, xlim=[<span class="hljs-number">1</span>, num_epochs], ylim=[<span class="hljs-number">0.3</span>, <span class="hljs-number">0.9</span>],<br>                        legend=[<span class="hljs-string">'train loss'</span>, <span class="hljs-string">'train acc'</span>, <span class="hljs-string">'test acc'</span>])<br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):<br>        train_metrics = train_epoch_ch3(net, train_iter, loss, updater)<br>        test_acc = evaluate_accuracy(net, test_iter)<br>        animator.add(epoch + <span class="hljs-number">1</span>, train_metrics + (test_acc,))<br>    train_loss, train_acc = train_metrics<br>    <span class="hljs-keyword">assert</span> train_loss &lt; <span class="hljs-number">0.5</span>, train_loss<br>    <span class="hljs-keyword">assert</span> train_acc &lt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> train_acc &gt; <span class="hljs-number">0.7</span>, train_acc<br>    <span class="hljs-keyword">assert</span> test_acc &lt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> test_acc &gt; <span class="hljs-number">0.7</span>, test_acc<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>我们使用中小批量随机梯度下降来优化模型的损失函数，设置学习率为0.1。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">lr = <span class="hljs-number">0.1</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">updater</span>(<span class="hljs-params">batch_size</span>):<br>    <span class="hljs-keyword">return</span> d2l.sgd([W, b], lr, batch_size)<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>现在，我们训练模型10个迭代周期。 请注意，迭代周期（<code>num_epochs</code>）和学习率（<code>lr</code>）都是可调节的超参数。 通过更改它们的值，我们可以提高模型的分类精度。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">num_epochs = <span class="hljs-number">10</span><br>train_ch3(net, train_iter, test_iter, cross_entropy, num_epochs, updater)<br></code></pre></td></tr></tbody></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202307300938410.svg" srcset="/img/loading.gif" lazyload alt="../_images/output_softmax-regression-scratch_a48321_222_0.svg"></p>
<h2 id="预测"><a href="#预测" class="headerlink" title="预测"></a>预测</h2><p>现在训练已经完成，我们的模型已经准备好对图像进行分类预测。 给定一系列图像，我们将比较它们的实际标签（文本输出的第一行）和模型预测（文本输出的第二行）。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">predict_ch3</span>(<span class="hljs-params">net, test_iter, n=<span class="hljs-number">6</span></span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""预测标签（定义见第3章）"""</span><br>    <span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> test_iter:<br>        <span class="hljs-keyword">break</span><br>    trues = d2l.get_fashion_mnist_labels(y)<br>    preds = d2l.get_fashion_mnist_labels(net(X).argmax(axis=<span class="hljs-number">1</span>))<br>    titles = [true +<span class="hljs-string">'\n'</span> + pred <span class="hljs-keyword">for</span> true, pred <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(trues, preds)]<br>    d2l.show_images(<br>        X[<span class="hljs-number">0</span>:n].reshape((n, <span class="hljs-number">28</span>, <span class="hljs-number">28</span>)), <span class="hljs-number">1</span>, n, titles=titles[<span class="hljs-number">0</span>:n])<br><br>predict_ch3(net, test_iter)<br></code></pre></td></tr></tbody></table></figure>





<h1 id="softmax回归的简洁实现"><a href="#softmax回归的简洁实现" class="headerlink" title="softmax回归的简洁实现"></a>softmax回归的简洁实现</h1><ul>
<li>数据集引入：</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">from</span> d2l <span class="hljs-keyword">import</span> torch <span class="hljs-keyword">as</span> d2l<br><br>batch_size = <span class="hljs-number">256</span><br>train_iter, test_iter = d2l.load_data_fashion_mnist(batch_size)<br></code></pre></td></tr></tbody></table></figure>



<h2 id="初始化模型参数-3"><a href="#初始化模型参数-3" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># PyTorch不会隐式地调整输入的形状。因此，</span><br><span class="hljs-comment"># 我们在线性层前定义了展平层（flatten），来调整网络输入的形状</span><br>net = nn.Sequential(nn.Flatten(), nn.Linear(<span class="hljs-number">784</span>, <span class="hljs-number">10</span>))<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">init_weights</span>(<span class="hljs-params">m</span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(m) == nn.Linear:<br>        nn.init.normal_(m.weight, std=<span class="hljs-number">0.01</span>)<br><br>net.apply(init_weights);<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<ul>
<li>首先，通过<code>nn.Sequential</code>定义了一个神经网络模型<code>net</code>。它按照给定的顺序将一系列层（layers）组织成一个网络。在这里，<code>nn.Sequential</code>包含了两个层：<code>nn.Flatten()</code>和<code>nn.Linear(784, 10)</code>。<ul>
<li><code>nn.Flatten()</code>：这是一个用于展平操作的层，它没有可训练的参数。在深度学习中，通常要将输入数据从多维的形状（例如图像的形状是[batch_size, channels, height, width]）展平为一维的形状（[batch_size, flattened_size]），以便能够连接到后续的全连接层。</li>
<li><code>nn.Linear(784, 10)</code>：这是一个全连接层，它接收784维的输入（即展平后的图像数据），并输出10维的结果（即预测的类别数）。在这里，784是输入特征的维度，而10是输出类别的维度。</li>
</ul>
</li>
<li>其次，参数初始化。定义了一个<code>init_weights</code>函数用于初始化模型的参数。这里采用了一种常见的参数初始化方法：对于线性层（<code>nn.Linear</code>），使用正态分布（均值为0，标准差为0.01）来初始化权重参数。<ul>
<li>最后一行代码<code>net.apply(init_weights)</code>将<code>init_weights</code>函数应用到<code>net</code>模型的所有线性层上。这将导致模型的所有线性层（在这里只有一个）的权重被初始化为正态分布的随机值（均值为0，标准差为0.01）。这个初始化过程是为了确保模型在训练开始时具有一些随机性，从而避免所有参数的初始状态相同，使得训练更具有多样性和稳定性。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="重新审视Softmax的实现"><a href="#重新审视Softmax的实现" class="headerlink" title="重新审视Softmax的实现"></a>重新审视Softmax的实现</h2><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/LogSumExp">https://en.wikipedia.org/wiki/LogSumExp</a></p>
</blockquote>
<ul>
<li>softmax函数$\hat y_j = \frac{\exp(o_j)}{\sum_k \exp(o_k)}$，如果$o_k$非常大，可能导致$\exp(o_k)$大于数据类型容许的最大数字，即<em>上溢</em>（overflow）。 这将使分母或分子变为<code>inf</code>（无穷大）， 最后得到的是0、<code>inf</code>或<code>nan</code>（不是数字）的$\hat y_j$。我们无法得到一个明确定义的交叉熵值。</li>
<li>解决这个问题的一个技巧是： 在继续softmax计算之前，先从所有$o_k$中减去$\max(o_k)$。 这里可以看到每个$o_k$按常数进行的移动不会改变softmax的返回值：</li>
</ul>
<p>$$<br>\begin{split}\begin{aligned}<br>\hat y_j &amp; =  \frac{\exp(o_j - \max(o_k))\exp(\max(o_k))}{\sum_k \exp(o_k - \max(o_k))\exp(\max(o_k))} \<br>&amp; = \frac{\exp(o_j - \max(o_k))}{\sum_k \exp(o_k - \max(o_k))}.<br>\end{aligned}\end{split}<br>$$</p>
<ul>
<li><p>减法和规范化步骤之后，可能有些$o_j - \max(o_k)$具有较大的负值。 由于精度受限，$\exp(o_j - \max(o_k))$将有接近零的值，即<em>下溢</em>（underflow）。 这些值可能会四舍五入为零，使$\hat y_j$为零， 并且使得$\log(\hat y_j)$的值为<code>-inf</code>。 反向传播几步后，我们可能会发现自己面对一屏幕可怕的<code>nan</code>结果。</p>
</li>
<li><p>尽管我们要计算指数函数，但我们最终在计算交叉熵损失时会取它们的对数。 通过将softmax和交叉熵结合在一起，可以避免反向传播过程中可能会困扰我们的数值稳定性问题。 如下面的等式所示，我们避免计算$\exp(o_j - \max(o_k))$， 而可以直接使用$o_j - \max(o_k)$，因为log⁡(exp⁡(⋅))被抵消了。</p>
</li>
</ul>
<p>$$<br>\begin{split}\begin{aligned}<br>\log{(\hat y_j)} &amp; = \log\left( \frac{\exp(o_j - \max(o_k))}{\sum_k \exp(o_k - \max(o_k))}\right) \<br>&amp; = \log{(\exp(o_j - \max(o_k)))}-\log{\left( \sum_k \exp(o_k - \max(o_k)) \right)} \<br>&amp; = o_j - \max(o_k) -\log{\left( \sum_k \exp(o_k - \max(o_k)) \right)}.<br>\end{aligned}\end{split}<br>$$</p>
<ul>
<li>我们也希望保留传统的softmax函数，以备我们需要评估通过模型输出的概率。 但是，<strong>我们没有将softmax概率传递到损失函数中， 而是在交叉熵损失函数中传递未规范化的预测，并同时计算softmax及其对数。</strong></li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">loss = nn.CrossEntropyLoss(reduction=<span class="hljs-string">'none'</span>)<br></code></pre></td></tr></tbody></table></figure>



<h2 id="优化算法"><a href="#优化算法" class="headerlink" title="优化算法"></a>优化算法</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">trainer = torch.optim.SGD(net.parameters(), lr=<span class="hljs-number">0.1</span>)<br></code></pre></td></tr></tbody></table></figure>



<h2 id="训练-3"><a href="#训练-3" class="headerlink" title="训练"></a>训练</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">num_epochs = <span class="hljs-number">10</span><br>d2l.train_ch3(net, train_iter, test_iter, loss, num_epochs, trainer)<br></code></pre></td></tr></tbody></table></figure>







<h1 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h1><h2 id="synthetic-data"><a href="#synthetic-data" class="headerlink" title="synthetic_data"></a>synthetic_data</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">synthetic_data</span>(<span class="hljs-params">w, b, num_examples</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""生成y=Xw+b+噪声"""</span><br>    X = torch.normal(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, (num_examples, <span class="hljs-built_in">len</span>(w)))<br>    y = torch.matmul(X, w) + b<br>    y += torch.normal(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>, y.shape)<br>    <span class="hljs-keyword">return</span> X, y.reshape((-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br><br>true_w = torch.tensor([<span class="hljs-number">2</span>, -<span class="hljs-number">3.4</span>])<br>true_b = <span class="hljs-number">4.2</span><br>features, labels = synthetic_data(true_w, true_b, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<ul>
<li>输入为：weight, bias和数量，输出为：X矩阵和y列向量。</li>
</ul>
<ol>
<li>函数首先使用 <code>torch.normal</code> 函数生成一个维度为 <code>(num_examples, len(w))</code> 的张量 <code>X</code>，其中每个元素都是从均值为 0、标准差为 1 的正态分布中随机采样得到的。 -&gt; $X_{numExamples\ *\ len(w)}$</li>
<li>通过矩阵乘法 <code>torch.matmul(X, w)</code> 和加法 <code>+ b</code>，生成一个表示标签 <code>y</code> 的张量。这里使用了真实的权重向量 <code>w</code> 和偏置值 <code>b</code>，并将噪声添加到 <code>y</code> 中。$X_{numExamples\ *\ len(w)}\ *\ w_{len(w)\ *\ 1} + b$ -&gt; $y_{numExamples\ *\ 1}$</li>
<li>通过 <code>torch.normal</code> 函数生成一个维度与 <code>y</code> 相同的张量，并将其加到 <code>y</code> 中，以模拟噪声 -&gt; 现实世界中噪声是正常的，我们手动产生一个y.shape相同类型的噪声，并加到y矩阵上。</li>
<li>返回$X_{numExamples\ *\ len(w)}$，和y.reshape((-1, 1))，当调用 <code>y.reshape((-1, 1))</code> 时，函数会自动计算第一维的长度，以使得 <code>y</code> 的形状变为一个列向量，即第一维的长度为 <code>1</code>，而第二维的长度自适应。</li>
</ol>
<ul>
<li>函数的返回值为特征和标签，也就是我们真实的X和Y，我们使用X和Y来训练模型。</li>
</ul>
</blockquote>
<h2 id="data-iter"><a href="#data-iter" class="headerlink" title="data_iter"></a>data_iter</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">data_iter</span>(<span class="hljs-params">batch_size, features, labels</span>):<br>    num_examples = <span class="hljs-built_in">len</span>(features)<br>    indices = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(num_examples))<br>    <span class="hljs-comment"># 这些样本是随机读取的，没有特定的顺序</span><br>    random.shuffle(indices)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, num_examples, batch_size):<br>        batch_indices = torch.tensor(<br>            indices[i: <span class="hljs-built_in">min</span>(i + batch_size, num_examples)])<br>        <span class="hljs-keyword">yield</span> features[batch_indices], labels[batch_indices]<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<ul>
<li>输入为：<code>batch_size</code>（批次大小）、<code>features</code>（特征张量）和 <code>labels</code>（标签张量）。输出为：随机取样的特征和标签向量。</li>
</ul>
<ol>
<li>函数首先获取样本数量 <code>num_examples</code>，然后创建一个包含从 <code>0</code> 到 <code>num_examples-1</code> 的索引列表 <code>indices</code>。</li>
<li>通过 <code>random.shuffle</code> 函数对索引列表进行随机打乱，以实现随机读取样本。</li>
<li>通过 <code>range</code> 函数以步长为 <code>batch_size</code> 进行迭代，每次迭代生成一个批次的数据。</li>
<li>通过 <code>torch.tensor</code> 函数将当前批次的索引列表切片为一个张量 <code>batch_indices</code>，该张量包含当前批次的索引。</li>
<li>使用 <code>yield</code> 关键字返回当前批次的特征张量 <code>features[batch_indices]</code> 和标签张量 <code>labels[batch_indices]</code>。</li>
</ol>
<ul>
<li>通过使用迭代器函数 <code>data_iter</code>，可以方便地按指定的批次大小随机读取数据集的特征和标签。在训练模型时，可以使用该迭代器循环读取数据集的不同批次，以进行模型的训练和优化。</li>
</ul>
</blockquote>
<h2 id="linreg"><a href="#linreg" class="headerlink" title="linreg"></a>linreg</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">linreg</span>(<span class="hljs-params">X, w, b</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""线性回归模型"""</span><br>    <span class="hljs-keyword">return</span> torch.matmul(X, w) + b<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>该函数实现了线性回归模型，其中X是特征张量，w是权重张量，b是偏置张量。函数通过torch.matmul计算特征与权重的矩阵乘法，并将结果与偏置相加，得到线性回归的预测结果。</p>
</blockquote>
<h2 id="squared-loss"><a href="#squared-loss" class="headerlink" title="squared_loss"></a>squared_loss</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">squared_loss</span>(<span class="hljs-params">y_hat, y</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""均方损失"""</span><br>    <span class="hljs-keyword">return</span> (y_hat - y.reshape(y_hat.shape)) ** <span class="hljs-number">2</span> / <span class="hljs-number">2</span><br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>该函数实现了均方损失（平方损失），其中y_hat是模型的预测结果，y是实际标签。函数通过计算(y_hat - y.reshape(y_hat.shape))的平方，再除以2，得到均方损失。</p>
</blockquote>
<h2 id="sgd"><a href="#sgd" class="headerlink" title="sgd"></a>sgd</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sgd</span>(<span class="hljs-params">params, lr, batch_size</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""小批量随机梯度下降"""</span><br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        <span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> params:<br>            param -= lr * param.grad / batch_size<br>            param.grad.zero_()<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>该函数实现了小批量随机梯度下降（SGD）算法，用于更新模型参数。其中params是一个包含模型参数的列表，lr是学习率，batch_size是批次大小。</p>
</blockquote>
<h2 id="训练-4"><a href="#训练-4" class="headerlink" title="训练"></a>训练</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">lr = <span class="hljs-number">0.03</span><br>num_epochs = <span class="hljs-number">3</span><br>net = linreg<br>loss = squared_loss<br><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):<br>    <span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> data_iter(batch_size, features, labels):<br>        l = loss(net(X, w, b), y)  <span class="hljs-comment"># X和y的小批量损失</span><br>        <span class="hljs-comment"># 因为l形状是(batch_size,1)，而不是一个标量。l中的所有元素被加到一起，</span><br>        <span class="hljs-comment"># 并以此计算关于[w,b]的梯度</span><br>        l.<span class="hljs-built_in">sum</span>().backward()<br>        sgd([w, b], lr, batch_size)  <span class="hljs-comment"># 使用参数的梯度更新参数</span><br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        train_l = loss(net(features, w, b), labels)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f'epoch <span class="hljs-subst">{epoch + <span class="hljs-number">1</span>}</span>, loss <span class="hljs-subst">{<span class="hljs-built_in">float</span>(train_l.mean()):f}</span>'</span>)<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<ol>
<li><code>lr = 0.03</code>: <code>lr</code> 是学习率 (learning rate)，它是控制梯度下降步长的超参数，用于更新模型参数时的调整幅度。</li>
<li><code>num_epochs = 3</code>: <code>num_epochs</code> 表示迭代次数，即整个数据集将被训练3次。</li>
<li><code>net = linreg</code>: <code>net</code> 是一个线性回归模型，这里使用了<code>linreg</code>函数表示。</li>
<li><code>loss = squared_loss</code>: <code>loss</code> 是损失函数，这里使用了均方误差损失 (squared loss)。</li>
<li><code>for epoch in range(num_epochs):</code>: 开始迭代训练，共进行3次迭代。</li>
<li><code>for X, y in data_iter(batch_size, features, labels):</code>: <code>data_iter</code> 是数据迭代器，每次从<code>features</code>和<code>labels</code>中获取一个大小为<code>batch_size</code>的小批量数据。</li>
<li><code>l = loss(net(X, w, b), y)</code>: 计算当前小批量数据的预测值并计算与真实标签<code>y</code>之间的损失。</li>
<li><code>l.sum().backward()</code>: 将损失 <code>l</code> 中的所有元素加和得到一个标量值，然后计算该标量值关于模型参数<code>w</code>和<code>b</code>的梯度。</li>
<li><code>sgd([w, b], lr, batch_size)</code>: 使用随机梯度下降 (SGD) 算法，根据梯度和学习率，更新模型参数<code>w</code>和<code>b</code>。</li>
<li><code>with torch.no_grad():</code>: 这是一个不计算梯度的上下文管理器，用于更新参数时不需要计算梯度。</li>
<li><code>train_l = loss(net(features, w, b), labels)</code>: 在整个训练集上计算当前模型的损失，用于输出当前模型的训练效果。</li>
<li><code>print(f'epoch {epoch + 1}, loss {float(train_l.mean()):f}')</code>: 输出当前迭代的训练结果，包括迭代次数和平均损失值。</li>
</ol>
</blockquote>
<h2 id="l-sum"><a href="#l-sum" class="headerlink" title="l.sum"></a>l.sum</h2><p>在上面的代码中，<code>l</code> 是当前小批量数据的损失，计算得到的是一个张量，而不是一个标量。在使用梯度下降法（或其他优化算法）进行参数更新时，通常需要一个标量损失来计算参数的梯度，并对参数进行更新。所以，为了得到一个标量损失，代码中使用了 <code>l.sum()</code> 来将所有损失元素相加，得到一个标量值，然后再通过该标量值来计算关于参数的梯度。</p>
<p>让我们更详细地解释为什么需要将损失元素相加并得到一个标量值来计算梯度：</p>
<ol>
<li><strong>Backpropagation and Gradients</strong>: 在深度学习中，我们使用反向传播算法来计算模型参数的梯度。反向传播需要一个标量损失值作为起点，然后通过计算该标量相对于每个模型参数的偏导数（梯度）来进行参数更新。</li>
<li><strong>Batched Computations</strong>: 通常，在深度学习中，我们会使用小批量（batch）数据进行训练，而不是单个样本。这样做有两个原因：首先，小批量训练可以加快训练过程；其次，小批量计算有利于并行计算，提高训练效率。</li>
<li><strong>Loss Computation for Batches</strong>: 当我们使用小批量数据进行训练时，损失函数的计算也会产生小批量的损失值。这些损失值组成一个张量，而不是一个标量。</li>
<li><strong>Summing Loss Elements</strong>: 为了将小批量的损失值转换为一个标量，一种常见的方法是对损失值中的元素进行求和。在代码中，<code>l.sum()</code> 就是将 <code>l</code> 这个张量中的所有元素相加得到一个标量值，从而成为反向传播的起点。</li>
</ol>
<p>所以，<code>l.sum().backward()</code> 的目的是计算 <code>l</code> 张量中所有元素的梯度，将其作为损失函数关于模型参数的梯度，并用于后续的参数更新。这种技巧允许我们在小批量数据上训练，并将损失计算转换为标量，以便进行反向传播。</p>
<h2 id="torch-no-grad"><a href="#torch-no-grad" class="headerlink" title="torch.no_grad"></a>torch.no_grad</h2><p>在PyTorch中，<code>torch.no_grad()</code>是一个上下文管理器，也称为上下文环境或上下文块。它的作用是告诉PyTorch在该上下文块内不需要计算梯度，从而在此期间避免不必要的梯度计算，节省内存和计算资源。通常，<code>torch.no_grad()</code>用于执行一些不需要梯度的操作，比如在模型训练过程中的参数更新阶段或进行模型推断时。</p>
<p>详细解释如下：</p>
<ol>
<li><strong>Gradient Tracking in PyTorch</strong>: 在PyTorch中，默认情况下，所有的张量都会自动跟踪计算梯度信息。这个特性称为自动微分（Autograd），它是PyTorch进行梯度计算和反向传播的基础。当你对一个张量进行操作（比如加减乘除、求和等），PyTorch会构建一个计算图，用于计算该操作的梯度。这样在反向传播时，PyTorch可以根据计算图自动计算出梯度，从而进行参数的更新。</li>
<li><strong>Disabling Gradient Calculation with <code>torch.no_grad()</code></strong>: 有些情况下，我们并不希望进行梯度计算，比如在参数更新阶段，我们只需要根据梯度更新参数，而不需要计算额外的梯度信息。这时，可以使用<code>torch.no_grad()</code>上下文管理器来暂时关闭梯度计算。在这个上下文块内，所有的操作不会被跟踪，也不会构建计算图，从而节省了梯度计算所需的内存和计算资源。</li>
<li><strong>Benefits of Using <code>torch.no_grad()</code></strong>:<ul>
<li><strong>Memory Savings</strong>: 由于不计算梯度，所以不需要保存梯度相关的中间结果，从而减少了内存的使用量。</li>
<li><strong>Speedup</strong>: 不进行梯度计算可以加快计算速度，特别是在推断（inference）阶段，当不需要反向传播时，使用<code>torch.no_grad()</code>可以显著加速代码执行。</li>
<li><strong>Preventing Unintended Gradient Updates</strong>: 有时候在模型推断阶段，如果不使用<code>torch.no_grad()</code>，可能会不小心修改了模型参数，而这些修改是不希望的。</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><br><span class="hljs-comment"># 创建一个需要计算梯度的张量</span><br>x = torch.tensor([<span class="hljs-number">2.0</span>], requires_grad=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 在计算图上计算 x^2</span><br>y = x ** <span class="hljs-number">2</span><br><br><span class="hljs-comment"># 使用torch.no_grad()进行推断，不需要梯度</span><br><span class="hljs-keyword">with</span> torch.no_grad():<br>    <span class="hljs-comment"># 在这个上下文块内，任何操作都不会被跟踪，也不会构建计算图</span><br>    z = y * <span class="hljs-number">3</span><br><br><span class="hljs-built_in">print</span>(z)  <span class="hljs-comment"># tensor([12.])</span><br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>在上面的示例中，在<code>torch.no_grad()</code>上下文块内，<code>y * 3</code>操作不会被跟踪，因此不会计算梯度。这对于推断阶段或者仅需要参数更新的情况非常有用。</p>
</blockquote>
<h2 id="load-data-fashion-mnist"><a href="#load-data-fashion-mnist" class="headerlink" title="load_data_fashion_mnist"></a>load_data_fashion_mnist</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_data_fashion_mnist</span>(<span class="hljs-params">batch_size, resize=<span class="hljs-literal">None</span></span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""下载Fashion-MNIST数据集，然后将其加载到内存中"""</span><br>    trans = [transforms.ToTensor()]<br>    <span class="hljs-keyword">if</span> resize:<br>        trans.insert(<span class="hljs-number">0</span>, transforms.Resize(resize))<br>    trans = transforms.Compose(trans)<br>    mnist_train = torchvision.datasets.FashionMNIST(<br>        root=<span class="hljs-string">"../data"</span>, train=<span class="hljs-literal">True</span>, transform=trans, download=<span class="hljs-literal">True</span>)<br>    mnist_test = torchvision.datasets.FashionMNIST(<br>        root=<span class="hljs-string">"../data"</span>, train=<span class="hljs-literal">False</span>, transform=trans, download=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">return</span> (data.DataLoader(mnist_train, batch_size, shuffle=<span class="hljs-literal">True</span>,<br>                            num_workers=get_dataloader_workers()),<br>            data.DataLoader(mnist_test, batch_size, shuffle=<span class="hljs-literal">False</span>,<br>                            num_workers=get_dataloader_workers()))<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<ul>
<li>它接受两个参数：<code>batch_size</code>（用于指定每个批次中图像的数量）和<code>resize</code>（用于指定是否调整图像的尺寸）。</li>
</ul>
<ol>
<li><code>trans = [transforms.ToTensor()]</code>: 这里定义了一个转换列表<code>trans</code>，其中包含一个<code>transforms.ToTensor()</code>操作。<code>transforms.ToTensor()</code>用于将PIL图像或NumPy数组转换为PyTorch张量。</li>
<li><code>trans.insert(0, transforms.Resize(resize))</code>: 如果传入了<code>resize</code>值，则在转换列表<code>trans</code>的开头插入一个<code>transforms.Resize(resize)</code>操作。<code>transforms.Resize()</code>用于调整图像的尺寸。</li>
<li><code>trans = transforms.Compose(trans)</code>: 这一行将转换列表<code>trans</code>中的操作组合成一个<code>transforms.Compose</code>对象。<code>transforms.Compose</code>用于将多个图像转换操作串联起来，依次应用于图像数据。</li>
<li><code>mnist_train = torchvision.datasets.FashionMNIST(root="../data", train=True, transform=trans, download=True)</code>: 这一行加载训练集。<code>torchvision.datasets.FashionMNIST</code>用于下载和加载Fashion-MNIST数据集。<code>root</code>参数指定数据集下载的目录，<code>train=True</code>表示加载训练集，<code>transform=trans</code>表示对加载的图像应用前面定义的转换操作，<code>download=True</code>表示在数据目录中下载数据集（如果数据集尚未下载）。</li>
<li><code>mnist_test = torchvision.datasets.FashionMNIST(root="../data", train=False, transform=trans, download=True)</code>: 这一行加载测试集，与上一行类似，只是<code>train=False</code>表示加载测试集。</li>
<li><code>return (data.DataLoader(mnist_train, batch_size, shuffle=True, num_workers=get_dataloader_workers()), data.DataLoader(mnist_test, batch_size, shuffle=False, num_workers=get_dataloader_workers()))</code>: 最后，函数返回两个<code>DataLoader</code>对象，一个用于训练集，另一个用于测试集。<code>DataLoader</code>用于将数据集划分为小批次，并提供多线程数据加载的功能。<code>num_workers=get_dataloader_workers()</code>指定了在数据加载过程中使用的工作线程数（使用<code>get_dataloader_workers()</code>函数来获取适当的工作线程数，该函数可能是其他代码中定义的）。</li>
</ol>
</blockquote>
<h2 id="Softmax"><a href="#Softmax" class="headerlink" title="Softmax"></a>Softmax</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">softmax</span>(<span class="hljs-params">X</span>):<br>    X_exp = torch.exp(X)<br>    partition = X_exp.<span class="hljs-built_in">sum</span>(<span class="hljs-number">1</span>, keepdim=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">return</span> X_exp / partition  <span class="hljs-comment"># 这里应用了广播机制</span><br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<ol>
<li><code>torch.exp(X)</code>计算输入向量X中每个元素的指数值。这是为了确保每个元素都是非负的。</li>
<li><code>X_exp.sum(1, keepdim=True)</code>对<code>X_exp</code>中的每一行求和，<code>sum(1)</code>表示沿着第1维（即行）进行求和。<code>keepdim=True</code>表示保持结果的维度，使得返回的结果仍然是一个列向量（如果输入是一个二维矩阵的话）。</li>
<li>将<code>X_exp</code>中的每个元素除以对应行的和（<code>partition</code>），得到一个概率分布。这样做确保了概率分布中的每个元素都在0到1的范围内，并且它们的和为1。由于PyTorch中的广播机制，每个元素会自动与同一行中的其他元素进行除法。</li>
</ol>
<ul>
<li>总结起来，这个函数将输入向量X中的每个元素转换为非负值，并确保它们的和为1，从而得到一个概率分布，这在很多分类问题中非常有用。</li>
</ul>
</blockquote>
<h2 id="accuracy"><a href="#accuracy" class="headerlink" title="accuracy"></a>accuracy</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">accuracy</span>(<span class="hljs-params">y_hat, y</span>):<br>    <span class="hljs-string">"""计算预测正确的数量"""</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(y_hat.shape) &gt; <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> y_hat.shape[<span class="hljs-number">1</span>] &gt; <span class="hljs-number">1</span>:<br>        y_hat = y_hat.argmax(axis=<span class="hljs-number">1</span>)<br>    cmp = y_hat.<span class="hljs-built_in">type</span>(y.dtype) == y<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">float</span>(cmp.<span class="hljs-built_in">type</span>(y.dtype).<span class="hljs-built_in">sum</span>())<br><br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<ul>
<li>y_hat 是模型的预测输出，它是一个二维张量（或数组），其中每一行代表一个样本的预测结果，每一列对应一个类别的预测概率。y 是真实标签，是一个一维张量（或数组），其中每个元素对应一个样本的真实类别标签。</li>
</ul>
<ol>
<li>if len(y_hat.shape) &gt; 1 and y_hat.shape[1] &gt; 1: 这一行判断了 y_hat 是否为一个多类别预测的结果。如果是多类别预测，即 y_hat 是一个二维数组（或张量），并且每一行代表一个样本的预测概率分布（每个类别的概率），则通过 argmax(axis=1) 取出每行中最大值所在的列索引，得到每个样本的预测类别（即取概率最大的类别作为预测结果）。</li>
<li>cmp = y_hat.type(y.dtype) == y 这一行对预测结果 y_hat 与真实标签 y 进行逐元素比较，生成一个布尔值张量（或数组），其中元素为 True 表示预测正确，False 表示预测错误。</li>
<li>return float(cmp.type(y.dtype).sum()) 最后，计算预测正确的数量。将布尔值张量 cmp 转换为与 y 相同的数据类型（可能是整数或浮点数），然后对这个张量中为 True 的元素（即预测正确的情况）求和，得到预测正确的样本数量，并将其转换为浮点数类型返回作为准确率。</li>
</ol>
<ul>
<li>总结起来，这个函数用于计算模型在分类任务中的准确率，通过将预测结果与真实标签逐元素比较来统计预测正确的样本数量，并返回准确率（预测正确样本数量除以总样本数量）。</li>
</ul>
</blockquote>
<h2 id="cross-entropy"><a href="#cross-entropy" class="headerlink" title="cross_entropy"></a>cross_entropy</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">cross_entropy</span>(<span class="hljs-params">y_hat, y</span>):<br>    <span class="hljs-keyword">return</span> - torch.log(y_hat[<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(y_hat)), y])<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<ul>
<li>y_hat 是模型的预测输出，它是一个二维张量（或数组），其中每一行代表一个样本的预测结果，每一列对应一个类别的预测概率。y 是真实标签，是一个一维张量（或数组），其中每个元素对应一个样本的真实类别标签。最后，返回计算得到的交叉熵损失值。在实际应用中，通常会对所有样本的损失值求平均，以得到整体的平均交叉熵损失。</li>
</ul>
<ol>
<li><p>range(len(y_hat)) 创建了一个表示从 0 到 len(y_hat)-1 的整数列表，它的长度等于 y_hat 的行数，也就是样本的数量。</p>
</li>
<li><p>y_hat[range(len(y_hat)), y] 这一部分使用了切片操作，其中 range(len(y_hat)) 用于选择 y_hat 中的每一行，而 y 则用于选择对应行中的元素（类别标签）。这样，我们获取了模型对每个样本预测的类别的概率值。</p>
</li>
<li><p>torch.log(…) 计算了取对数的负值，这是交叉熵损失函数的核心部分。交叉熵损失度量了预测概率分布与真实标签之间的差异，对于每个样本，它将预测类别对应的概率取对数，并求取其负值。</p>
</li>
</ol>
<ul>
<li>总结起来，这个函数用于计算模型在分类任务中的交叉熵损失。它通过将模型预测的类别概率取对数并求取其负值来衡量预测结果与真实标签之间的差异。</li>
</ul>
</blockquote>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><br><span class="hljs-comment"># 假设模型的预测概率为：</span><br>y_hat = torch.tensor([[<span class="hljs-number">0.1</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.7</span>],<br>                      [<span class="hljs-number">0.8</span>, <span class="hljs-number">0.1</span>, <span class="hljs-number">0.1</span>],<br>                      [<span class="hljs-number">0.3</span>, <span class="hljs-number">0.4</span>, <span class="hljs-number">0.3</span>],<br>                      [<span class="hljs-number">0.5</span>, <span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>]])<br><br><span class="hljs-comment"># 假设真实标签为：</span><br>y = torch.tensor([<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>])<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">cross_entropy</span>(<span class="hljs-params">y_hat, y</span>):<br>    <span class="hljs-keyword">return</span> -torch.log(y_hat[<span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(y_hat)), y])<br><br><span class="hljs-comment"># 计算交叉熵损失</span><br>loss = cross_entropy(y_hat, y)<br><br><span class="hljs-built_in">print</span>(loss)<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>结果为：tensor([0.3567, 2.3026, 0.9163, 1.2039])</p>
</blockquote>
<ul>
<li><p>本质上y_hat[xIdx, yIdx]是对于y_hat中元素的定位：</p>
<ul>
<li>对于第一个样本，<code>y[0]</code> 的值是2，所以我们选择 <code>y_hat[0, 2]</code>，即第0行第2列的预测概率值，它是0.7。</li>
<li>对于第二个样本，<code>y[1]</code> 的值是0，所以我们选择 <code>y_hat[1, 0]</code>，即第1行第0列的预测概率值，它是0.8。</li>
<li>对于第三个样本，<code>y[2]</code> 的值是1，所以我们选择 <code>y_hat[2, 1]</code>，即第2行第1列的预测概率值，它是0.4。</li>
<li>对于第四个样本，<code>y[3]</code> 的值是2，所以我们选择 <code>y_hat[3, 2]</code>，即第3行第2列的预测概率值，它是0.3。</li>
</ul>
</li>
<li><p>结果：</p>
<ul>
<li><p>对于第一个样本，真实标签是2，模型预测这个类别的概率是0.7，交叉熵损失为 -log(0.7) ≈ 0.3567。</p>
</li>
<li><p>对于第二个样本，真实标签是0，模型预测这个类别的概率是0.8，交叉熵损失为 -log(0.8) ≈ 2.3026。</p>
</li>
<li><p>对于第三个样本，真实标签是1，模型预测这个类别的概率是0.4，交叉熵损失为 -log(0.4) ≈ 0.9163。</p>
</li>
<li><p>对于第四个样本，真实标签是2，模型预测这个类别的概率是0.3，交叉熵损失为 -log(0.3) ≈ 1.2039。</p>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>说白了就是<strong>正确位置</strong>对应的<strong>预测概率</strong>，取个-log罢了</p>
</blockquote>
<h2 id="evaluate-accuracy"><a href="#evaluate-accuracy" class="headerlink" title="evaluate_accuracy"></a>evaluate_accuracy</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Accumulator</span>:  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""在n个变量上累加"""</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, n</span>):<br>        self.data = [<span class="hljs-number">0.0</span>] * n<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, *args</span>):<br>        self.data = [a + <span class="hljs-built_in">float</span>(b) <span class="hljs-keyword">for</span> a, b <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(self.data, args)]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">reset</span>(<span class="hljs-params">self</span>):<br>        self.data = [<span class="hljs-number">0.0</span>] * <span class="hljs-built_in">len</span>(self.data)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__getitem__</span>(<span class="hljs-params">self, idx</span>):<br>        <span class="hljs-keyword">return</span> self.data[idx]<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">evaluate_accuracy</span>(<span class="hljs-params">net, data_iter</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""计算在指定数据集上模型的精度"""</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(net, torch.nn.Module):<br>        net.<span class="hljs-built_in">eval</span>()  <span class="hljs-comment"># 将模型设置为评估模式</span><br>    metric = Accumulator(<span class="hljs-number">2</span>)  <span class="hljs-comment"># 正确预测数、预测总数</span><br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        <span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> data_iter:<br>            metric.add(accuracy(net(X), y), y.numel())<br>    <span class="hljs-keyword">return</span> metric[<span class="hljs-number">0</span>] / metric[<span class="hljs-number">1</span>]<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<ul>
<li><p><code>Accumulator</code>类： 这是一个简单的累加器类，用于在n个变量上进行累加。它有三个主要方法：</p>
<ul>
<li><p><code>__init__(self, n)</code>: 构造函数，初始化累加器对象，接收一个整数n作为参数，并创建一个长度为n的列表<code>self.data</code>，并初始化所有元素为0.0。</p>
</li>
<li><p><code>add(self, *args)</code>: 用于将输入的参数与累加器中的元素逐元素相加。它接收可变数量的参数（*args），这些参数与累加器的每个元素一一对应。注意，这里使用<code>zip()</code>函数将输入的参数与<code>self.data</code>中的元素一一配对。</p>
</li>
<li><p><code>reset(self)</code>: 将累加器中的所有元素重置为0.0。</p>
</li>
<li><p><code>__getitem__(self, idx)</code>: 这是一个特殊方法，使得累加器对象可以通过索引直接获取对应位置的元素值。</p>
</li>
</ul>
</li>
<li><p><code>evaluate_accuracy(net, data_iter)</code>函数： 这个函数用于计算在指定数据集上模型的精度。它接收两个参数：<code>net</code>是一个PyTorch的模型，<code>data_iter</code>是一个数据迭代器，用于遍历数据集中的样本。</p>
<ul>
<li>函数首先将模型设置为评估模式，即<code>net.eval()</code>，这是因为在评估阶段我们不需要进行梯度计算。</li>
<li>然后，函数创建了一个<code>Accumulator</code>对象 <code>metric</code>，用于记录正确预测数和预测总数，这两个指标将用于计算模型的精度。</li>
<li>接下来，使用<code>torch.no_grad()</code>上下文管理器来关闭梯度计算，避免不必要的计算和内存占用。然后，通过遍历<code>data_iter</code>中的每个样本，计算每个样本的预测准确率，并将结果累加到<code>metric</code>中。</li>
<li><code>accuracy(net(X), y)</code>：这里调用了之前提到的计算准确率的函数，<code>net(X)</code>对输入样本X进行预测，然后与真实标签y一起传递给<code>accuracy</code>函数，得到每个样本的预测准确率。<code>y.numel()</code>：计算了当前样本的标签数量，用于累加到<code>metric</code>中的预测总数。</li>
</ul>
</li>
<li><p>最后，返回模型在数据集上的精度，即正确预测数除以预测总数。</p>
</li>
</ul>
</blockquote>
<h2 id="Animator"><a href="#Animator" class="headerlink" title="Animator"></a>Animator</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animator</span>:  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""在动画中绘制数据"""</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, xlabel=<span class="hljs-literal">None</span>, ylabel=<span class="hljs-literal">None</span>, legend=<span class="hljs-literal">None</span>, xlim=<span class="hljs-literal">None</span>,</span><br><span class="hljs-params">                 ylim=<span class="hljs-literal">None</span>, xscale=<span class="hljs-string">'linear'</span>, yscale=<span class="hljs-string">'linear'</span>,</span><br><span class="hljs-params">                 fmts=(<span class="hljs-params"><span class="hljs-string">'-'</span>, <span class="hljs-string">'m--'</span>, <span class="hljs-string">'g-.'</span>, <span class="hljs-string">'r:'</span></span>), nrows=<span class="hljs-number">1</span>, ncols=<span class="hljs-number">1</span>,</span><br><span class="hljs-params">                 figsize=(<span class="hljs-params"><span class="hljs-number">3.5</span>, <span class="hljs-number">2.5</span></span>)</span>):<br>        <span class="hljs-comment"># 增量地绘制多条线</span><br>        <span class="hljs-keyword">if</span> legend <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            legend = []<br>        d2l.use_svg_display()<br>        self.fig, self.axes = d2l.plt.subplots(nrows, ncols, figsize=figsize)<br>        <span class="hljs-keyword">if</span> nrows * ncols == <span class="hljs-number">1</span>:<br>            self.axes = [self.axes, ]<br>        <span class="hljs-comment"># 使用lambda函数捕获参数</span><br>        self.config_axes = <span class="hljs-keyword">lambda</span>: d2l.set_axes(<br>            self.axes[<span class="hljs-number">0</span>], xlabel, ylabel, xlim, ylim, xscale, yscale, legend)<br>        self.X, self.Y, self.fmts = <span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, fmts<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">self, x, y</span>):<br>        <span class="hljs-comment"># 向图表中添加多个数据点</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(y, <span class="hljs-string">"__len__"</span>):<br>            y = [y]<br>        n = <span class="hljs-built_in">len</span>(y)<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> <span class="hljs-built_in">hasattr</span>(x, <span class="hljs-string">"__len__"</span>):<br>            x = [x] * n<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.X:<br>            self.X = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> self.Y:<br>            self.Y = [[] <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n)]<br>        <span class="hljs-keyword">for</span> i, (a, b) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(<span class="hljs-built_in">zip</span>(x, y)):<br>            <span class="hljs-keyword">if</span> a <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span> <span class="hljs-keyword">and</span> b <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                self.X[i].append(a)<br>                self.Y[i].append(b)<br>        self.axes[<span class="hljs-number">0</span>].cla()<br>        <span class="hljs-keyword">for</span> x, y, fmt <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(self.X, self.Y, self.fmts):<br>            self.axes[<span class="hljs-number">0</span>].plot(x, y, fmt)<br>        self.config_axes()<br>        display.display(self.fig)<br>        display.clear_output(wait=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<ul>
<li>参数<ul>
<li><code>xlabel</code>: 横轴（x轴）的标签。</li>
<li><code>ylabel</code>: 纵轴（y轴）的标签。</li>
<li><code>legend</code>: 图例，用于标识不同曲线的含义。</li>
<li><code>xlim</code>: 横轴的范围（最小值和最大值），用于限定横轴显示的数据范围。</li>
<li><code>ylim</code>: 纵轴的范围（最小值和最大值），用于限定纵轴显示的数据范围。</li>
<li><code>xscale</code>: 横轴的缩放方式，可选值为 <code>'linear'</code>（线性缩放）或 <code>'log'</code>（对数缩放）。</li>
<li><code>yscale</code>: 纵轴的缩放方式，可选值为 <code>'linear'</code>（线性缩放）或 <code>'log'</code>（对数缩放）。</li>
<li><code>fmts</code>: 一个包含不同线条样式的列表，用于绘制多条曲线时使用。</li>
<li><code>nrows</code>: 子图的行数。</li>
<li><code>ncols</code>: 子图的列数。</li>
<li><code>figsize</code>: 图表的大小，用元组表示，比如 <code>(width, height)</code>。</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="train-epoch-ch3"><a href="#train-epoch-ch3" class="headerlink" title="train_epoch_ch3"></a>train_epoch_ch3</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_epoch_ch3</span>(<span class="hljs-params">net, train_iter, loss, updater</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""训练模型一个迭代周期（定义见第3章）"""</span><br>    <span class="hljs-comment"># 将模型设置为训练模式</span><br>    <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(net, torch.nn.Module):<br>        net.train()<br>    <span class="hljs-comment"># 训练损失总和、训练准确度总和、样本数</span><br>    metric = Accumulator(<span class="hljs-number">3</span>)<br>    <span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> train_iter:<br>        <span class="hljs-comment"># 计算梯度并更新参数</span><br>        y_hat = net(X)<br>        l = loss(y_hat, y)<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(updater, torch.optim.Optimizer):<br>            <span class="hljs-comment"># 使用PyTorch内置的优化器和损失函数</span><br>            updater.zero_grad()<br>            l.mean().backward()<br>            updater.step()<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 使用定制的优化器和损失函数</span><br>            l.<span class="hljs-built_in">sum</span>().backward()<br>            updater(X.shape[<span class="hljs-number">0</span>])<br>        metric.add(<span class="hljs-built_in">float</span>(l.<span class="hljs-built_in">sum</span>()), accuracy(y_hat, y), y.numel())<br>    <span class="hljs-comment"># 返回训练损失和训练精度</span><br>    <span class="hljs-keyword">return</span> metric[<span class="hljs-number">0</span>] / metric[<span class="hljs-number">2</span>], metric[<span class="hljs-number">1</span>] / metric[<span class="hljs-number">2</span>]<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<ol>
<li><code>net.train()</code>：首先将模型 <code>net</code> 设置为训练模式。这是因为有一些模型（如Dropout）在训练和评估时有不同的行为，设置为训练模式会启用这些特定的行为。</li>
<li><code>metric = Accumulator(3)</code>：创建一个 <code>Accumulator</code> 对象 <code>metric</code> 用于记录训练损失总和、训练准确度总和以及样本数。</li>
<li><code>for X, y in train_iter:</code>：遍历训练数据集的迭代器 <code>train_iter</code>，其中 <code>X</code> 是输入特征，<code>y</code> 是对应的真实标签。</li>
<li><code>y_hat = net(X)</code>：通过模型 <code>net</code> 对输入特征 <code>X</code> 进行预测，得到预测结果 <code>y_hat</code>。</li>
<li><code>l = loss(y_hat, y)</code>：计算预测结果 <code>y_hat</code> 和真实标签 <code>y</code> 之间的损失，使用提供的损失函数 <code>loss</code>。</li>
<li><code>if isinstance(updater, torch.optim.Optimizer):</code>：这个条件判断是为了处理不同的优化器。如果 <code>updater</code> 是PyTorch内置的优化器（如SGD、Adam等），则使用PyTorch的优化器进行梯度计算和参数更新。<ul>
<li><code>updater.zero_grad()</code>: 清空之前的梯度信息。</li>
<li><code>l.mean().backward()</code>: 计算损失 <code>l</code> 的平均值，并进行反向传播计算梯度。</li>
<li><code>updater.step()</code>: 使用优化器根据计算得到的梯度更新模型的参数。</li>
</ul>
</li>
<li><code>else:</code>：如果 <code>updater</code> 不是PyTorch内置的优化器，则使用定制的优化器进行梯度计算和参数更新。在这种情况下，假设 <code>updater</code> 是一个自定义的函数，它接收一个批次的大小 <code>X.shape[0]</code> 作为参数，用于更新模型的参数。</li>
<li><code>metric.add(float(l.sum()), accuracy(y_hat, y), y.numel())</code>：将本次迭代的损失、准确度和样本数量添加到 <code>metric</code> 中。</li>
<li><code>return metric[0] / metric[2], metric[1] / metric[2]</code>：返回训练周期内的平均损失和平均准确度，用于评估模型在一个迭代周期内的训练性能。</li>
</ol>
<ul>
<li><code>train_epoch_ch3</code> 函数用于在一个迭代周期内训练模型。它遍历训练数据集的迭代器，计算损失、梯度，并根据提供的优化器更新模型的参数。在训练过程中，还会记录损失和准确度的累积和，最后返回一个迭代周期内的平均损失和平均准确度。</li>
</ul>
</blockquote>
<h2 id="train-ch3"><a href="#train-ch3" class="headerlink" title="train_ch3"></a>train_ch3</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">train_ch3</span>(<span class="hljs-params">net, train_iter, test_iter, loss, num_epochs, updater</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""训练模型（定义见第3章）"""</span><br>    animator = Animator(xlabel=<span class="hljs-string">'epoch'</span>, xlim=[<span class="hljs-number">1</span>, num_epochs], ylim=[<span class="hljs-number">0.3</span>, <span class="hljs-number">0.9</span>],<br>                        legend=[<span class="hljs-string">'train loss'</span>, <span class="hljs-string">'train acc'</span>, <span class="hljs-string">'test acc'</span>])<br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):<br>        train_metrics = train_epoch_ch3(net, train_iter, loss, updater)<br>        test_acc = evaluate_accuracy(net, test_iter)<br>        animator.add(epoch + <span class="hljs-number">1</span>, train_metrics + (test_acc,))<br>    train_loss, train_acc = train_metrics<br>    <span class="hljs-keyword">assert</span> train_loss &lt; <span class="hljs-number">0.5</span>, train_loss<br>    <span class="hljs-keyword">assert</span> train_acc &lt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> train_acc &gt; <span class="hljs-number">0.7</span>, train_acc<br>    <span class="hljs-keyword">assert</span> test_acc &lt;= <span class="hljs-number">1</span> <span class="hljs-keyword">and</span> test_acc &gt; <span class="hljs-number">0.7</span>, test_acc<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<ol>
<li><code>animator = Animator(...)</code>: 这行代码创建一个 <code>Animator</code> 对象，用于可视化并绘制训练损失、训练准确度和测试准确度等指标的图表。<code>Animator</code> 对象被初始化为使用提供的配置参数绘制图表。</li>
<li><code>for epoch in range(num_epochs):</code>: 这个循环在 <code>num_epochs</code> 指定的迭代周期内运行，表示训练过程中的迭代次数。</li>
<li><code>train_metrics = train_epoch_ch3(net, train_iter, loss, updater)</code>: 这行代码调用 <code>train_epoch_ch3</code> 函数（前面已解释）在训练数据迭代器 <code>train_iter</code> 上训练模型一个迭代周期，使用损失函数 <code>loss</code> 和更新器函数 <code>updater</code>。该函数返回当前迭代周期内的平均训练损失和训练准确度，这些指标被存储在 <code>train_metrics</code> 中。</li>
<li><code>test_acc = evaluate_accuracy(net, test_iter)</code>: 在训练一个迭代周期后，这行代码调用 <code>evaluate_accuracy</code> 函数（前面已解释）来评估模型在测试数据迭代器 <code>test_iter</code> 上的准确度。计算得到的测试准确度被存储在 <code>test_acc</code> 中。</li>
<li><code>animator.add(epoch + 1, train_metrics + (test_acc,))</code>: 这行代码将当前迭代周期的训练指标和测试准确度添加到 <code>Animator</code> 对象 <code>animator</code> 中。它用于可视化并更新图表中的数据。</li>
<li><code>train_loss, train_acc = train_metrics</code>: 在所有迭代周期完成训练后，最终的训练损失和训练准确度分别被存储在 <code>train_loss</code> 和 <code>train_acc</code> 中。</li>
<li><code>assert train_loss &lt; 0.5, train_loss</code>: 这行代码是一个断言语句，用于检查最终的训练损失是否小于 0.5。如果条件不满足，将会抛出 <code>AssertionError</code>，表示训练过程可能没有按预期进行。</li>
<li><code>assert train_acc &lt;= 1 and train_acc &gt; 0.7, train_acc</code>: 这行代码是一个断言语句，用于检查最终的训练准确度是否在 0.7 到 1 之间。如果条件不满足，将会抛出 <code>AssertionError</code>。</li>
<li><code>assert test_acc &lt;= 1 and test_acc &gt; 0.7, test_acc</code>: 这行代码是一个断言语句，用于检</li>
</ol>
</blockquote>
<h1 id="References"><a href="#References" class="headerlink" title="References:"></a>References:</h1><ol>
<li><a target="_blank" rel="noopener" href="https://zh.d2l.ai/chapter_linear-networks/linear-regression.html">https://zh.d2l.ai/chapter_linear-networks/linear-regression.html</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/95814925">https://zhuanlan.zhihu.com/p/95814925</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=s7BxboxEfnU">https://www.youtube.com/watch?v=s7BxboxEfnU</a></li>
<li><a target="_blank" rel="noopener" href="https://d2l.ai/chapter_appendix-mathematics-for-deep-learning/distributions.html">数学分布</a></li>
<li><a target="_blank" rel="noopener" href="https://zh-v1.d2l.ai/chapter_deep-learning-basics/softmax-regression.html">https://zh-v1.d2l.ai/chapter_deep-learning-basics/softmax-regression.html</a></li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/tardis/zm/art/35709485?source_id=1003">https://www.zhihu.com/tardis/zm/art/35709485?source_id=1003</a></li>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/LogSumExp">https://en.wikipedia.org/wiki/LogSumExp</a></li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/AI/" class="category-chain-item">AI</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%A0%940%E8%87%AA%E5%AD%A6/">#研0自学</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>D2L-3-Linear Neural Networks</div>
      <div>http://example.com/2023/07/25/d2l-3-linear-neural-networks/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Alexander Liu</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年7月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/07/30/d2l-4-multilayer-perceptrons/" title="D2L-4-Multilayer Perceptrons">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">D2L-4-Multilayer Perceptrons</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/07/23/d2l-2-preliminaries/" title="D2L-2-Preliminaries">
                        <span class="hidden-mobile">D2L-2-Preliminaries</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  





  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.events.registerRefreshCallback(function() {
      if ('mermaid' in window) {
        mermaid.init();
      }
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
