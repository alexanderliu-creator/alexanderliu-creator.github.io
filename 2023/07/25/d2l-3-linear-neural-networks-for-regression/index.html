

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/tuzi.png">
  <link rel="icon" href="/img/tuzi.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Alexander Liu">
  <meta name="keywords" content="分布式系统,后端研发,数据协同">
  
    <meta name="description" content="本章我们将介绍神经网络的整个训练过程， 包括：定义简单的神经网络架构、数据处理、指定损失函数和如何训练模型。 为了更容易学习，我们将从经典算法————线性神经网络开始，介绍神经网络的基础知识。 经典统计学习技术中的线性回归和softmax回归可以视为线性神经网络， 这些知识将为本书其他部分中更复杂的技术奠定基础。">
<meta property="og:type" content="article">
<meta property="og:title" content="D2L-3-Linear Neural Networks for Regression">
<meta property="og:url" content="http://example.com/2023/07/25/d2l-3-linear-neural-networks-for-regression/index.html">
<meta property="og:site_name" content="兔の博客">
<meta property="og:description" content="本章我们将介绍神经网络的整个训练过程， 包括：定义简单的神经网络架构、数据处理、指定损失函数和如何训练模型。 为了更容易学习，我们将从经典算法————线性神经网络开始，介绍神经网络的基础知识。 经典统计学习技术中的线性回归和softmax回归可以视为线性神经网络， 这些知识将为本书其他部分中更复杂的技术奠定基础。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202307231956594.jpg">
<meta property="article:published_time" content="2023-07-25T09:01:02.000Z">
<meta property="article:modified_time" content="2023-07-27T16:09:45.923Z">
<meta property="article:author" content="Alexander Liu">
<meta property="article:tag" content="研0自学">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202307231956594.jpg">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>D2L-3-Linear Neural Networks for Regression - 兔の博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0">
<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
<link rel="alternate" href="/atom.xml" title="兔の博客" type="application/atom+xml">
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>兔的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/background_post.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="D2L-3-Linear Neural Networks for Regression"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Alexander Liu
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-07-25 17:01" pubdate>
          2023年7月25日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          21k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          172 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">D2L-3-Linear Neural Networks for Regression</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：几秒前
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p> 本章我们将介绍神经网络的整个训练过程， 包括：定义简单的神经网络架构、数据处理、指定损失函数和如何训练模型。 为了更容易学习，我们将从经典算法————<em>线性</em>神经网络开始，介绍神经网络的基础知识。 经典统计学习技术中的线性回归和softmax回归可以视为线性神经网络， 这些知识将为本书其他部分中更复杂的技术奠定基础。</p>
<span id="more"></span>



<h1 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h1><ul>
<li><p><em>回归</em>（regression）是能为一个或多个自变量与因变量之间关系建模的一类方法。 在自然科学和社会科学领域，回归经常用来表示输入和输出之间的关系。</p>
</li>
<li><p>在机器学习领域中的大多数任务通常都与<em>预测</em>（prediction）有关。 当我们想预测一个数值时，就会涉及到回归问题。 常见的例子包括：预测价格（房屋、股票等）、预测住院时间（针对住院病人等）、 预测需求（零售销量等）。 <strong>但不是所有的<em>预测</em>都是回归问题。</strong></p>
</li>
</ul>
<h2 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h2><ul>
<li><em>线性回归</em>（linear regression）可以追溯到19世纪初， 它在回归的各种标准工具中最简单而且最流行。 线性回归基于几个简单的假设： 首先，假设自变量$\mathbf{x}$和因变量$y$之间的关系是线性的， 即$y$可以表示为$\mathbf{x}$中元素的加权和，这里通常允许包含观测值的一些噪声； 其次，我们假设任何噪声都比较正常，如噪声遵循正态分布。</li>
<li>通常，我们使用$n$来表示数据集中的样本数。 对索引为$i$的样本，其输入表示为$\mathbf{x}^{(i)} = [x_1^{(i)}, x_2^{(i)}]^\top$， 其对应的标签是$y^{(i)}$。</li>
</ul>
<h3 id="线性模型"><a href="#线性模型" class="headerlink" title="线性模型"></a>线性模型</h3><ul>
<li>线性假设是指目标（房屋价格）可以表示为特征（面积和房龄）的加权和，如：$\mathrm{price} = w_{\mathrm{area}} \cdot \mathrm{area} + w_{\mathrm{age}} \cdot \mathrm{age} + b.$。$w_{\mathrm{area}}$和$w_{\mathrm{age}}$是<em>权重</em>（weight），权重决定了每个特征对我们预测值的影响。$b$称为<em>偏置</em>（bias）、<em>偏移量</em>（offset）或<em>截距</em>（intercept）。偏置是指当所有特征都取值为0时，预测值应该为多少。 即使现实中不会有任何房子的面积是0或房龄正好是0年，我们仍然需要偏置项。 如果没有偏置项，我们模型的表达能力将受到限制。</li>
</ul>
<blockquote>
<p>输入特征的一个 <em>仿射变换</em>（affine transformation）。 仿射变换的特点是通过加权和对特征进行<em>线性变换</em>（linear transformation）， 并通过偏置项来进行<em>平移</em>（translation）。</p>
</blockquote>
<ul>
<li>给定一个数据集，我们的目标是寻找模型的权重$\mathbf{w}$和偏置$b$， 使得根据模型做出的预测大体符合数据里的真实价格。 输出的预测值由输入特征通过<em>线性模型</em>的仿射变换决定，仿射变换由所选权重和偏置确定。</li>
<li>而在机器学习领域，我们通常使用的是高维数据集，建模时采用线性代数表示法会比较方便。 当我们的输入包含$d$个特征时，我们将预测结果$\hat{y}$（通常使用“尖角”符号表示$y$的估计值）表示为：</li>
</ul>
<p>$$<br>\hat{y} = w_1  x_1 + … + w_d  x_d + b.<br>$$</p>
<blockquote>
<p>特征放入$\mathbf{x} \in \mathbb{R}^d$，权重放入$\mathbf{w} \in \mathbb{R}^d$，我们可以用点积形式来简洁地表达模型：</p>
</blockquote>
<p>$$<br>\hat{y} = \mathbf{w}^\top \mathbf{x} + b.<br>$$</p>
<ul>
<li>$\mathbf{x}$对应于单个数据样本的特征。 用符号表示的矩阵$\mathbf{X} \in \mathbb{R}^{n \times d}$可以很方便地引用我们整个数据集的$n$个样本。 $\mathbf{X}$的每一行是一个样本，每一列是一种特征。对于特征集合$\mathbf{X}$，预测值$\hat{\mathbf{y}} \in \mathbb{R}^n$可以通过矩阵-向量乘法表示为：</li>
</ul>
<p>$$<br>{\hat{\mathbf{y}}} = \mathbf{X} \mathbf{w} + b<br>$$</p>
<blockquote>
<p>这个过程中的求和将使用广播机制 （广播机制在 <a target="_blank" rel="noopener" href="https://zh.d2l.ai/chapter_preliminaries/ndarray.html#subsec-broadcasting">2.1.3节</a>中有详细介绍）。 给定训练数据特征$\mathbf{X}$和对应的已知标签$\mathbf{y}$， 线性回归的目标是找到一组权重向量$w$和偏置$b$： 当给定从$\mathbf{X}$的同分布中取样的新样本特征时， 这组权重向量和偏置能够使得新样本预测标签的误差尽可能小。</p>
</blockquote>
<ul>
<li><p>虽然我们相信给定$\mathbf{x}$预测$y$的最佳模型会是线性的， 但我们很难找到一个有$n$个样本的真实数据集，其中对于所有的$1 \leq i \leq n$，$y^{(i)}$完全等于$\mathbf{w}^\top \mathbf{x}^{(i)}+b$。 无论我们使用什么手段来观察特征$\mathbf{X}$和标签$y$， 都可能会出现少量的观测误差。 因此，即使确信特征与标签的潜在关系是线性的， 我们也会加入一个噪声项来考虑观测误差带来的影响。</p>
</li>
<li><p>在开始寻找最好的<em>模型参数</em>（model parameters）$\mathbf{w}$和$b$之前， 我们还需要两个东西： （1）一种模型质量的度量方式； （2）一种能够更新模型以提高模型预测质量的方法。</p>
</li>
</ul>
<h3 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h3><ul>
<li>我们需要确定一个拟合程度的度量。 <em>损失函数</em>（loss function）能够量化目标的<em>实际</em>值与<em>预测</em>值之间的差距。 通常我们会选择非负数作为损失，且数值越小表示损失越小，完美预测时的损失为0。 回归问题中最常用的损失函数是平方误差函数。 当样本$i$的预测值为$\hat{y}^{(i)}$，其相应的真实标签为$y^{(i)}$时， 平方误差可以定义为以下公式：</li>
</ul>
<p>$$<br>l^{(i)}(\mathbf{w}, b) = \frac{1}{2} \left(\hat{y}^{(i)} - y^{(i)}\right)^2.<br>$$</p>
<blockquote>
<p>常数$\frac{1}{2}$不会带来本质的差别，但这样在形式上稍微简单一些 （因为当我们对损失函数求导后常数系数为1）。 由于训练数据集并不受我们控制，所以经验误差只是关于模型参数的函数。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202307261014650.svg" srcset="/img/loading.gif" lazyload alt="../_images/fit-linreg.svg"></p>
<ul>
<li>由于平方误差函数中的二次方项， 估计值$\hat{y}^{(i)}$和观测值$y^{(i)}$之间较大的差异将导致更大的损失。 为了度量模型在整个数据集上的质量，我们需计算在训练集$n$个样本上的损失均值（也等价于求和）。</li>
</ul>
<p>$$<br>L(\mathbf{w}, b) =\frac{1}{n}\sum_{i=1}^n l^{(i)}(\mathbf{w}, b) =\frac{1}{n} \sum_{i=1}^n \frac{1}{2}\left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right)^2.<br>$$</p>
<blockquote>
<p>在训练模型时，我们希望寻找一组参数$(\mathbf{w}^*, b^*)$， 这组参数能最小化在所有训练样本上的总损失。如下式：</p>
</blockquote>
<p>$$<br>\mathbf{w}^*, b^* = \operatorname*{argmin}_{\mathbf{w}, b}\  L(\mathbf{w}, b).<br>$$</p>
<h3 id="解析解"><a href="#解析解" class="headerlink" title="解析解"></a>解析解</h3><ul>
<li>线性回归刚好是一个很简单的优化问题。 与我们将在本书中所讲到的其他大部分模型不同，线性回归的解可以用一个公式简单地表达出来， 这类解叫作解析解（analytical solution）。 首先，我们将偏置$b$合并到参数$\mathbf{w}$中，合并方法是在包含所有参数的矩阵中附加一列。 我们的预测问题是最小化$|\mathbf{y} - \mathbf{X}\mathbf{w}|^2$。 这在损失平面上只有一个临界点，这个临界点对应于整个区域的损失极小点。 将损失关于$\mathbf{w}$的导数设为0，得到解析解：</li>
</ul>
<p>$$<br>\mathbf{w}^* = (\mathbf X^\top \mathbf X)^{-1}\mathbf X^\top \mathbf{y}.<br>$$</p>
<blockquote>
<p><strong>像线性回归这样的简单问题存在解析解，但并不是所有的问题都存在解析解。</strong> 解析解可以进行很好的数学分析，但解析解对问题的限制很严格，导致它无法广泛应用在深度学习里。</p>
</blockquote>
<h3 id="随机梯度下降"><a href="#随机梯度下降" class="headerlink" title="随机梯度下降"></a>随机梯度下降</h3><ul>
<li>我们用到一种名为<em>梯度下降</em>（gradient descent）的方法， 这种方法几乎可以优化所有深度学习模型。 它通过不断地在损失函数递减的方向上更新参数来降低误差。</li>
<li>梯度下降最简单的用法是计算损失函数（数据集中所有样本的损失均值） 关于模型参数的导数（在这里也可以称为梯度）。 但实际中的执行可能会非常慢：因为在每一次更新参数之前，我们必须遍历整个数据集。 因此，我们通常会在每次需要计算更新的时候随机抽取一小批样本， 这种变体叫做<em>小批量随机梯度下降</em>（minibatch stochastic gradient descent）。</li>
<li>在每次迭代中，我们首先随机抽样一个小批量$\mathcal{B}$， 它是由固定数量的训练样本组成的。 然后，我们计算小批量的平均损失关于模型参数的导数（也可以称为梯度）。 最后，我们将梯度乘以一个预先确定的正数$\eta$，并从当前参数的值中减掉。我们用下面的数学公式来表示这一更新过程（$\partial$表示偏导数）：</li>
</ul>
<p>$$<br>(\mathbf{w},b) \leftarrow (\mathbf{w},b) - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \partial_{(\mathbf{w},b)} l^{(i)}(\mathbf{w},b).<br>$$</p>
<ul>
<li>总结一下，算法的步骤如下： <ul>
<li>（1）初始化模型参数的值，如随机初始化； </li>
<li>（2）从数据集中随机抽取小批量样本且在负梯度的方向上更新参数，并不断迭代这一步骤。</li>
</ul>
</li>
<li>对于平方损失和仿射变换，我们可以明确地写成如下形式:</li>
</ul>
<p>$$<br>\begin{split}\begin{aligned} \mathbf{w} &amp;\leftarrow \mathbf{w} -   \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \partial_{\mathbf{w}} l^{(i)}(\mathbf{w}, b) = \mathbf{w} - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \mathbf{x}^{(i)} \left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right),\ b &amp;\leftarrow b -  \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \partial_b l^{(i)}(\mathbf{w}, b)  = b - \frac{\eta}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} \left(\mathbf{w}^\top \mathbf{x}^{(i)} + b - y^{(i)}\right). \end{aligned}\end{split}<br>$$</p>
<blockquote>
<p>$\mathbf{w}$和$x$都是向量，更优雅的向量表示法比系数表示法（如$w_1, w_2, \ldots, w_d$）更具可读性。 $|\mathcal{B}|$表示每个小批量中的样本数，这也称为<em>批量大小</em>（batch size）。 $\eta$表示<em>学习率</em>（learning rate）。 批量大小和学习率的值通常是手动预先指定，而不是通过模型训练得到的。 这些可以调整但不在训练过程中更新的参数称为<em>超参数</em>（hyperparameter）。 <em>调参</em>（hyperparameter tuning）是选择超参数的过程。 超参数通常是我们根据训练迭代结果来调整的， 而训练迭代结果是在独立的<em>验证数据集</em>（validation dataset）上评估得到的。</p>
</blockquote>
<ul>
<li><p>在训练了预先确定的若干迭代次数后（或者直到满足某些其他停止条件后）， 我们记录下模型参数的估计值，表示为$\hat{\mathbf{w}}, \hat{b}$。 但是，即使我们的函数确实是线性的且无噪声，这些估计值也不会使损失函数真正地达到最小值。 因为算法会使得损失向最小值缓慢收敛，但却不能在有限的步数内非常精确地达到最小值。</p>
</li>
<li><p>线性回归恰好是一个在整个域中只有一个最小值的学习问题。 但是对像深度神经网络这样复杂的模型来说，损失平面上通常包含多个最小值。 深度学习实践者很少会去花费大力气寻找这样一组参数，使得在<em>训练集</em>上的损失达到最小。 事实上，更难做到的是找到一组参数，这组参数能够在我们从未见过的数据上实现较低的损失， 这一挑战被称为<em>泛化</em>（generalization）。</p>
</li>
</ul>
<h3 id="用模型预测"><a href="#用模型预测" class="headerlink" title="用模型预测"></a>用模型预测</h3><ul>
<li>“已学习”的线性回归模型$\hat{\mathbf{w}}^\top \mathbf{x} + \hat{b}$，就可以通过新的$\mathbf{x}$，来估计一个$y$。给定特征估计目标的过程通常称为<em>预测</em>（prediction）或<em>推断</em>（inference）。</li>
<li>本书将尝试坚持使用<em>预测</em>这个词。 虽然<em>推断</em>这个词已经成为深度学习的标准术语，但其实<em>推断</em>这个词有些用词不当。 在统计学中，<em>推断</em>更多地表示基于数据集估计参数。</li>
</ul>
<h2 id="矢量化加速"><a href="#矢量化加速" class="headerlink" title="矢量化加速"></a>矢量化加速</h2><ul>
<li>在训练我们的模型时，我们经常希望能够同时处理整个小批量的样本。 为了实现这一点，需要我们对计算进行矢量化， 从而利用线性代数库，而不是在Python中编写开销高昂的for循环。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">%matplotlib inline<br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> d2l <span class="hljs-keyword">import</span> torch <span class="hljs-keyword">as</span> d2l<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>线性代数库与for循环性能对比：</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># test case</span><br>n = <span class="hljs-number">10000</span><br>a = torch.ones([n])<br>b = torch.ones([n])<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Timer</span>:  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""记录多次运行时间"""</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        self.times = []<br>        self.start()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">"""启动计时器"""</span><br>        self.tik = time.time()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">stop</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">"""停止计时器并将时间记录在列表中"""</span><br>        self.times.append(time.time() - self.tik)<br>        <span class="hljs-keyword">return</span> self.times[-<span class="hljs-number">1</span>]<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">avg</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">"""返回平均时间"""</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(self.times) / <span class="hljs-built_in">len</span>(self.times)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">"""返回时间总和"""</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">sum</span>(self.times)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cumsum</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">"""返回累计时间"""</span><br>        <span class="hljs-keyword">return</span> np.array(self.times).cumsum().tolist()<br><br><span class="hljs-comment"># for循环</span><br>c = torch.zeros(n)<br>timer = Timer()<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(n):<br>    c[i] = a[i] + b[i]<br><span class="hljs-string">f'<span class="hljs-subst">{timer.stop():<span class="hljs-number">.5</span>f}</span> sec'</span><br><span class="hljs-comment"># result</span><br><span class="hljs-string">'0.09661 sec'</span><br><br><br><span class="hljs-comment"># 线性代数库</span><br>timer.start()<br>d = a + b<br><span class="hljs-string">f'<span class="hljs-subst">{timer.stop():<span class="hljs-number">.5</span>f}</span> sec'</span><br><span class="hljs-comment"># result</span><br><span class="hljs-string">'0.00021 sec'</span><br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>矢量化代码通常会带来数量级的加速。 另外，我们将更多的数学运算放到库中，而无须自己编写那么多的计算，从而减少了出错的可能性。</p>
</blockquote>
<h2 id="正态分布与平方损失"><a href="#正态分布与平方损失" class="headerlink" title="正态分布与平方损失"></a>正态分布与平方损失</h2><ul>
<li>正态分布和线性回归之间的关系很密切。 正态分布（normal distribution），也称为<em>高斯分布</em>（Gaussian distribution）， 最早由德国数学家高斯（Gauss）应用于天文学研究。 简单的说，若随机变量$x$具有均值$\mu$和方差$\sigma^2$（标准差$\sigma$），其正态分布概率密度函数如下：</li>
</ul>
<p>$$<br>p(x) = \frac{1}{\sqrt{2 \pi \sigma^2}} \exp\left(-\frac{1}{2 \sigma^2} (x - \mu)^2\right).<br>$$</p>
<ul>
<li>可视化正态分布：</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">normal</span>(<span class="hljs-params">x, mu, sigma</span>):<br>    p = <span class="hljs-number">1</span> / math.sqrt(<span class="hljs-number">2</span> * math.pi * sigma**<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">return</span> p * np.exp(-<span class="hljs-number">0.5</span> / sigma**<span class="hljs-number">2</span> * (x - mu)**<span class="hljs-number">2</span>)<br>  <br><span class="hljs-comment"># 再次使用numpy进行可视化</span><br>x = np.arange(-<span class="hljs-number">7</span>, <span class="hljs-number">7</span>, <span class="hljs-number">0.01</span>)<br><br><span class="hljs-comment"># 均值和标准差对</span><br>params = [(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>), (<span class="hljs-number">0</span>, <span class="hljs-number">2</span>), (<span class="hljs-number">3</span>, <span class="hljs-number">1</span>)]<br>d2l.plot(x, [normal(x, mu, sigma) <span class="hljs-keyword">for</span> mu, sigma <span class="hljs-keyword">in</span> params], xlabel=<span class="hljs-string">'x'</span>,<br>         ylabel=<span class="hljs-string">'p(x)'</span>, figsize=(<span class="hljs-number">4.5</span>, <span class="hljs-number">2.5</span>),<br>         legend=[<span class="hljs-string">f'mean <span class="hljs-subst">{mu}</span>, std <span class="hljs-subst">{sigma}</span>'</span> <span class="hljs-keyword">for</span> mu, sigma <span class="hljs-keyword">in</span> params])<br></code></pre></td></tr></tbody></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202307261041887.svg" srcset="/img/loading.gif" lazyload alt="../_images/output_linear-regression_216540_70_0.svg"></p>
<ul>
<li>就像我们所看到的，改变均值会产生沿$x$轴的偏移，增加方差将会分散分布、降低其峰值。均方误差损失函数（简称均方损失）可以用于线性回归的一个原因是： 我们假设了观测中包含噪声，其中噪声服从正态分布。 噪声正态分布如下式:</li>
</ul>
<p>$$<br>y = \mathbf{w}^\top \mathbf{x} + b + \epsilon,<br>$$</p>
<blockquote>
<p>其中，$\epsilon \sim \mathcal{N}(0, \sigma^2)$。因此，我们现在可以写出通过给定的$\mathbf{x}$观测到特定$y$的<em>似然</em>（likelihood）：</p>
</blockquote>
<p>$$<br>P(y \mid \mathbf{x}) = \frac{1}{\sqrt{2 \pi \sigma^2}} \exp\left(-\frac{1}{2 \sigma^2} (y - \mathbf{w}^\top \mathbf{x} - b)^2\right).<br>$$</p>
<blockquote>
<p>现在，根据极大似然估计法，最优值是使整个数据集的<em>似然</em>最大的值：</p>
</blockquote>
<p>$$<br>P(\mathbf y \mid \mathbf X) = \prod_{i=1}^{n} p(y^{(i)}|\mathbf{x}^{(i)}).<br>$$</p>
<blockquote>
<p>根据极大似然估计法选择的估计量称为<em>极大似然估计量</em>。 虽然使许多指数函数的乘积最大化看起来很困难， 但是我们可以在不改变目标的前提下，通过最大化似然对数来简化。 由于历史原因，优化通常是说最小化而不是最大化。 我们可以改为<em>最小化负对数似然</em>$-\log P(\mathbf y \mid \mathbf X)$。 由此可以得到的数学公式是：</p>
</blockquote>
<p>$$<br>-\log P(\mathbf y \mid \mathbf X) = \sum_{i=1}^n \frac{1}{2} \log(2 \pi \sigma^2) + \frac{1}{2 \sigma^2} \left(y^{(i)} - \mathbf{w}^\top \mathbf{x}^{(i)} - b\right)^2.<br>$$</p>
<blockquote>
<p>现在我们只需要假设$\sigma$是某个固定常数就可以忽略第一项， 因为第一项不依赖于$\mathbf{w}$和$b$。 现在第二项除了常数$\frac{1}{\sigma^2}$外，其余部分和前面介绍的均方误差是一样的。 幸运的是，上面式子的解并不依赖于$\sigma$。 因此，在高斯噪声的假设下，最小化均方误差等价于对线性模型的极大似然估计。</p>
</blockquote>
<h2 id="从线性回归到深度网络"><a href="#从线性回归到深度网络" class="headerlink" title="从线性回归到深度网络"></a>从线性回归到深度网络</h2><ul>
<li>尽管神经网络涵盖了更多更为丰富的模型，我们依然可以用描述神经网络的方式来描述线性模型， 从而把线性模型看作一个神经网络。 首先，我们用“层”符号来重写这个模型。</li>
</ul>
<h3 id="神经网络图"><a href="#神经网络图" class="headerlink" title="神经网络图"></a>神经网络图</h3><p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202307261046793.svg" srcset="/img/loading.gif" lazyload alt="../_images/singleneuron.svg"></p>
<blockquote>
<p>输入为$x_1, \ldots, x_d$， 因此输入层中的<em>输入数</em>（或称为<em>特征维度</em>，feature dimensionality）为$d$。 网络的输出为$o_1$，因此输出层中的<em>输出数</em>是1。 需要注意的是，输入值都是已经给定的，并且只有一个<em>计算</em>神经元。 由于模型重点在发生计算的地方，所以通常我们在计算层数时不考虑输入层。 也就是说，图中神经网络的<em>层数</em>为1。 我们可以将线性回归模型视为仅由单个人工神经元组成的神经网络，或称为单层神经网络。</p>
</blockquote>
<ul>
<li>对于线性回归，每个输入都与每个输出（在本例中只有一个输出）相连， 我们将这种变换称为<em>全连接层</em>（fully-connected layer）或称为<em>稠密层</em>（dense layer）。</li>
</ul>
<h3 id="生物学"><a href="#生物学" class="headerlink" title="生物学"></a>生物学</h3><p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202307261049045.svg" srcset="/img/loading.gif" lazyload alt="../_images/neuron.svg"></p>
<blockquote>
<p>树突中接收到来自其他神经元（或视网膜等环境传感器）的信息$x_i$。 该信息通过<em>突触权重</em>$w_i$来加权，以确定输入的影响（即，通过$x_i w_i$相乘来激活或抑制）。 来自多个源的加权输入以加权和$y = \sum_i x_i w_i + b$的形式汇聚在细胞核中， 然后将这些信息发送到轴突$y$中进一步处理，通常会通过$\sigma(y)$进行一些非线性处理。 之后，它要么到达目的地（例如肌肉），要么通过树突进入另一个神经元。</p>
</blockquote>
<ul>
<li>当今大多数深度学习的研究几乎没有直接从神经科学中获得灵感。在深度学习中的灵感同样或更多地来自数学、统计学和计算机科学。</li>
</ul>
<p><strong>Tips: 具体的Linear Regression推导，可以看看下面那一篇知乎的reference昂！！！</strong></p>
<h1 id="线性回归的从零开始实现"><a href="#线性回归的从零开始实现" class="headerlink" title="线性回归的从零开始实现"></a>线性回归的从零开始实现</h1><ul>
<li>代码实现：</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">%matplotlib inline<br><span class="hljs-keyword">import</span> random<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> d2l <span class="hljs-keyword">import</span> torch <span class="hljs-keyword">as</span> d2l<br></code></pre></td></tr></tbody></table></figure>



<h2 id="生成数据集"><a href="#生成数据集" class="headerlink" title="生成数据集"></a>生成数据集</h2><blockquote>
<p>我们将根据带有噪声的线性模型构造一个人造数据集。 我们的任务是使用这个有限样本的数据集来恢复这个模型的参数。 我们将使用低维数据，这样可以很容易地将其可视化。</p>
</blockquote>
<ul>
<li>我们生成一个包含1000个样本的数据集， 每个样本包含从标准正态分布中采样的2个特征。 我们的合成数据集是一个矩阵$\mathbf{X}\in \mathbb{R}^{1000 \times 2}$，我们使用线性模型参数$\mathbf{w} = [2, -3.4]^\top$、$b = 4.2$和噪声项$\epsilon$生成数据集及其标签：</li>
</ul>
<p>$$<br>\mathbf{y}= \mathbf{X} \mathbf{w} + b + \mathbf\epsilon.<br>$$</p>
<blockquote>
<p>$\epsilon$可以视为模型预测和标签时的潜在观测误差。 在这里我们认为标准假设成立，即$\epsilon$服从均值为0的正态分布。 为了简化问题，我们将标准差设为0.01。 下面的代码生成合成数据集。</p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">synthetic_data</span>(<span class="hljs-params">w, b, num_examples</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""生成y=Xw+b+噪声"""</span><br>    X = torch.normal(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, (num_examples, <span class="hljs-built_in">len</span>(w)))<br>    y = torch.matmul(X, w) + b<br>    y += torch.normal(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>, y.shape)<br>    <span class="hljs-keyword">return</span> X, y.reshape((-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br><br>true_w = torch.tensor([<span class="hljs-number">2</span>, -<span class="hljs-number">3.4</span>])<br>true_b = <span class="hljs-number">4.2</span><br>features, labels = synthetic_data(true_w, true_b, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>注意，<code>features</code>中的每一行都包含一个二维数据样本， <code>labels</code>中的每一行都包含一维标签值（一个标量）。</p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">'features:'</span>, features[<span class="hljs-number">0</span>],<span class="hljs-string">'\nlabel:'</span>, labels[<span class="hljs-number">0</span>])<br><br><span class="hljs-comment"># result</span><br>features: tensor([-<span class="hljs-number">0.3679</span>, -<span class="hljs-number">1.8471</span>])<br>label: tensor([<span class="hljs-number">9.7361</span>])<br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>通过生成第二个特征<code>features[:, 1]</code>和<code>labels</code>的散点图， 可以直观观察到两者之间的线性关系。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">d2l.set_figsize()<br>d2l.plt.scatter(features[:, <span class="hljs-number">1</span>].detach().numpy(), labels.detach().numpy(), <span class="hljs-number">1</span>);<br></code></pre></td></tr></tbody></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202307271011392.svg" srcset="/img/loading.gif" lazyload alt="../_images/output_linear-regression-scratch_58de05_51_0.svg"></p>
<h2 id="读取数据集"><a href="#读取数据集" class="headerlink" title="读取数据集"></a>读取数据集</h2><ul>
<li>训练模型时要对数据集进行遍历，每次抽取一小批量样本，并使用它们来更新我们的模型。 有必要定义一个函数， 该函数能打乱数据集中的样本并以小批量方式获取数据。我们定义一个<code>data_iter</code>函数， 该函数接收批量大小、特征矩阵和标签向量作为输入，生成大小为<code>batch_size</code>的小批量。 每个小批量包含一组特征和标签。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">data_iter</span>(<span class="hljs-params">batch_size, features, labels</span>):<br>    num_examples = <span class="hljs-built_in">len</span>(features)<br>    indices = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(num_examples))<br>    <span class="hljs-comment"># 这些样本是随机读取的，没有特定的顺序</span><br>    random.shuffle(indices)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, num_examples, batch_size):<br>        batch_indices = torch.tensor(<br>            indices[i: <span class="hljs-built_in">min</span>(i + batch_size, num_examples)])<br>        <span class="hljs-keyword">yield</span> features[batch_indices], labels[batch_indices]<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>通常，我们利用GPU并行运算的优势，处理合理大小的“小批量”。 每个样本都可以并行地进行模型计算，且每个样本损失函数的梯度也可以被并行计算。 GPU可以在处理几百个样本时，所花费的时间不比处理一个样本时多太多。</p>
</blockquote>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python">batch_size = <span class="hljs-number">10</span><br><br><span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> data_iter(batch_size, features, labels):<br>    <span class="hljs-built_in">print</span>(X, <span class="hljs-string">'\n'</span>, y)<br>    <span class="hljs-keyword">break</span><br><br><span class="hljs-comment"># result</span><br>tensor([[ <span class="hljs-number">0.1649</span>, -<span class="hljs-number">1.1651</span>],<br>        [-<span class="hljs-number">2.0755</span>, -<span class="hljs-number">1.0165</span>],<br>        [-<span class="hljs-number">0.2189</span>,  <span class="hljs-number">0.7607</span>],<br>        [ <span class="hljs-number">0.6833</span>,  <span class="hljs-number">0.3537</span>],<br>        [-<span class="hljs-number">0.2736</span>, -<span class="hljs-number">2.0485</span>],<br>        [-<span class="hljs-number">0.3026</span>,  <span class="hljs-number">0.9771</span>],<br>        [ <span class="hljs-number">2.4795</span>,  <span class="hljs-number">0.6881</span>],<br>        [-<span class="hljs-number">0.2045</span>, -<span class="hljs-number">0.8509</span>],<br>        [-<span class="hljs-number">0.1353</span>,  <span class="hljs-number">0.5476</span>],<br>        [ <span class="hljs-number">0.3371</span>, -<span class="hljs-number">0.0479</span>]])<br> tensor([[ <span class="hljs-number">8.4901</span>],<br>        [ <span class="hljs-number">3.5015</span>],<br>        [ <span class="hljs-number">1.1779</span>],<br>        [ <span class="hljs-number">4.3752</span>],<br>        [<span class="hljs-number">10.6125</span>],<br>        [ <span class="hljs-number">0.2845</span>],<br>        [ <span class="hljs-number">6.8094</span>],<br>        [ <span class="hljs-number">6.6776</span>],<br>        [ <span class="hljs-number">2.0598</span>],<br>        [ <span class="hljs-number">5.0189</span>]])<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>当我们运行迭代时，我们会连续地获得不同的小批量，直至遍历完整个数据集。 上面实现的迭代对教学来说很好，但它的执行效率很低，可能会在实际问题上陷入麻烦。 例如，它要求我们将所有数据加载到内存中，并执行大量的随机内存访问。 在深度学习框架中实现的内置迭代器效率要高得多， 它可以处理存储在文件中的数据和数据流提供的数据。</p>
<p>Tips: 深度学习框架很好用！！！性能很好捏！！！</p>
</blockquote>
<h2 id="初始化模型参数"><a href="#初始化模型参数" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h2><ul>
<li>我们通过从均值为0、标准差为0.01的正态分布中采样随机数来初始化权重， 并将偏置初始化为0。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">w = torch.normal(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>, size=(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>), requires_grad=<span class="hljs-literal">True</span>)<br>b = torch.zeros(<span class="hljs-number">1</span>, requires_grad=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>在初始化参数之后，我们的任务是更新这些参数，直到这些参数足够拟合我们的数据。 每次更新都需要计算损失函数关于模型参数的梯度。 有了这个梯度，我们就可以向减小损失的方向更新每个参数。 因为手动计算梯度很枯燥而且容易出错，所以没有人会手动计算梯度。 </p>
</blockquote>
<h2 id="定义模型"><a href="#定义模型" class="headerlink" title="定义模型"></a>定义模型</h2><ul>
<li>我们必须定义模型，将模型的输入和参数同模型的输出关联起来。 回想一下，要计算线性模型的输出， 我们只需计算输入特征$\mathbf{X}$和模型权重$\mathbf{w}$的矩阵-向量乘法后加上偏置$b$。 注意，上面的$\mathbf{Xw}$是一个向量，而$b$是一个标量。 回想一下 <a target="_blank" rel="noopener" href="https://zh-v2.d2l.ai/chapter_preliminaries/ndarray.html#subsec-broadcasting">2.1.3节</a>中描述的广播机制： 当我们用一个向量加一个标量时，标量会被加到向量的每个分量上。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">linreg</span>(<span class="hljs-params">X, w, b</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""线性回归模型"""</span><br>    <span class="hljs-keyword">return</span> torch.matmul(X, w) + b<br></code></pre></td></tr></tbody></table></figure>



<h2 id="定义损失函数"><a href="#定义损失函数" class="headerlink" title="定义损失函数"></a>定义损失函数</h2><ul>
<li>平方损失函数，我们需要将真实值<code>y</code>的形状转换为和预测值<code>y_hat</code>的形状相同。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">squared_loss</span>(<span class="hljs-params">y_hat, y</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""均方损失"""</span><br>    <span class="hljs-keyword">return</span> (y_hat - y.reshape(y_hat.shape)) ** <span class="hljs-number">2</span> / <span class="hljs-number">2</span><br></code></pre></td></tr></tbody></table></figure>



<h2 id="定义优化算法"><a href="#定义优化算法" class="headerlink" title="定义优化算法"></a>定义优化算法</h2><ul>
<li>线性回归有解析解，其他模型不一定有， 这里我们介绍小批量随机梯度下降。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sgd</span>(<span class="hljs-params">params, lr, batch_size</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""小批量随机梯度下降"""</span><br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        <span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> params:<br>            param -= lr * param.grad / batch_size<br>            param.grad.zero_()<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>在每一步中，使用从数据集中随机抽取的一个小批量，然后根据参数计算损失的梯度。 接下来，朝着减少损失的方向更新我们的参数。 下面的函数实现小批量随机梯度下降更新。 该函数接受模型参数集合、学习速率和批量大小作为输入。每 一步更新的大小由学习速率<code>lr</code>决定。 因为我们计算的损失是一个批量样本的总和，所以我们用批量大小（<code>batch_size</code>） 来规范化步长，这样步长大小就不会取决于我们对批量大小的选择。</p>
</blockquote>
<h2 id="训练"><a href="#训练" class="headerlink" title="训练"></a>训练</h2><blockquote>
<p>在每次迭代中，我们读取一小批量训练样本，并通过我们的模型来获得一组预测。 计算完损失后，我们开始反向传播，存储每个参数的梯度。 最后，我们调用优化算法<code>sgd</code>来更新模型参数。</p>
</blockquote>
<ul>
<li><p>我们将执行以下循环：</p>
<ul>
<li>初始化参数</li>
<li>重复以下训练，直到完成<ul>
<li>计算梯度$\mathbf{g} \leftarrow \partial_{(\mathbf{w},b)} \frac{1}{|\mathcal{B}|} \sum_{i \in \mathcal{B}} l(\mathbf{x}^{(i)}, y^{(i)}, \mathbf{w}, b)$</li>
<li>更新参数$(\mathbf{w}, b) \leftarrow (\mathbf{w}, b) - \eta \mathbf{g}$</li>
</ul>
</li>
</ul>
</li>
<li><p>在每个<em>迭代周期</em>（epoch）中，我们使用<code>data_iter</code>函数遍历整个数据集， 并将训练数据集中所有样本都使用一次（假设样本数能够被批量大小整除）。 这里的迭代周期个数<code>num_epochs</code>和学习率<code>lr</code>都是超参数，分别设为3和0.03。 设置超参数很棘手，需要通过反复试验进行调整，我们现在忽略这些细节。</p>
</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">lr = <span class="hljs-number">0.03</span><br>num_epochs = <span class="hljs-number">3</span><br>net = linreg<br>loss = squared_loss<br><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):<br>    <span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> data_iter(batch_size, features, labels):<br>        l = loss(net(X, w, b), y)  <span class="hljs-comment"># X和y的小批量损失</span><br>        <span class="hljs-comment"># 因为l形状是(batch_size,1)，而不是一个标量。l中的所有元素被加到一起，</span><br>        <span class="hljs-comment"># 并以此计算关于[w,b]的梯度</span><br>        l.<span class="hljs-built_in">sum</span>().backward()<br>        sgd([w, b], lr, batch_size)  <span class="hljs-comment"># 使用参数的梯度更新参数</span><br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        train_l = loss(net(features, w, b), labels)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f'epoch <span class="hljs-subst">{epoch + <span class="hljs-number">1</span>}</span>, loss <span class="hljs-subst">{<span class="hljs-built_in">float</span>(train_l.mean()):f}</span>'</span>)<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>还是一样的，先通过构造损失函数l，然后通过l来执行backward()函数，进行更新。</p>
</blockquote>
<ul>
<li>因为我们使用的是自己合成的数据集，所以我们知道真正的参数是什么。 因此，我们可以通过比较真实参数和通过训练学到的参数来评估训练的成功程度。 事实上，真实参数和通过训练学到的参数确实非常接近。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">f'w的估计误差: <span class="hljs-subst">{true_w - w.reshape(true_w.shape)}</span>'</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f'b的估计误差: <span class="hljs-subst">{true_b - b}</span>'</span>)<br><br><span class="hljs-comment"># result</span><br>w的估计误差: tensor([ <span class="hljs-number">0.0003</span>, -<span class="hljs-number">0.0002</span>], grad_fn=&lt;SubBackward0&gt;)<br>b的估计误差: tensor([<span class="hljs-number">0.0010</span>], grad_fn=&lt;RsubBackward1&gt;)<br></code></pre></td></tr></tbody></table></figure>









<h1 id="线性回归的简洁实现"><a href="#线性回归的简洁实现" class="headerlink" title="线性回归的简洁实现"></a>线性回归的简洁实现</h1><h2 id="数据集生成"><a href="#数据集生成" class="headerlink" title="数据集生成"></a>数据集生成</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch.utils <span class="hljs-keyword">import</span> data<br><span class="hljs-keyword">from</span> d2l <span class="hljs-keyword">import</span> torch <span class="hljs-keyword">as</span> d2l<br><br>true_w = torch.tensor([<span class="hljs-number">2</span>, -<span class="hljs-number">3.4</span>])<br>true_b = <span class="hljs-number">4.2</span><br>features, labels = d2l.synthetic_data(true_w, true_b, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>和上面的一致捏</p>
</blockquote>
<h2 id="读取数据集-1"><a href="#读取数据集-1" class="headerlink" title="读取数据集"></a>读取数据集</h2><ul>
<li>我们可以调用框架中现有的API来读取数据。 我们将<code>features</code>和<code>labels</code>作为API的参数传递，并通过数据迭代器指定<code>batch_size</code>。 此外，布尔值<code>is_train</code>表示是否希望数据迭代器对象在每个迭代周期内打乱数据。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">load_array</span>(<span class="hljs-params">data_arrays, batch_size, is_train=<span class="hljs-literal">True</span></span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""构造一个PyTorch数据迭代器"""</span><br>    dataset = data.TensorDataset(*data_arrays)<br>    <span class="hljs-keyword">return</span> data.DataLoader(dataset, batch_size, shuffle=is_train)<br><br>batch_size = <span class="hljs-number">10</span><br>data_iter = load_array((features, labels), batch_size)<br></code></pre></td></tr></tbody></table></figure>



<h2 id="定义模型-1"><a href="#定义模型-1" class="headerlink" title="定义模型"></a>定义模型</h2><ul>
<li>对于标准深度学习模型，我们可以使用框架的预定义好的层。这使我们只需关注使用哪些层来构造模型，而不必关注层的实现细节。 我们首先定义一个模型变量<code>net</code>，它是一个<code>Sequential</code>类的实例。 <code>Sequential</code>类将多个层串联在一起。 当给定输入数据时，<code>Sequential</code>实例将数据传入到第一层， 然后将第一层的输出作为第二层的输入，以此类推。 在下面的例子中，我们的模型只包含一个层，因此实际上不需要<code>Sequential</code>。 但是由于以后几乎所有的模型都是多层的，在这里使用<code>Sequential</code>。</li>
</ul>
<blockquote>
<p>示例图</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202307272154971.svg" srcset="/img/loading.gif" lazyload alt="../_images/singleneuron.svg"></p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># nn是神经网络的缩写</span><br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><br>net = nn.Sequential(nn.Linear(<span class="hljs-number">2</span>, <span class="hljs-number">1</span>))<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>在PyTorch中，全连接层在<code>Linear</code>类中定义。 值得注意的是，我们将两个参数传递到<code>nn.Linear</code>中。 第一个指定输入特征形状，即2，第二个指定输出特征形状，输出特征形状为单个标量，因此为1。</p>
</blockquote>
<h2 id="初始化模型参数-1"><a href="#初始化模型参数-1" class="headerlink" title="初始化模型参数"></a>初始化模型参数</h2><ul>
<li>在使用<code>net</code>之前，我们需要初始化模型参数。 如在线性回归模型中的权重和偏置。 深度学习框架通常有预定义的方法来初始化参数。 在这里，我们指定每个权重参数应该从均值为0、标准差为0.01的正态分布中随机采样， 偏置参数将初始化为零。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">net[<span class="hljs-number">0</span>].weight.data.normal_(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>)<br>net[<span class="hljs-number">0</span>].bias.data.fill_(<span class="hljs-number">0</span>)<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>正如我们在构造<code>nn.Linear</code>时指定输入和输出尺寸一样， 现在我们能直接访问参数以设定它们的初始值。 我们通过<code>net[0]</code>选择网络中的第一个图层， 然后使用<code>weight.data</code>和<code>bias.data</code>方法访问参数。 我们还可以使用替换方法<code>normal_</code>和<code>fill_</code>来重写参数值。</p>
</blockquote>
<h2 id="定义损失函数-1"><a href="#定义损失函数-1" class="headerlink" title="定义损失函数"></a>定义损失函数</h2><ul>
<li>计算均方误差使用的是<code>MSELoss</code>类，也称为平方$L_2$范数。 默认情况下，它返回所有样本损失的平均值。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">loss = nn.MSELoss()<br></code></pre></td></tr></tbody></table></figure>



<h2 id="定义优化算法-1"><a href="#定义优化算法-1" class="headerlink" title="定义优化算法"></a>定义优化算法</h2><ul>
<li>小批量随机梯度下降算法是一种优化神经网络的标准工具， PyTorch在<code>optim</code>模块中实现了该算法的许多变种。 当我们实例化一个<code>SGD</code>实例时，我们要指定优化的参数 （可通过<code>net.parameters()</code>从我们的模型中获得）以及优化算法所需的超参数字典。 小批量随机梯度下降只需要设置<code>lr</code>值，这里设置为0.03。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">trainer = torch.optim.SGD(net.parameters(), lr=<span class="hljs-number">0.03</span>)<br></code></pre></td></tr></tbody></table></figure>



<h2 id="训练-1"><a href="#训练-1" class="headerlink" title="训练"></a>训练</h2><p>通过深度学习框架的高级API来实现我们的模型只需要相对较少的代码。 我们不必单独分配参数、不必定义我们的损失函数，也不必手动实现小批量随机梯度下降。 当我们需要更复杂的模型时，高级API的优势将大大增加。 当我们有了所有的基本组件，训练过程代码与我们从零开始实现时所做的非常相似。</p>
<p>回顾一下：在每个迭代周期里，我们将完整遍历一次数据集（<code>train_data</code>）， 不停地从中获取一个小批量的输入和相应的标签。 对于每一个小批量，我们会进行以下步骤:</p>
<ul>
<li>通过调用<code>net(X)</code>生成预测并计算损失<code>l</code>（前向传播）。</li>
<li>通过进行反向传播来计算梯度。</li>
<li>通过调用优化器来更新模型参数。</li>
</ul>
<p>为了更好的衡量训练效果，我们计算每个迭代周期后的损失，并打印它来监控训练过程。</p>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">num_epochs = <span class="hljs-number">3</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):<br>    <span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> data_iter:<br>        l = loss(net(X) ,y)<br>        trainer.zero_grad()<br>        l.backward()<br>        trainer.step()<br>    l = loss(net(features), labels)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f'epoch <span class="hljs-subst">{epoch + <span class="hljs-number">1</span>}</span>, loss <span class="hljs-subst">{l:f}</span>'</span>)<br>    <br><span class="hljs-comment"># result</span><br>epoch <span class="hljs-number">1</span>, loss <span class="hljs-number">0.000183</span><br>epoch <span class="hljs-number">2</span>, loss <span class="hljs-number">0.000101</span><br>epoch <span class="hljs-number">3</span>, loss <span class="hljs-number">0.000101</span><br></code></pre></td></tr></tbody></table></figure>

<ul>
<li>下面我们比较生成数据集的真实参数和通过有限数据训练获得的模型参数。 要访问参数，我们首先从<code>net</code>访问所需的层，然后读取该层的权重和偏置。 正如在从零开始实现中一样，我们估计得到的参数与生成数据的真实参数非常接近。</li>
</ul>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">w = net[<span class="hljs-number">0</span>].weight.data<br><span class="hljs-built_in">print</span>(<span class="hljs-string">'w的估计误差：'</span>, true_w - w.reshape(true_w.shape))<br>b = net[<span class="hljs-number">0</span>].bias.data<br><span class="hljs-built_in">print</span>(<span class="hljs-string">'b的估计误差：'</span>, true_b - b)<br><br><span class="hljs-comment"># result</span><br>w的估计误差： tensor([-<span class="hljs-number">0.0003</span>, -<span class="hljs-number">0.0002</span>])<br>b的估计误差： tensor([<span class="hljs-number">8.1062e-06</span>])<br></code></pre></td></tr></tbody></table></figure>



<h1 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h1><h2 id="synthetic-data"><a href="#synthetic-data" class="headerlink" title="synthetic_data"></a>synthetic_data</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">synthetic_data</span>(<span class="hljs-params">w, b, num_examples</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""生成y=Xw+b+噪声"""</span><br>    X = torch.normal(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, (num_examples, <span class="hljs-built_in">len</span>(w)))<br>    y = torch.matmul(X, w) + b<br>    y += torch.normal(<span class="hljs-number">0</span>, <span class="hljs-number">0.01</span>, y.shape)<br>    <span class="hljs-keyword">return</span> X, y.reshape((-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>))<br><br>true_w = torch.tensor([<span class="hljs-number">2</span>, -<span class="hljs-number">3.4</span>])<br>true_b = <span class="hljs-number">4.2</span><br>features, labels = synthetic_data(true_w, true_b, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<ul>
<li>输入为：weight, bias和数量，输出为：X矩阵和y列向量。</li>
</ul>
<ol>
<li>函数首先使用 <code>torch.normal</code> 函数生成一个维度为 <code>(num_examples, len(w))</code> 的张量 <code>X</code>，其中每个元素都是从均值为 0、标准差为 1 的正态分布中随机采样得到的。 -&gt; $X_{numExamples\ *\ len(w)}$</li>
<li>通过矩阵乘法 <code>torch.matmul(X, w)</code> 和加法 <code>+ b</code>，生成一个表示标签 <code>y</code> 的张量。这里使用了真实的权重向量 <code>w</code> 和偏置值 <code>b</code>，并将噪声添加到 <code>y</code> 中。$X_{numExamples\ *\ len(w)}\ *\ w_{len(w)\ *\ 1} + b$ -&gt; $y_{numExamples\ *\ 1}$</li>
<li>通过 <code>torch.normal</code> 函数生成一个维度与 <code>y</code> 相同的张量，并将其加到 <code>y</code> 中，以模拟噪声 -&gt; 现实世界中噪声是正常的，我们手动产生一个y.shape相同类型的噪声，并加到y矩阵上。</li>
<li>返回$X_{numExamples\ *\ len(w)}$，和y.reshape((-1, 1))，当调用 <code>y.reshape((-1, 1))</code> 时，函数会自动计算第一维的长度，以使得 <code>y</code> 的形状变为一个列向量，即第一维的长度为 <code>1</code>，而第二维的长度自适应。</li>
</ol>
<ul>
<li>函数的返回值为特征和标签，也就是我们真实的X和Y，我们使用X和Y来训练模型。</li>
</ul>
</blockquote>
<h2 id="data-iter"><a href="#data-iter" class="headerlink" title="data_iter"></a>data_iter</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">data_iter</span>(<span class="hljs-params">batch_size, features, labels</span>):<br>    num_examples = <span class="hljs-built_in">len</span>(features)<br>    indices = <span class="hljs-built_in">list</span>(<span class="hljs-built_in">range</span>(num_examples))<br>    <span class="hljs-comment"># 这些样本是随机读取的，没有特定的顺序</span><br>    random.shuffle(indices)<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, num_examples, batch_size):<br>        batch_indices = torch.tensor(<br>            indices[i: <span class="hljs-built_in">min</span>(i + batch_size, num_examples)])<br>        <span class="hljs-keyword">yield</span> features[batch_indices], labels[batch_indices]<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<ul>
<li>输入为：<code>batch_size</code>（批次大小）、<code>features</code>（特征张量）和 <code>labels</code>（标签张量）。输出为：随机取样的特征和标签向量。</li>
</ul>
<ol>
<li>函数首先获取样本数量 <code>num_examples</code>，然后创建一个包含从 <code>0</code> 到 <code>num_examples-1</code> 的索引列表 <code>indices</code>。</li>
<li>通过 <code>random.shuffle</code> 函数对索引列表进行随机打乱，以实现随机读取样本。</li>
<li>通过 <code>range</code> 函数以步长为 <code>batch_size</code> 进行迭代，每次迭代生成一个批次的数据。</li>
<li>通过 <code>torch.tensor</code> 函数将当前批次的索引列表切片为一个张量 <code>batch_indices</code>，该张量包含当前批次的索引。</li>
<li>使用 <code>yield</code> 关键字返回当前批次的特征张量 <code>features[batch_indices]</code> 和标签张量 <code>labels[batch_indices]</code>。</li>
</ol>
<ul>
<li>通过使用迭代器函数 <code>data_iter</code>，可以方便地按指定的批次大小随机读取数据集的特征和标签。在训练模型时，可以使用该迭代器循环读取数据集的不同批次，以进行模型的训练和优化。</li>
</ul>
</blockquote>
<h2 id="linreg"><a href="#linreg" class="headerlink" title="linreg"></a>linreg</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">linreg</span>(<span class="hljs-params">X, w, b</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""线性回归模型"""</span><br>    <span class="hljs-keyword">return</span> torch.matmul(X, w) + b<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>该函数实现了线性回归模型，其中X是特征张量，w是权重张量，b是偏置张量。函数通过torch.matmul计算特征与权重的矩阵乘法，并将结果与偏置相加，得到线性回归的预测结果。</p>
</blockquote>
<h2 id="squared-loss"><a href="#squared-loss" class="headerlink" title="squared_loss"></a>squared_loss</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">squared_loss</span>(<span class="hljs-params">y_hat, y</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""均方损失"""</span><br>    <span class="hljs-keyword">return</span> (y_hat - y.reshape(y_hat.shape)) ** <span class="hljs-number">2</span> / <span class="hljs-number">2</span><br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>该函数实现了均方损失（平方损失），其中y_hat是模型的预测结果，y是实际标签。函数通过计算(y_hat - y.reshape(y_hat.shape))的平方，再除以2，得到均方损失。</p>
</blockquote>
<h2 id="sgd"><a href="#sgd" class="headerlink" title="sgd"></a>sgd</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">sgd</span>(<span class="hljs-params">params, lr, batch_size</span>):  <span class="hljs-comment">#@save</span><br>    <span class="hljs-string">"""小批量随机梯度下降"""</span><br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        <span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> params:<br>            param -= lr * param.grad / batch_size<br>            param.grad.zero_()<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>该函数实现了小批量随机梯度下降（SGD）算法，用于更新模型参数。其中params是一个包含模型参数的列表，lr是学习率，batch_size是批次大小。</p>
</blockquote>
<h2 id="训练-2"><a href="#训练-2" class="headerlink" title="训练"></a>训练</h2><figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">lr = <span class="hljs-number">0.03</span><br>num_epochs = <span class="hljs-number">3</span><br>net = linreg<br>loss = squared_loss<br><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):<br>    <span class="hljs-keyword">for</span> X, y <span class="hljs-keyword">in</span> data_iter(batch_size, features, labels):<br>        l = loss(net(X, w, b), y)  <span class="hljs-comment"># X和y的小批量损失</span><br>        <span class="hljs-comment"># 因为l形状是(batch_size,1)，而不是一个标量。l中的所有元素被加到一起，</span><br>        <span class="hljs-comment"># 并以此计算关于[w,b]的梯度</span><br>        l.<span class="hljs-built_in">sum</span>().backward()<br>        sgd([w, b], lr, batch_size)  <span class="hljs-comment"># 使用参数的梯度更新参数</span><br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        train_l = loss(net(features, w, b), labels)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f'epoch <span class="hljs-subst">{epoch + <span class="hljs-number">1</span>}</span>, loss <span class="hljs-subst">{<span class="hljs-built_in">float</span>(train_l.mean()):f}</span>'</span>)<br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<ol>
<li><code>lr = 0.03</code>: <code>lr</code> 是学习率 (learning rate)，它是控制梯度下降步长的超参数，用于更新模型参数时的调整幅度。</li>
<li><code>num_epochs = 3</code>: <code>num_epochs</code> 表示迭代次数，即整个数据集将被训练3次。</li>
<li><code>net = linreg</code>: <code>net</code> 是一个线性回归模型，这里使用了<code>linreg</code>函数表示。</li>
<li><code>loss = squared_loss</code>: <code>loss</code> 是损失函数，这里使用了均方误差损失 (squared loss)。</li>
<li><code>for epoch in range(num_epochs):</code>: 开始迭代训练，共进行3次迭代。</li>
<li><code>for X, y in data_iter(batch_size, features, labels):</code>: <code>data_iter</code> 是数据迭代器，每次从<code>features</code>和<code>labels</code>中获取一个大小为<code>batch_size</code>的小批量数据。</li>
<li><code>l = loss(net(X, w, b), y)</code>: 计算当前小批量数据的预测值并计算与真实标签<code>y</code>之间的损失。</li>
<li><code>l.sum().backward()</code>: 将损失 <code>l</code> 中的所有元素加和得到一个标量值，然后计算该标量值关于模型参数<code>w</code>和<code>b</code>的梯度。</li>
<li><code>sgd([w, b], lr, batch_size)</code>: 使用随机梯度下降 (SGD) 算法，根据梯度和学习率，更新模型参数<code>w</code>和<code>b</code>。</li>
<li><code>with torch.no_grad():</code>: 这是一个不计算梯度的上下文管理器，用于更新参数时不需要计算梯度。</li>
<li><code>train_l = loss(net(features, w, b), labels)</code>: 在整个训练集上计算当前模型的损失，用于输出当前模型的训练效果。</li>
<li><code>print(f'epoch {epoch + 1}, loss {float(train_l.mean()):f}')</code>: 输出当前迭代的训练结果，包括迭代次数和平均损失值。</li>
</ol>
</blockquote>
<h2 id="l-sum"><a href="#l-sum" class="headerlink" title="l.sum()"></a>l.sum()</h2><p>在上面的代码中，<code>l</code> 是当前小批量数据的损失，计算得到的是一个张量，而不是一个标量。在使用梯度下降法（或其他优化算法）进行参数更新时，通常需要一个标量损失来计算参数的梯度，并对参数进行更新。所以，为了得到一个标量损失，代码中使用了 <code>l.sum()</code> 来将所有损失元素相加，得到一个标量值，然后再通过该标量值来计算关于参数的梯度。</p>
<p>让我们更详细地解释为什么需要将损失元素相加并得到一个标量值来计算梯度：</p>
<ol>
<li><strong>Backpropagation and Gradients</strong>: 在深度学习中，我们使用反向传播算法来计算模型参数的梯度。反向传播需要一个标量损失值作为起点，然后通过计算该标量相对于每个模型参数的偏导数（梯度）来进行参数更新。</li>
<li><strong>Batched Computations</strong>: 通常，在深度学习中，我们会使用小批量（batch）数据进行训练，而不是单个样本。这样做有两个原因：首先，小批量训练可以加快训练过程；其次，小批量计算有利于并行计算，提高训练效率。</li>
<li><strong>Loss Computation for Batches</strong>: 当我们使用小批量数据进行训练时，损失函数的计算也会产生小批量的损失值。这些损失值组成一个张量，而不是一个标量。</li>
<li><strong>Summing Loss Elements</strong>: 为了将小批量的损失值转换为一个标量，一种常见的方法是对损失值中的元素进行求和。在代码中，<code>l.sum()</code> 就是将 <code>l</code> 这个张量中的所有元素相加得到一个标量值，从而成为反向传播的起点。</li>
</ol>
<p>所以，<code>l.sum().backward()</code> 的目的是计算 <code>l</code> 张量中所有元素的梯度，将其作为损失函数关于模型参数的梯度，并用于后续的参数更新。这种技巧允许我们在小批量数据上训练，并将损失计算转换为标量，以便进行反向传播。</p>
<h2 id="torch-no-grad"><a href="#torch-no-grad" class="headerlink" title="torch.no_grad()"></a>torch.no_grad()</h2><p>在PyTorch中，<code>torch.no_grad()</code>是一个上下文管理器，也称为上下文环境或上下文块。它的作用是告诉PyTorch在该上下文块内不需要计算梯度，从而在此期间避免不必要的梯度计算，节省内存和计算资源。通常，<code>torch.no_grad()</code>用于执行一些不需要梯度的操作，比如在模型训练过程中的参数更新阶段或进行模型推断时。</p>
<p>详细解释如下：</p>
<ol>
<li><strong>Gradient Tracking in PyTorch</strong>: 在PyTorch中，默认情况下，所有的张量都会自动跟踪计算梯度信息。这个特性称为自动微分（Autograd），它是PyTorch进行梯度计算和反向传播的基础。当你对一个张量进行操作（比如加减乘除、求和等），PyTorch会构建一个计算图，用于计算该操作的梯度。这样在反向传播时，PyTorch可以根据计算图自动计算出梯度，从而进行参数的更新。</li>
<li><strong>Disabling Gradient Calculation with <code>torch.no_grad()</code></strong>: 有些情况下，我们并不希望进行梯度计算，比如在参数更新阶段，我们只需要根据梯度更新参数，而不需要计算额外的梯度信息。这时，可以使用<code>torch.no_grad()</code>上下文管理器来暂时关闭梯度计算。在这个上下文块内，所有的操作不会被跟踪，也不会构建计算图，从而节省了梯度计算所需的内存和计算资源。</li>
<li><strong>Benefits of Using <code>torch.no_grad()</code></strong>:<ul>
<li><strong>Memory Savings</strong>: 由于不计算梯度，所以不需要保存梯度相关的中间结果，从而减少了内存的使用量。</li>
<li><strong>Speedup</strong>: 不进行梯度计算可以加快计算速度，特别是在推断（inference）阶段，当不需要反向传播时，使用<code>torch.no_grad()</code>可以显著加速代码执行。</li>
<li><strong>Preventing Unintended Gradient Updates</strong>: 有时候在模型推断阶段，如果不使用<code>torch.no_grad()</code>，可能会不小心修改了模型参数，而这些修改是不希望的。</li>
</ul>
</li>
</ol>
<figure class="highlight python"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><br><span class="hljs-comment"># 创建一个需要计算梯度的张量</span><br>x = torch.tensor([<span class="hljs-number">2.0</span>], requires_grad=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 在计算图上计算 x^2</span><br>y = x ** <span class="hljs-number">2</span><br><br><span class="hljs-comment"># 使用torch.no_grad()进行推断，不需要梯度</span><br><span class="hljs-keyword">with</span> torch.no_grad():<br>    <span class="hljs-comment"># 在这个上下文块内，任何操作都不会被跟踪，也不会构建计算图</span><br>    z = y * <span class="hljs-number">3</span><br><br><span class="hljs-built_in">print</span>(z)  <span class="hljs-comment"># tensor([12.])</span><br></code></pre></td></tr></tbody></table></figure>

<blockquote>
<p>在上面的示例中，在<code>torch.no_grad()</code>上下文块内，<code>y * 3</code>操作不会被跟踪，因此不会计算梯度。这对于推断阶段或者仅需要参数更新的情况非常有用。</p>
</blockquote>
<h1 id="References"><a href="#References" class="headerlink" title="References:"></a>References:</h1><ol>
<li><a target="_blank" rel="noopener" href="https://zh.d2l.ai/chapter_linear-networks/linear-regression.html">https://zh.d2l.ai/chapter_linear-networks/linear-regression.html</a></li>
<li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/95814925">https://zhuanlan.zhihu.com/p/95814925</a></li>
<li><a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=s7BxboxEfnU">https://www.youtube.com/watch?v=s7BxboxEfnU</a></li>
</ol>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/AI/" class="category-chain-item">AI</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%A0%940%E8%87%AA%E5%AD%A6/">#研0自学</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>D2L-3-Linear Neural Networks for Regression</div>
      <div>http://example.com/2023/07/25/d2l-3-linear-neural-networks-for-regression/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Alexander Liu</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年7月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/07/23/d2l-2-preliminaries/" title="D2L-2-Preliminaries">
                        <span class="hidden-mobile">D2L-2-Preliminaries</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  





  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.events.registerRefreshCallback(function() {
      if ('mermaid' in window) {
        mermaid.init();
      }
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
