

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/tuzi.png">
  <link rel="icon" href="/img/tuzi.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Alexander Liu">
  <meta name="keywords" content="分布式系统,后端研发,数据协同">
  
    <meta name="description" content="操作系统与虚拟化安全课程小结，虽然开卷，然而紧张。。。*代表有一部分没有补全，&amp;代表这部分内容很多，不详细，请参考PPT。">
<meta property="og:type" content="article">
<meta property="og:title" content="PKU-操作系统与虚拟化安全">
<meta property="og:url" content="https://alexanderliu-creator.github.io/2023/12/25/pku-cao-zuo-xi-tong-yu-xu-ni-hua-an-quan/index.html">
<meta property="og:site_name" content="兔の博客">
<meta property="og:description" content="操作系统与虚拟化安全课程小结，虽然开卷，然而紧张。。。*代表有一部分没有补全，&amp;代表这部分内容很多，不详细，请参考PPT。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202310300934730.png">
<meta property="article:published_time" content="2023-12-25T10:04:38.000Z">
<meta property="article:modified_time" content="2023-12-30T08:54:00.297Z">
<meta property="article:author" content="Alexander Liu">
<meta property="article:tag" content="研一课程">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202310300934730.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>PKU-操作系统与虚拟化安全 - 兔の博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"alexanderliu-creator.github.io","root":"/","version":"1.9.3","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":1},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="兔の博客" type="application/atom+xml">

<style>.github-emoji { position: relative; display: inline-block; width: 1.2em; min-height: 1.2em; overflow: hidden; vertical-align: top; color: transparent; }  .github-emoji > span { position: relative; z-index: 10; }  .github-emoji img, .github-emoji .fancybox { margin: 0 !important; padding: 0 !important; border: none !important; outline: none !important; text-decoration: none !important; user-select: none !important; cursor: auto !important; }  .github-emoji img { height: 1.2em !important; width: 1.2em !important; position: absolute !important; left: 50% !important; top: 50% !important; transform: translate(-50%, -50%) !important; user-select: none !important; cursor: auto !important; } .github-emoji-fallback { color: inherit; } .github-emoji-fallback img { opacity: 0 !important; }</style>
</head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>兔的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/background_post.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="PKU-操作系统与虚拟化安全"></span>
          
        </div>

        
          
  <div class="mt-3">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-author" aria-hidden="true"></i>
        Alexander Liu
      </span>
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-12-25 18:04" pubdate>
          2023年12月25日 晚上
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          27k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          227 分钟
        
      </span>
    

    
    
      
        <span id="busuanzi_container_page_pv" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="busuanzi_value_page_pv"></span> 次
        </span>
        
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">PKU-操作系统与虚拟化安全</h1>
            
              <p class="note note-info">
                
                  
                    本文最后更新于：8 个月前
                  
                
              </p>
            
            
              <div class="markdown-body">
                
                <p>操作系统与虚拟化安全课程小结，虽然开卷，然而紧张。。。*代表有一部分没有补全，&amp;代表这部分内容很多，不详细，请参考PPT。</p>
<span id="more"></span>

<h1 id="0-操作系统概述"><a href="#0-操作系统概述" class="headerlink" title="0. 操作系统概述"></a>0. 操作系统概述</h1><h2 id="0-1-操作系统原理与发展史"><a href="#0-1-操作系统原理与发展史" class="headerlink" title="0.1 操作系统原理与发展史"></a>0.1 操作系统原理与发展史</h2><blockquote>
<p>Focus on 微内核</p>
</blockquote>
<ul>
<li><p>操作系统的主流结构：微内核、宏内核。</p>
</li>
<li><p>什么是微内核？足够小的内核 基于客户-服务器模式 实现机制和策略的分离 采用面向对象技术。 OS 基本功能-微内核，OS其他功能-用户态服务器。</p>
</li>
<li><p>微内核结构操作系统…</p>
</li>
<li><p>宏内核结构操作系统…</p>
</li>
<li><p>微内核操作系统的好处</p>
</li>
<li><p>改变操作系统功能的技术：网络计算、多核计算、可信计算、虚拟化计算、移动计算、云计算</p>
</li>
<li><p>操作系统基本概念：</p>
<ul>
<li>定义，任务</li>
<li>设计目标</li>
<li>功能：CPU, Storage, I/O, File System, User Interface</li>
<li>主要特性：并发行，共享性，异步性</li>
<li>引导？外部存储器 -&gt; OS -&gt; 主存储器</li>
<li>过程和原理：<ul>
<li>上电（硬件电路决定），BIOS软件固化在内存，CPU直接读BIOS中的指令。</li>
<li>BIOS自检和加载引导扇区</li>
<li>加载引导扇区</li>
<li>加载操作系统</li>
<li>运行操作系统</li>
</ul>
</li>
</ul>
</li>
<li><p>CPU管理：</p>
<ul>
<li>中断<ul>
<li>中断或中断机制是实现多道程序设计与并发执行的基础和必要条件。如果没有中断，操作系统就无法获得系统的控制权，就不会将CPU（也作为一种资源）分派给不同的进程而实现并发执行。</li>
<li>中断源类型：强迫性中断，自愿性中断</li>
</ul>
</li>
<li>CPU调度<ul>
<li>对处理机的调度最终归结为对进程和线程的管理</li>
<li>多道程序，并发并行</li>
</ul>
</li>
<li>进程<ul>
<li>进程是一个可并发执行的具有独立功能的程序关于某个数据集合的一次执行过程，也是操作系统进行资源分配和保护的基本单位。</li>
<li>进程与程序的联系与区别。</li>
<li>三个状态：Running, Ready, Blocked，还有转换。</li>
<li>PCB，进程 = 程序 + 数据 + 进程控制块，三者的定义和关系。</li>
<li>缺点：进程时空的开销大，进程间通信的代价大，进程之间的并发性粒度较粗，不适合并行计算和分布式计算的要求，不适合客户/服务器计算的要求</li>
</ul>
</li>
<li>线程<ul>
<li>引入原因，线程含义</li>
<li>属性拆开：独立分配资源和调度分派执行</li>
<li>好处</li>
<li>进程线程一对多</li>
<li>二者比较和关系</li>
</ul>
</li>
<li>调度<ul>
<li>调度层次：低级、中级、高级</li>
<li>调度算法目标：资源利用率、公平性、均衡性、策略强制执行</li>
<li>算法：FCFS, SJF, 高响应比优先</li>
<li>What, Why, How</li>
</ul>
</li>
</ul>
</li>
<li><p>存储管理：</p>
<ul>
<li>功能：分配、共享、保护、扩充。</li>
<li>存储体系结构（缓存）</li>
<li>虚拟存储器<ul>
<li>概念</li>
<li>基本原理</li>
<li>缺页请求</li>
</ul>
</li>
</ul>
</li>
<li><p>设备管理</p>
<ul>
<li>特点，目的</li>
<li>概述：存储设备，IO设备</li>
<li>资源角度分类：独占、共享、虚设备</li>
<li>Linux分类：块、字符、网络设备</li>
<li>目的和任务</li>
<li>功能</li>
</ul>
</li>
<li><p>文件管理</p>
<ul>
<li>文件、文件系统定义</li>
<li>信息流</li>
<li>目录、目录结构</li>
<li>文件分类</li>
<li>目的</li>
<li>基本功能</li>
</ul>
</li>
</ul>
<h2 id="0-2-操作系统设计技术"><a href="#0-2-操作系统设计技术" class="headerlink" title="0.2 操作系统设计技术"></a>0.2 操作系统设计技术</h2><blockquote>
<p>Focus on 各个子系统</p>
</blockquote>
<ul>
<li><p>内核导论</p>
<ul>
<li>文件子系统</li>
<li>进程控制子系统</li>
<li>硬件控制</li>
</ul>
</li>
<li><p>文件内部表示</p>
<ul>
<li>Inode &amp; inode table</li>
<li>磁盘索引节点，内存索引节点</li>
<li>文件表</li>
<li>用户文件描述符表(file_struct结构体)</li>
<li>文件相关三个表的关系：用户文件描述符表、文件表、内存索引节点表</li>
<li>Fork操作系统语义</li>
<li>Linux进程相关三个表之间的关系：task_struct -&gt; fs_struct -&gt; inode</li>
<li>VFS与具体文件系统的关系，file_operations数据结构</li>
</ul>
</li>
<li><p>进程结构</p>
<ul>
<li>进程的基本概念</li>
<li>进程的数据结构<ul>
<li>进程的标识</li>
<li>进程树和进程之间的关系</li>
<li>进程的上下文</li>
</ul>
</li>
<li>进程表与u区、系统区表、进程区表</li>
<li>进程状态以及转换</li>
<li>进程的控制</li>
<li>进程间通信</li>
<li>IPC机制的共性</li>
<li>消息队列、共享存储区、信号量、的系统调用</li>
</ul>
</li>
<li><p>I/O子系统：</p>
<ul>
<li>基本概念</li>
<li>接口</li>
</ul>
</li>
</ul>
<h2 id="0-3-虚拟化技术概述"><a href="#0-3-虚拟化技术概述" class="headerlink" title="0.3 虚拟化技术概述"></a>0.3 虚拟化技术概述</h2><blockquote>
<p>Focus on 虚拟化概念</p>
</blockquote>
<ul>
<li>数据中心现状和趋势<ul>
<li>传统数据中心的IT资源配置模式 — “烟囱式”结构</li>
<li>缺陷</li>
<li>资源利用率低下的原因</li>
<li>“冰山模式”—传统数据中心的成本支出结构</li>
<li>数据中心的IT基础架构发展路径，三个阶段性步骤：整合 -&gt; 虚拟化 -&gt; 自动化</li>
<li>随机应变的数据中心：非虚拟环境、虚拟环境</li>
</ul>
</li>
<li>虚拟化<ul>
<li>定义</li>
<li>常见类型：基础设施虚拟化、系统虚拟化、软件虚拟化。</li>
<li>基础设施虚拟化：网络、存储虚拟化</li>
<li>系统虚拟化</li>
<li>软件虚拟化</li>
</ul>
</li>
<li>虚拟化关键技术<ul>
<li>服务器虚拟化技术，云计算的核心技术</li>
<li>技术发展</li>
<li>体系结构</li>
<li>实现技术的分类：全虚拟化、泛虚拟化、硬件辅助虚拟化</li>
<li>VMM分类</li>
<li>VMM实现技术：CPU虚拟化、内存虚拟化、IO虚拟化</li>
<li>CPU虚拟化：<ul>
<li>特权指令与非特权指令</li>
<li>虚拟化系统下CPU等级划分的困难</li>
<li>硬件CPU虚拟化</li>
</ul>
</li>
<li>内存虚拟化<ul>
<li>概念</li>
<li>方法</li>
</ul>
</li>
<li>IO虚拟化<ul>
<li>概念</li>
<li>缺点</li>
</ul>
</li>
</ul>
</li>
<li>主流的虚拟化软件与虚拟化技术实践<ul>
<li>VMWare: 不开源</li>
<li>Xen: 开源</li>
<li>硬件对虚拟化的支持</li>
</ul>
</li>
</ul>
<h2 id="0-4-系统虚拟化关键技术"><a href="#0-4-系统虚拟化关键技术" class="headerlink" title="0.4 系统虚拟化关键技术"></a>0.4 系统虚拟化关键技术</h2><ul>
<li>系统虚拟化的主要用途：隔离、合并、迁移、个性化</li>
<li>CPU虚拟化：<ul>
<li>概念</li>
<li>基于额度的调度方法</li>
<li>威胁：<ul>
<li>基于Xen Credit调度算法脆弱性的拒绝服务</li>
<li>抗干扰虚拟机隐蔽通道－信息泄漏</li>
</ul>
</li>
<li>软件解决：客户端降权<ul>
<li>在0环以上运行 Guest OS时，敏感指令运行会出错</li>
<li>在VMM中 处理Guest OS运行敏感指令时所产生的错误</li>
</ul>
</li>
<li>CPU虚拟化挑战</li>
<li>硬件辅助CPU虚拟化</li>
<li>Intel VT-x操作模式，VMX指令集。</li>
<li>VM Entry and VM Exit</li>
<li>虚拟机控制结构 (VMCS)</li>
</ul>
</li>
<li>内存虚拟化：机器地址、物理地址、虚拟地址。<ul>
<li>页表虚拟化</li>
<li>MMU泛虚拟化与影子页表的比较</li>
<li>内存虚拟化优化机制: a. 按需取页与虚拟存储，两种方案。 b. 内存共享—内存页面的写时复制机制。c. 内存可写工作集（writable working sets) 的使用 d. 硬件辅助内存虚拟化</li>
<li>硬件辅助内存虚拟化-Intel 虚拟处理器标识（VPIDs), 硬件辅助内存虚拟化- Intel 扩展页表EPT</li>
</ul>
</li>
<li>IO虚拟化：<ul>
<li>虚拟化方式：模拟IO设备，额外软件接口</li>
<li>Intel VT-d 硬件辅助I/O虚拟化技术</li>
<li>基于软件的I/O虚拟化，IO设备的直接分配</li>
<li>VT-d设计，DMA虚拟化实现<ul>
<li>DMA虚拟化实现，新设计的IOMMU</li>
<li>中断重映射</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="1-安全概念和标准"><a href="#1-安全概念和标准" class="headerlink" title="1. 安全概念和标准"></a>1. 安全概念和标准</h1><h2 id="1-1-操作系统安全的重要性"><a href="#1-1-操作系统安全的重要性" class="headerlink" title="1.1 操作系统安全的重要性"></a>1.1 操作系统安全的重要性</h2><ul>
<li>安全性包括: 法律法规要求, 人身安全要求, 信息/资产保护要求</li>
<li>威胁: Software bugs(软件漏洞), Malicious users(恶意用户), Unauthorized access(未授权访问)-机制不完善, Human error(人员错误), Hardware error(硬件错误)</li>
<li>攻击: <ul>
<li>恶意代码(Malicious code)-木马，病毒，逻辑炸弹，蠕虫，天窗后门隐蔽通道等（参见教材P1-3)</li>
<li>系统渗透(System penetration) 一 未授权访问系统资源</li>
<li>中间人(Man in the middle)攻击者将自己置于用户和系统之间</li>
<li>拒绝服务(Denial of service) 一 使得一个可用服务变得不可用</li>
<li>网终嗅探(Network sniffing.) — 攻击者监听网终流量</li>
<li>信息池露(TEMPEST) 一 从电磁辐射中抽取信息</li>
<li>社会工程(Social engineering) — 为了达到攻击目的而欺骗人</li>
</ul>
</li>
<li>安全性的两个方面：<ul>
<li>计算机安全(Computer security): 保证计算资源不被滥用或未授权使用，同时保护数据免受 意外或故意破坏、泄密或修改；</li>
<li>通信安全(Communication security): 在计算机网络和分布式系统中的数据表示和编码信息在传 输过程中得到保护。也称网络安全。</li>
</ul>
</li>
<li>数据加密不能解决所有问题，它主要解决的是数据的机密性和完整性问题，但是还有其他安全挑战。</li>
<li>Windows NT安全漏洞：<ul>
<li>特洛伊木马（Trojan Horses）和病毒，依靠缺省的权力黑入。</li>
<li>NTFS文件系统中，读权限意味着同时具有读和执行的权限，文件不当执行。</li>
</ul>
</li>
<li>Unix/Linux安全漏洞<ul>
<li>adduser/useradd设计错误，默认组名等同于用户名，可以凭借特殊用户名分入特殊用户组，从而获取权限。</li>
<li>Linux ping 缓冲区溢出漏洞：丢弃root特权失败，使得本地 用户有可能获取root权限。</li>
</ul>
</li>
<li>安全性规则：安全性必须是逐层建立的，每一层的安全性应该是建立在假设底层是可信的基础之上的，在不可信层上建立安全应用是不值当的。用户空间不可信，且它可以控制内核空间（如：通过内核模块的插入权限提升 -&gt; 内核空间也是不可信的。What we need is:</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202312251918751.png" srcset="/img/loading.gif" lazyload alt="image-20231225191851792"></p>
<blockquote>
<p>小Demo: 老鼠吃曲奇，如何保护曲奇？保护房子(No)，保护曲奇(Yes)</p>
</blockquote>
<ul>
<li>安全系统的定义：<ul>
<li>它是从一个授权状态（或安全状态）开始的</li>
<li>它不会进入一个未授权状态（或非安全状态）</li>
</ul>
</li>
<li>安全与可信的比较</li>
</ul>
<table>
<thead>
<tr>
<th>Secure</th>
<th>Trusted</th>
</tr>
</thead>
<tbody><tr>
<td>Binary</td>
<td>Graded</td>
</tr>
<tr>
<td>Property of presenter</td>
<td>Property of receiver</td>
</tr>
<tr>
<td>Asserted, based on characteristics</td>
<td>Judged, based on evidence</td>
</tr>
<tr>
<td>Absolute</td>
<td>Relative</td>
</tr>
<tr>
<td>Goal</td>
<td>Characteristic</td>
</tr>
</tbody></table>
<blockquote>
<p>Main concepts of “trusted”: </p>
<ol>
<li><strong>执行安全策略</strong>（Enforcement of security policy）：确保所有安全相关的策略得到有效执行。</li>
<li><strong>充分的措施和机制</strong>（Sufficient measures and mechanisms）：采取足够的安全措施和机制来保护系统和数据。</li>
<li><strong>评估</strong>（Evaluation）：对安全措施和策略进行定期评估，以确保它们的有效性和适用性。</li>
</ol>
</blockquote>
<h2 id="1-2-国内外技术现状"><a href="#1-2-国内外技术现状" class="headerlink" title="1.2 国内外技术现状"></a>1.2 国内外技术现状</h2><ul>
<li>背景<ul>
<li>作为战略技术资源，国外对高级别（B1级以上）安全操作系统的出 口进行了严格的限制。</li>
<li>对已经掌握的方法和关键技术也进行了严格保密，文献中很难见到 有关技术细节。</li>
</ul>
</li>
<li>所有技术：<ul>
<li><strong>Multics (多重信息计算服务系统)</strong>: 1965年由美国贝尔实验室和麻省理工学院的MAC项目组联合开发。旨在实现并发访问信息存储系统时的高安全性，包括受控共享、用户鉴别、用户间隔离等。虽然结果不太理想，但为安全操作系统研究迈出了重要的第一步。</li>
<li><strong>Adept-50</strong>: 美国军方第一个实用的分时（time-sharing) 安全操作系统。以一个高水印模型(high-water-mark model)为基础， 为给定的安全问题提供了一个比较形式化的解决方案。</li>
<li><strong>PSOS (Provably Secure Operating System)</strong>: 1973-1980年间开发的层次化、基于权能的安全操作系统，使用严格的工程过程减小了安全性论证的复杂性。</li>
<li><strong>KSOS (Kernelized Secure Operating System)</strong>: 1977年由美国国防部研究计划局发起，由Ford公司承担的项目，采用形式化流分析技术，目标是高安全可信性。</li>
<li><strong>LOCK(Logical Co-processing Kernel)</strong>: 可验证安全操作系统项目是在美国政府的资助下由 国家计算安全中心于1987－1992年完成的，目标是 达到或超过TCSEC A1级安全需求的安全系统。</li>
<li><strong>XENIX (Secure XENIX &amp; Trusted XENIX)</strong>: IBM公司于1986年开发的安全操作系统，目标是TCSEC的B2级至A1级。1989年，产品更名为Trusted XENIX，并提供了更高级别的安全特性。</li>
<li><strong>TMach (Trusted Mach) &amp; DTMach (Distributed Trusted Mach)</strong>: 分别于1987年和1992-1993年由美国TIS公司和NSA及安全计算公司SCC的研究人员开发。TMach旨在实现B3级系统，而DTMach是基于TMach和LOCK项目的分布式系统。</li>
<li><strong>DTOS (Distributed Trusted Operating System)</strong>: 1997年完成的项目，旨在开发原型安全微内核并研究微内核操作系统的保证技术。它是DTMach之后的项目，由NSA、SCC和犹他州大学的Flux项目组合作开发。</li>
<li><strong>TUNIS</strong>: 加拿大多伦多大学于1989年开发，重点在于改进BLP模型和UNIX内核的重新实现，使用Turing Plus语言。系统设计目标是B3至A1级，但只提供了原型系统。</li>
<li><strong>ASOS (Army Secure Operating System)</strong>: 由TRW公司于1990年完成的军用安全操作系统，分为多级安全操作系统（TCSEC A1级）和专用安全操作系统（TCSEC C2级）。主要特点包括多平台兼容、Ada语言开发、自主访问控制、BLP模型的机密性控制和Biba模型的完整性控制。</li>
<li><strong>STOP (SCOMP Trusted Operating Program)</strong>: Honeywell公司为安全通信处理器开发的操作系统，于1985年通过美国国防部TCSEC A1的评估。采用Pascal语言实现内核软件。</li>
</ul>
</li>
</ul>
<blockquote>
<p>这些系统代表了安全操作系统领域的不同方向和发展阶段，每个系统都有其独特的安全特性和发展历程。</p>
</blockquote>
<ul>
<li><p>1990年以来，我国参照TCSEC B1, B2级和GB17859 第三级、第四级进行安全操作系统的研究和探讨。</p>
</li>
<li><p>J. P. Anderson研究报告，1972年，提出</p>
<ul>
<li>引用监控器(reference monitor)</li>
<li>引用验证机制(reference validation mechanism)</li>
<li>安全内核(security kernel)</li>
<li>安全建模(modeling)，即开发安全系统首先必须建立系统的安全模型，完成建模之后，再进行安全内核的设计与实现。</li>
</ul>
</li>
</ul>
<h2 id="1-3-国内外相关标准"><a href="#1-3-国内外相关标准" class="headerlink" title="1.3 国内外相关标准*"></a>1.3 国内外相关标准*</h2><ul>
<li>Evaluation Criteria<ul>
<li>TCSEC: Trusted Computer System Evaluation Criteria</li>
<li>ITSEC: Information Technology Security Evaluation Criteria</li>
<li>FC: Federal Criteria for Information Technology Security</li>
<li>CC: Common Criteria</li>
<li>Many others</li>
</ul>
</li>
</ul>
<ol>
<li><strong>彩虹系列 (Rainbow Series)</strong>:<ul>
<li>以1985年美国国防部发布的《可信计算机系统评测标准（TCSEC）》为核心。</li>
<li>对评测标准进行扩充，提供了关键的背景知识，深入解释和分析关键概念，并提出具体实现方法和措施。</li>
<li>彩虹系列是信息系统安全事业的里程碑，建立了一套被普遍接受和使用的标准体系。</li>
</ul>
</li>
<li>**TCSEC (Trusted Computer System Evaluation Criteria)**，通常称为橙皮书，是美国国防部制定的一系列用于评估计算机系统安全性的标准。TCSEC首次发布于1983年，并在1985年更新。它是彩虹系列丛书的核心，也是后续许多安全标准的基础，包括ITSEC和CC。TCSEC是评估计算机信息系统安全性的先驱，并对信息系统安全领域产生了深远影响。<ul>
<li>TCSEC的主要内容包括：<ol>
<li><strong>评估等级</strong>：将系统安全划分为D、C1、C2、B1、B2、B3和A1七个等级，每个等级都有其特定的安全要求。这些等级按照从最低到最高的安全性进行排列。</li>
<li><strong>安全功能</strong>：不同等级的系统需要实现不同的安全功能，包括但不限于用户身份验证、访问控制、审计和保证措施等。</li>
<li><strong>安全保证</strong>：随着等级的提高，系统需要提供越来越高级别的安全保证，如形式化验证和设计。</li>
<li><strong>实现方法和措施</strong>：TCSEC描述了如何实现特定等级的安全要求，并提供了相应的指导和措施。</li>
</ol>
</li>
<li>TCSEC的评估体系建立了一个用于确保计算机系统可信度的标准框架。这些标准框架包括了对安全策略的定义、对安全机制的描述以及保障措施，旨在确保系统能够抵御外部威胁和内部滥用。TCSEC及其彩虹系列丛书的发展标志着信息系统安全事业的重要里程碑，建立了一个被普遍接受和使用的标准和体系，并且提出的基本概念、原则和方法被广泛应用于各种信息技术产品和系统的安全评估中。</li>
</ul>
</li>
<li><strong>ITSEC (Information Technology Security Evaluation Criteria)</strong>:<ul>
<li>由法国、德国、荷兰和英联邦于1990年发布，欧共体于1991年发布了可操作的1.2版本。</li>
<li>ITSEC 是一套评估产品和系统安全的标准，每次评估通过功能性测试和渗透测试对IT安全属性进行详细检查。</li>
<li>引入了保密性、完整性和可用性的概念，以及安全目标（ST）的概念。</li>
<li>安全性要求分为“功能”和“保证”两部分，功能要求包括技术安全措施如访问控制等，保证要求如安全脆弱性分析等。</li>
<li>分别衡量安全功能（F1-F10）与安全保证要求（E0-E6）。</li>
</ul>
</li>
<li><strong>CC (Common Criteria for IT Security Evaluation)</strong>:<ul>
<li>CC是在ITSEC基础上发展起来的，由六国七方在1996年共同提出的通用安全测评标准。</li>
<li>1997年颁布了2.0版，1999年被ISO确立为国际标准ISO/IEC 15408。</li>
<li>CC提供了一组通用要求，使各种独立的安全评估结果具有可比性，以确定产品和系统的安全功能及相应保证措施的可信级别。</li>
<li>目标读者包括用户、开发者和评估者。</li>
<li>关键概念包括评估对象（TOE）、保护轮廓（PP）、安全目标（ST）、TOE安全策略（TSP）和TOE安全功能（TSF）。</li>
<li>CC核心内容涵盖安全功能要求和安全保证要求，其中安全保证要求定义了七个评估保证级别（EAL1~EAL7）。</li>
</ul>
</li>
<li><strong>中国国内相关标准</strong>:<ul>
<li>GB17859-1999计算机信息系统安全保护系统等级划分准则。</li>
<li>GB/T 18336.1~3-2001信息技术安全性评估准则。</li>
<li>GB/T 20272—2006操作系统安全技术要求。</li>
<li>GA/T 388-2002计算机信息系统安全等级保护操作系统技术要求。</li>
<li>GA/T 390-2002计算机信息系统安全等级保护通用技术要求。</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>TODO: 讨论题作业请放在这里</strong></p>
<p>请阅读GB17859，分组完成以下任务之一（下次课之 前分组讲解）： –（1）可信计算基、引用监控器概念是如何定义的？ –（2）五个可信等级是什么，划分的原则是什么？ –（3）涉及的安全功能主要要求包括哪些？ –（4）区分第二级与第三级安全功能要求的异同之处？ –（5）区分第三级与第四级安全功能要求的异同之处？</p>
</blockquote>
<h2 id="1-4-安全概念和设计思想"><a href="#1-4-安全概念和设计思想" class="headerlink" title="1.4 安全概念和设计思想"></a>1.4 安全概念和设计思想</h2><ul>
<li><p><strong>访问控制思想</strong>: 由B. W. Lampson于1969年首次提出，涉及主体、客体和访问控制矩阵的概念，并抽象化访问控制问题。在一个操作系统中，每一个实体组件都必须或者 是主体，或者是客体，或者既是主体又是客体。</p>
</li>
<li><p><strong>主体与客体</strong>: 在操作系统中，客体是指被动的实体（如文件或进程），而主体是指能够引起信息流动的实体（如用户或进程）</p>
</li>
<li><p><strong>访问控制</strong>：</p>
<ul>
<li>访问控制是系统授予或撤销访问某些数据或执行某些操作的任何机制。通常，用户首先必须使用某种认证系统登录到系统。接下来，访问控制机制通过将用户ID与访问控制数据库进行比较，来控制用户可能或不可能进行的操作。</li>
<li>访问控制系统包括：文件权限，例如在文件服务器上创建、读取、编辑或删除文件的权限。程序权限，例如在应用服务器上执行程序的权限。数据权限，例如在数据库中检索或更新信息的权限。</li>
</ul>
</li>
<li><p><strong>访问控制矩阵</strong>，描述主客体直接控制权限的关系，是一张二维表格，行列分别是主体和客体，表格中的值为主体对于客体拥有的权限。</p>
</li>
<li><p><strong>通用安全需求</strong>: </p>
<ul>
<li>机密性（防止信息泄露）是指不要泄露信息(也包括数 据的存在性)或资源。加密和访问控制机制支持机密性。</li>
<li>完整性（防止未授权修改）是指对数据或资源的可信赖程度，它通 常用于防止不当或未授权的修改。数据的完整性包括：数据的完整性和来源的完整性。访问控制支持完整性。 </li>
<li>可追究性（对数据访问和系统使用行为可追溯性）系统必须保证对数据的访问和 系统能力的使用的个人行为可追究性，并且提供审计它们的方法 。涉及标识、鉴别和审计等。</li>
<li>可用性（信息或资源的使用能力）。是指使用所期望的信息或资源的能 力。安全相关的可用性方面是指有人蓄意造成数据的访问拒绝或使得服务不可用 。</li>
</ul>
</li>
<li><p>安全三要素: 安全策略（Security Policy）-&gt; 应该做什么? ，安全机制（Security Mechanism）-&gt; 如何做? ，安全保证（Security Assurance）-&gt; 效果如何?</p>
</li>
</ul>
<h3 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a>安全策略</h3><ul>
<li><p>类型</p>
<ul>
<li>机密性策略 Confidentiality Policies -&gt; 保密性策略没有对客体设置信任。</li>
<li>完整性策略 Integrity Policies -&gt; 完整性策略表明在多大程度上信任客体。</li>
</ul>
</li>
<li><p>策略语言</p>
<ul>
<li>策略语言是描述安全策略的语言。</li>
<li>策略语言分类：<ul>
<li>高级策略语言：使用抽象的方法来表达对实体的策略约束。</li>
<li>低级策略语言：根据系统中程序的输入或调用选项来表达 约束。</li>
</ul>
</li>
</ul>
</li>
<li><p>安全模型</p>
<ul>
<li><strong>一个安全模型是安全策略的清晰表述</strong>, 具有特点：是精确的、无歧义的。是简单和抽象的，易于理解。只涉及安全性质，不限制系统的功能及其实现。</li>
<li>作用：明确安全性的定义。指导设计和实现。为安全测试提供上下文：使得可以识别对应于安全测试的抽象实体、目标的数据结构和过程。提供论证保障：论证保障就是安全系统正确实施安全策略的证明。</li>
</ul>
</li>
</ul>
<h3 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h3><ul>
<li><p><strong>安全机制是实施安全策略的手段</strong>，它们可以被划分为三大类别：预防、检测、恢复。通常使用的是预防机制。 检测和恢复机制通常涉及长期活动，并且是必要的，因为仅仅依靠预防是不够的。</p>
</li>
<li><p>引用监控器(Reference Monitor): 1972年，J.P. Anderson提出了引用监控器概念，这是一种访问控制概念，指的是一个抽象的机器，它<strong>介入并管理主体对客体的所有访问</strong>。Morri Gasser对引用监控器进行了扩展，将其定义为硬件和软件的结合体，负责强制执行系统的安全策略。</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202312252049036.png" srcset="/img/loading.gif" lazyload alt="image-20231225204927995"></p>
</li>
<li><p><strong>引用验证机制</strong>(Reference Validation Mechanism, 简称<strong>RVM</strong>): 是引用监控器概念的实际应用实现。它必须满足以下三个要求: a. 引用验证机制必须是防篡改的。 b. 引用验证机制必须始终参与到所有访问控制中。 c. 引用验证机制必须足够小，以便于进行测试（如有必要，可以进行彻底的测试）。</p>
</li>
<li><p>安全内核: 安全内核方法的根本：在一个大型操作系统中，由相对小的软件部分负责安全性，且<strong>必须满足对应RVM三个原则</strong>：</p>
<ul>
<li><strong>完整性（Completeness)</strong>: 必须做到无法绕过,  it must be impossible to bypass. </li>
<li><strong>隔离性（Isolation)</strong>: 必须是防篡改的，it must be tamperproof.</li>
<li><strong>可验证性（Verification)</strong>: 必须能够证明其正确实施，it must be shown to be properly implemented.</li>
</ul>
</li>
<li><p>三个基本设计原则：</p>
<ul>
<li><strong>完整性原则</strong>：意味着所有对信息的访问必须通过内核来中介。</li>
<li><strong>隔离性原则</strong>：声明内核必须是防篡改的。</li>
<li><strong>可验证性原则</strong>：<ul>
<li>设计标准：<ul>
<li>使用最新的软件工程技术</li>
<li>强调内核接口功能的简洁性</li>
<li>通过排除与安全无关的功能来最小化内核的大小。</li>
</ul>
</li>
<li>确保技术：<ul>
<li>代码审查</li>
<li>彻底测试</li>
<li>正式的数学规范和验证</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>系统边界与安全周界(System Boundary &amp; Security Perimeter): </p>
<ul>
<li>系统是一个包含了开发者所能控制的全部计算和通信环境的不明确实体。系统内部的一切都由系统保护，而系统外部的一切则无保护，因此，识别系统边界的关键在于准确指定系统与外部世界之间的接口。</li>
<li>系统内部的组件分为两种类型：一种是负责维护系统安全的组件，另一种是其他所有组件。与安全相关的组件实施内部控制。区分这两种类型组件的是一个被称为安全周界的假想边界。</li>
</ul>
</li>
<li><p>可信计算基(Trusted Computing Base, TCB): 包括了所有必须信赖的硬件和软件，以强制执行系统的安全策略。这包括：a. 访问调节的硬件与软件。b. 身份识别和认证（I&amp;A）机制。c. 审计机制。d. 可信软件，即那些不受非可信软件强制执行规则限制的软件。</p>
</li>
<li><p>可信软件与不可信软件：</p>
<ul>
<li>可信软件仅指与安全相关且位于安全周界内的部分，其故障可能对系统的安全产生不利影响。可信软件首先由可信的个体根据严格的标准开发，其次已通过使用形式建模和验证等先进工程技术被证明是正确的。</li>
<li>不可信软件则不与安全相关，位于安全周界之外：它可能是维持系统运行所需的，但它不能违反系统安全。</li>
</ul>
</li>
</ul>
<h3 id="安全保证"><a href="#安全保证" class="headerlink" title="安全保证"></a>安全保证</h3><ul>
<li>安全功能 -&gt; 它提供了哪些保护特性？</li>
<li>安全保证 -&gt; 这些保护特性的可靠性如何？</li>
<li>信任(Role of Trust): <ul>
<li>分析系统的安全性需要：<ul>
<li>理解强制执行安全策略的机制。</li>
<li>了解相关的假设和信任（任何安全策略和机制都是基于特定的假设和信任）。</li>
</ul>
</li>
<li>例如，假设有一个与安全相关的程序S，在操作系统O上进行了形式化证明。那么在安装这个程序时，需要做以下假设：<ul>
<li>S的形式化验证是正确的，即其证明是无误的。</li>
<li>S的形式化证明所做的假设是正确的。</li>
<li>程序必须被转换成可执行文件，且该可执行文件的功能与程序源代码指示的功能一致。</li>
<li>硬件需要按照意图执行程序，例如，避免因芯片缺陷导致的运算错误。</li>
</ul>
</li>
</ul>
</li>
<li>安全体系结构(Security Architecture)<ul>
<li>安全体系结构描述了系统如何组建以满足安全需求。</li>
<li>如果安全需求要求系统必须达到一个<strong>特定的保证级别</strong>以确保安全性控制的正确性，那么安全体系结构<strong>必须规定开发过程中所需的设计原则</strong>。此外，安全体系结构的<strong>指导作用将贯穿于开发过程的每一个步骤</strong>。</li>
</ul>
</li>
</ul>
<h2 id="1-5-TCG可信计算技术介绍-amp"><a href="#1-5-TCG可信计算技术介绍-amp" class="headerlink" title="1.5 TCG可信计算技术介绍&amp;"></a>1.5 TCG可信计算技术介绍&amp;</h2><ul>
<li><p>可信计算概念与需求：</p>
<ul>
<li>安全是指采取技术和管理的安全保护手段，保护软硬件与数据不因偶然的或恶意的原因而遭受到破坏、更改、暴露。</li>
<li>TCSEC：可信计算机系统评估标准 分为A/B/C/D四类七个等级-D,C1,C2,B1,B2,B3,A1。CC：公共准则(ISO/IEC 15408) 分为EAL1, EAL2, EAL3,EAL4,EAL5,EAL6,EAL7</li>
<li>安全保障技术与效果<ul>
<li>攻击者进不去 -&gt; 标识与鉴别</li>
<li>非授权者重要信 息拿不到 -&gt; 访问控制</li>
<li>窃取保密信息看不懂 -&gt; 数据加密</li>
<li>系统和信息 改不了 -&gt; 完整性保护</li>
<li>可用性资源管理+安全管理 -&gt; 系统工作瘫不成</li>
<li>攻击行为赖不掉 -&gt; 安全审计</li>
</ul>
</li>
</ul>
</li>
<li><p>可信计算概念与需求</p>
<ul>
<li>可信 -&gt; 针对某个特定的目的，实体的行为与预期的行为相符，则称针对这个目的， 该实体是可信的。</li>
<li>建立可信计算环境的需求 + 计算机安全攻击所造成的损失 + 正在变化中的计算机安全威胁。(看PPT)</li>
</ul>
</li>
<li><p>可信计算涵义与属性</p>
<ul>
<li>“可信计算”可以从几个方面来理解<ul>
<li>用户的身份认证：这是对使用者的信任</li>
<li>平台软硬件配置的正确性：这体现了使用者对平台运行环境的信任</li>
<li>应用程序的完整性和合法性：这体现了应用程序运行的可信</li>
<li>平台之间的可验证性：指网络环境下平台之间的相互信任。</li>
</ul>
</li>
<li>TCG制定的规范中定义了可信计算的三个属性<ul>
<li>可鉴别：计算机系统的用户可以确定与他们进行通信的对象身份。</li>
<li>完整性：用户确保信息能被正确传输。</li>
<li>私密性：用户相信系统能保证信息的私密性。</li>
</ul>
</li>
</ul>
</li>
<li><p>可信计算的机遇</p>
<ul>
<li>得到产业界支持的、基于标准化: • 提供一个更安全的计算环境 • 保护终端用户数据 • 提供可信的电子商务交易 • 基于硬件的信任</li>
<li>更多的信任: • 增加用户及管理员使用因特网的信心 • 降低商业，特别是关键行业（金融、保险、政府、医疗）的风险 • 在硬件的保护下增加交易量和交易额。</li>
</ul>
</li>
<li><p>TCG</p>
<ul>
<li><p>TCG组织介绍、工作组和一些杂七杂八：Blablabla，建议看PPT…这种不会考吧…</p>
</li>
<li><p>TCG的解决方案: • 将平台转变为可信计算环境 • 使平台能够证明给定的网络环境是一个受保护的环境 • 在正确的平台环境下，秘密才会被释放出来 • 将TPM作为产品中的可信构造块</p>
</li>
<li><p>当前应用: • 带有TPM的PC、Server、IoT设备 • 第三方软件使用TPM提供数据保护、网络访问、标识管理、认证 • 网络产品：Radius认证服务器、病毒保护、策略管理</p>
</li>
<li><p>现有标准规范介绍：安全性原则 私密性原则 可互操作性原则 数据的可移植性原则 可控性原则 易用性原则</p>
</li>
<li><p>现有规范介绍: TCG体系结构规范, TPM主规范, TSS规范, PC客户平台规范, 服务器规范, 移动电话使用场景规范, 基础设施规范, 可信网络连接规范</p>
</li>
<li><p>核心功能介绍: </p>
<ul>
<li>TCG技术的核心内容就是为计算平台提供了一整套基于TPM及平台中TBB（平台可信构造块）的信任建立及可信性证实方法和机制</li>
<li>CRTM（度量的核心信任根）: • 在最初设计可信平台架构时，TCG考虑到平台改造的成本和风险，并没有将CRTM集成到TPM内部，而是通过改造主板上的 Boot ROM 来实现的。 • 在启动的最初阶段，<strong>最先执行的一部分指令就是CRTM，它负责对紧随其后执行的 其他指令进行完整性度量，CRTM是可信度量根。</strong> • 根据信任根的定义，<strong>CRTM必须是平台上的一个受保护的部件，它必须总是按照预期的方式运作，从而能够被无条件信任。</strong></li>
<li>可信平台模块TPM: • 是一个拥有受保护的独立执行能力（密码运算部件)和小容量存储能力的<strong>硬件芯片</strong>。 • <strong>TPM是可信平台的核心，配合CRTM就能够实现完整性的度量和报告</strong>。 • 在可信体系的三个信任根中，TPM<strong>实现</strong>的是<strong>可信报告根RTR</strong>和<strong>可信存储根RTS</strong>的功能。</li>
</ul>
</li>
<li><p>TPM至少需要具备四个主要功能: 对称/非对称加密、安全存储、完整性度量、签名认证。</p>
<ul>
<li>数据的<strong>非对称加密和签名认证</strong>，是通过<strong>RSA算法</strong>来实现的</li>
<li>完整性<strong>度量</strong>则是通过<strong>高效的SHA-1散列算法</strong>来完成的</li>
<li>对称加密可以使用任意算法，既可以使用专用协处理器，也可以使用软件来完成。</li>
</ul>
</li>
<li><p>TPM结构：</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202312252116899.png" srcset="/img/loading.gif" lazyload alt="image-20231225211635845"></p>
<ul>
<li>受保护的功能：是一组命令，只有它们才能访问被屏蔽的位置</li>
<li>被隔离的位置：是内存，寄存器等，满足：a. 在这些位置上操作敏感数据是安全的。b. 访问数据的位置只能是受保护的功能。</li>
</ul>
</li>
</ul>
</li>
<li><p>TPM的核心功能介绍</p>
<ul>
<li><p>PCR平台配置寄存器：作用、允许的操作，密码哈希的性质。</p>
</li>
<li><p>完整性度量、存储、报告机制：目的，度量方式，存储值的存储，完整性报告。</p>
</li>
<li><p>信任链产生：在可信体系中，信任链以可信根（TPM）为起点而建立，在此基础上再将信任关系逐级传递到系统的各个模块，从而建立整个系统的信任关系。所以信任根 必须是一个能够被信任的组件，通常在一个可信平台中有三个可信根：</p>
</li>
<li><p>可信报告根（Root of Trust for Reporting，RTR）：提供密码机制对TPM的状态及信息进行数字签名</p>
</li>
<li><p>可信存储根（Root of Trust for Storage，RTS）：提供密码机制保护保存在TPM之外的信息(数据和密钥)</p>
</li>
<li><p>可信度量根（Root of Trust for Measurement，RTM）：由平台提供的对平台的状态进行度量的机制</p>
</li>
<li><p>信任链产生流程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202312252122955.png" srcset="/img/loading.gif" lazyload alt="image-20231225212226903"></p>
<blockquote>
<p>信任链扩展流程所加载的组件顺序</p>
</blockquote>
</li>
<li><p>完整性报告</p>
</li>
<li><p>远程报告：可信平台使用AIK对当前平台的PCR值 进行签名，报告给远程挑战者，以证明 其平台状态的可信性。 这一过程使用挑战-应答协议完成。</p>
</li>
<li><p>本地报告：借助TPM本身提供的Seal操作（将数据或密钥与一个或一组指定的PCR值绑定，只有当这个或这组PCR值符合特定的指定值时，这些数据和密钥才能够被释放出来）来完成本地的安全报告。</p>
<blockquote>
<p>当挑战者要判断本地机器是否被攻陷，意味着本机有可能是不可信的。那么本机的 验证会被攻击者篡改,挑战者会受到欺骗。</p>
</blockquote>
</li>
<li><p>远程证实: 远程证实协议 -&gt; 远程证实时，一个平台（挑战方）向另个平台（证实方）发送一个挑战证实的消息和一个随机数，要求获得一个或多个PCR值，以便对证实者的平台状态进行验证。</p>
</li>
<li><p>AIK证书的合法性 – EK 和 AIK：背书密钥 EK（Endorsement Key），身份认证密钥 AIKs（Attestation Identity Keys）。Privacy CA、AIK证书的合法性等。</p>
</li>
<li><p>数据保护：可信平台要可信，必须真实的报告系统的状态，同时不能暴露密钥，也要尽量不能暴露自己的身份。数据安全保护是可信平台的核心功能之一：通过密钥对数据采用特定的保护方式：</p>
<ul>
<li>用于数据安全保护的密钥分为对称密钥和非对称密钥</li>
<li>被保护的数据可以是任何数据</li>
<li>数据安全保护方式包括数据加解密、数据封装等方式。</li>
</ul>
</li>
<li><p>受保护的存储结构：存储根密钥(Storage Root Key, SRK) a. 每个可信计算平台只对应一个惟一的SRK,且只保存在TPM中。 b. 在TPM所有者获得TPM所有权时，在TPM中生成SRK。 c. 以SRK为根，可以建立受保存的树状存储结构。</p>
</li>
<li><p>绑定（BINDING）VS 封装（SEAL）</p>
</li>
<li><p>密钥管理: 密钥与数据，存储密钥与签名密钥，密钥是否可迁移、密钥的使用。</p>
</li>
</ul>
</li>
<li><p>可信平台软件架构: 服务提供者接口, 核心软件接口, TPM设备驱动程序接口。</p>
</li>
</ul>
<h1 id="2-安全标准"><a href="#2-安全标准" class="headerlink" title="2. 安全标准"></a>2. 安全标准</h1><h2 id="2-1-硬件安全机制"><a href="#2-1-硬件安全机制" class="headerlink" title="2.1 硬件安全机制"></a>2.1 硬件安全机制</h2><blockquote>
<p>Focus on Security in Hardware and OS.</p>
</blockquote>
<ul>
<li><p>操作系统的安全性表现:  • 物理上分离：要求进程使用不同的物理实体 • 时间上分离：具有不同安全要求进程在不同时间运行 • 逻辑上分离：要求进程不能访问其允许范围外的实体 • 密码上分离：要求进程隐蔽数据及计算</p>
</li>
<li><p>操作系统安全的主要目标: 依据系统安全策略对用户的操作进行访问控制， 防止用户对计算机资源的非法访问(窃取、篡改 和破坏), 标识系统中的用户和进行身份鉴别, 监督系统运行时的安全性, 保证系统自身的安全性和完整性。</p>
</li>
<li><p>必要的安全机制: • 硬件安全机制 • 访问控制机制 – 自主访问控制、安全标记与强制访问控制、客体重用 • 可追究机制 – 标识与鉴别、可信路径、安全审计 • 连续保护机制 – 系统完整性、隐蔽通道分析、最小特权管理、可信恢复</p>
</li>
<li><p>硬件安全机制</p>
<ul>
<li><p>为什么需要硬件安全性: • 认为硬件安全特性在执行时更为可靠和正确。（不会被错误的软件损坏） • 把安全特性设置在硬件中可以形成一个更为简洁的体系结构。 • 硬件允许的工作性能（运行速度）高于软件。</p>
</li>
<li><p>硬件安全目标: • 保证自身的可靠性、同时为系统提供基本安全机制，包括：<strong>存储保护, 运行保护, I/O保护</strong></p>
</li>
<li><p>存储保护</p>
<ul>
<li><p>存储保护的目标 • 单用户（内存一次运行一个进程）系统中 – 应该防止用户程序对操作系统的影响。 • 多道程序运行的系统中 – 需要对进程的存储区域实行互相隔离。</p>
</li>
<li><p>存储器管理机制</p>
<ul>
<li>虚地址空间 – 存储进程的程序与数据的专用地址空间 – 由硬件实现虚 -实地址转换 /映射</li>
<li>请求式页面调度 – 操作系统建立一个作用于整个进程虚拟存储器的页面描述表, 并在描述符中设置一个”ON DISK”标志,以指示那些页面不在 物理存储器中, 此时要求进行中断页处理 (整个进程用一个页表 ) </li>
<li>分段虚拟存储 – 典型二段方案：分为用户空间与系统空间 – 可变长分段与请求页面调度结合 (每个进程的段数不同,每个段 都有一个可变长的页面描述表 )</li>
</ul>
</li>
<li><p>存储器管理的访问控制</p>
<ul>
<li><p>策略：当系统的地址空间分为系统段与用户段时，应禁止在用户模式下运行的非特权进程向系统段进行写操作，而当在系统模式下运行时，则允许进程对所有的虚存空间进行读、写操作</p>
</li>
<li><p>具体机制：物理页附加密钥的方法，基于描述符的地址解释机制</p>
</li>
</ul>
</li>
<li><p>物理页附加密钥的方法：• <strong>每个物理页号都被标以一个称为密钥的秘密信息</strong>；系统只允许<strong>拥有该密钥</strong>的进程访问该物理页，同时<strong>利用一些访问控制信息指明</strong>该页是<strong>可读的还是可写的</strong> 。 • 每个进程相应地分配一个密钥，该密钥由操作系统装入进程的状态字中。 • 每次执行进程访问内存的操作时，<strong>由硬件对该密钥进行检验</strong>， 只有当进程的密钥与内存物理页的密钥相匹配，并且相应的访问控制信息与该物理页的读写模式相匹配时，才允许该程访问该页内存，否则禁止访问。 • <strong>缺点</strong>：进程挂起前后物理页面不同和共享页面会带来开销。</p>
</li>
<li><p>基于描述符的地址解释机制：• 每个进程都有一个“私有的”地址描述符，进程对系统内存某页或某段的访问模式都在该描述符中说明。可以有两类访问模式集，一类用于在用户状态下运行的进程，一类用于在系统模 式下运行的进程。 • W，R，E各占一比特，它们用来指明是否允许进程对内存的某 页或某段进行写、读和运行的访问操作。 • <strong>由于地址解释期间，地址描述符同时也被系统调用检验</strong>，所以这种基于描述符的内存访问控制方法，<strong>在进程转换、运行模式 （系统模式与用户模式）转换以及进程调出 /调入内存等过程中</strong>， 不需要或仅需要<strong>很少的额外开销</strong>。</p>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202312261047656.png" srcset="/img/loading.gif" lazyload alt="image-20231226104755543"></p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>运行保护</p>
<ul>
<li><p>背景知识</p>
<ul>
<li>一种计算机硬件要运行Unix/Linux系统，至少需要提 供两种运行模式：高优先级的内核模式和低优先级的 用户模式。实际上许多计算机都有两种以上的执行模 式。如：intel 80x86体系结构就有四层执行特权。</li>
<li>采取不同的执行模式是为了保护。由于用户进程在较低的特权级上运行，它们将不能意外或故意的破坏其 它进程或内核；程序造成的破坏会被局部化而不影响 系统中其它活动或者进程。当用户进程需要完成特权模式下才能完成的某些功能时，必须严格按照系统调用提供的接口才能进入特权模式运行受限的功能。</li>
</ul>
</li>
<li><p>UNIX/Linux系统层次结构</p>
<ul>
<li>一个Unix/Linux系统分为三个层次：用户、核心以及硬件。 其中系统调用是用户程序与核心间的边界，通过系统调 用进程可由用户模式转入内核模式，在内核下完成一定 的服务请求后再返回用户模式。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/alexanderliu-creator/blog_img/img/202312261056181.png" srcset="/img/loading.gif" lazyload alt="image-20231226105639135"></p>
</li>
<li><p>基于保护环的等级域机制</p>
<ul>
<li>执行域 – 涉及内容为：执行方式、状态以及范围。 – 域是分层的。</li>
<li>保护环： – 分层图的图形像一组同心的环。 – 环的编号越小，特权越高。</li>
<li>安全概念： – 保护每一环免遭其他环的影响，并允许每层环有效地控制该环及更低特权环上的应用程序。</li>
</ul>
</li>
<li><p>进程隔离机制</p>
<ul>
<li>给定一个进程，它可以在任意时刻在任何一个环内运行，在运行期间还可以从一个环转移到另一个环。</li>
<li><strong>当一个进程在某个环内运行时，进程隔离机制将保护该进程免遭在同一环内同时运行的其它进程破坏。</strong></li>
</ul>
</li>
<li><p>多域结构的保护机制</p>
<ul>
<li>依据： – 如果环 n对某一段具有一个给定的访问模式，那么 所有0—n-1的环都具有这种访问模式。</li>
<li>硬件保护机制 – 对于每种访问模式，仅需要在该描述符中指出具有该访问模式的最大环号，而不用为每个环都保存相应的访问模式信息。 – 对于一个给定的内存段，仅需 3个区域（Ｒ，Ｗ， Ｅ三种访问模式），在这 3个区域中只要保存具有该访问模式的最大环号即可。</li>
</ul>
</li>
<li><p>Ring bracket，环界: </p>
<ul>
<li>我们称R1，R2，R3环号为环界，分别表示对该段可以进行写W、读R、运行 E操作的环界，而且满足： R1≤R2≤R3。例如：在某个段描述符中，环界集（4， 5，7）表示0环到4环可对该段进行写 操作；0环到5环对该段可进行读操作； 0环到7环可运行该段内的代码。</li>
<li>如果某环内的某 一进程对内存某段具有写操作的特权， 那就不必限制其对该段的读与运行操作特权。如果进程对某段具有读操作的特权，那当然允许其运行该段的内容。</li>
<li>环界方法的安全性：不允许低特权环内编写（或者修改）的程序在 高特权环内运行。对于一个给定的段，为每个进程分配一个相应的环 界集，不同的进程对该段的环界可能是不同的。存在的问题：这种方法只能隐含，但不能明确限定同一环内两个进程对共享段设立不同的访问模式。</li>
<li>解决方法：将段的环界集定义为系统属性，仅当一个进程在环界集限定的环内运行且相应的访问模式位是 ON，那么才允许该进程对该段进行相应的访问操作。在同一环内运行的两个进程共享某个段，且欲使一个进程只 对该段进行读访问，而另一个进程仅对该段进行写访问时，只要按 需设置两个进程相应的访问模式信息即可，环界集相同。</li>
</ul>
</li>
</ul>
</li>
<li><p>I/O保护</p>
<ul>
<li>从访问控制角度看，一个进程发出的I/O指令主要涉及的部分。</li>
<li>I/O硬件保护机制。</li>
</ul>
</li>
</ul>
<h2 id="2-2-自主访问控制机制"><a href="#2-2-自主访问控制机制" class="headerlink" title="2.2 自主访问控制机制*"></a>2.2 自主访问控制机制*</h2><blockquote>
<p>Focus on DAC</p>
</blockquote>
<ul>
<li>计算机系统安全机制的主要目的是访问控制，自主访问控制机制(DAC, Discretionary Access Control): 授权：确定哪些主体有权访问哪些客体，确定访问权限，实施访问权限。</li>
<li>DAC – 概念：文件的拥有者可以按照自己的意愿精确指定 系统中的其他用户对其文件的访问权。定义！</li>
<li>“自主”的体现</li>
<li>DAC分类：基于行的访问控制矩阵信息：连接可访问客体到指定用户。基于列的访问控制矩阵信息：连接用户列表到指定的客体。<ul>
<li>基于行的自主存取控制机制：在每个主体上都附加一 个该主体可访问的客体的明细表，根据表中信息的不同可分成三种形式: 能力表、前缀表和口令。</li>
<li>基于列的自主存取控制机制：在每个客体上都附加一个主体明细表，表 示存取控制矩阵。表中的每一项都包括主体的身份和主体对该客体的访问权限。</li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>TODO: 讨论题作业请放在这里</strong></p>
<p>【Q1】：你了解Linux内核“主体”的数据结构吗?其中uid、euid、 suid、fsuid各自的含义和用途是什么？与标识和鉴别机制的关系</p>
<p>【Q2】：你了解Linux内核“客体”(如文件、目录、特殊文件、设 备、IPC客体-消息队列+共享内存+信号量、信号等)的数据结构吗? 如果要为这些客体打安全标签（如安全级），应该如何添加？</p>
<p>【Q3】：Linux的“块设备”与“字符设备”区别是什么，相关的数 据结构如何？举例说明。 </p>
<p>【Q4】: 你了解Linux2.6系统中与DAC相关的命令吗？如熟悉chmod, chown, setfacl, chfacl等命令的使用吗? </p>
<p>【Q5】：你能在Linux2.6以上内核中找出客体（如文件/目录）相关 的DAC数据结构吗（传统9Bit模式、ACL模式）？ </p>
<p>【Q6】: 你了解Linux的SETUID机制吗？chmod命令中的特殊权限位 的S_ISUID, S_ISGID,S_ISVTX(STICKY位）是什么含义？</p>
</blockquote>
<h2 id="2-3-强制访问控制机制"><a href="#2-3-强制访问控制机制" class="headerlink" title="2.3 强制访问控制机制"></a>2.3 强制访问控制机制</h2><blockquote>
<p>MAC, Mandatory Access Control. BLP，不可上读，不可下写。</p>
</blockquote>
<ul>
<li><p>特洛伊木马（Trojan horses）威胁</p>
</li>
<li><p>DAC &amp; Trojan Horse: DAC hold不住，在DAC控制下并没有办法防止木马通过共享客 体(shared objects)-比如文件、消息和共享内存等，把消 息从一个进程传给另一个进程。</p>
</li>
<li><p>引入了不可绕过的（直接或间接地）访问限制。</p>
</li>
<li><p>MAC &amp; Trojan horses</p>
<ul>
<li>MAC可以阻止一些Trojan horses攻击，主要体现在：<ul>
<li>为每个主体(subjects)和客体(objects)赋予安全属性 (security attributes),这些属性不像自主访问控制属性那样可以随意改变。</li>
<li>系统通过比较主体和客体的安全属性来决定该主体能 否以期望的方式访问该客体。反之，如果系统判定拥有某一安全属性的主体不能访问某个客体，那么任何人（包括客体的拥有者）也不能使它访问该客体。从这种意义上讲，是“强制”的。</li>
<li>以某个用户身份运行的进程不能改变该用户本身及该用户所拥有客体的安全属性，所以简单地通过允许其他用 户来访问一个文件不会泄露文件的内容。</li>
<li>可以阻止进程创建共享文件，避免利用这些共享文件将敏感信息传递给另一个进程。</li>
</ul>
</li>
</ul>
</li>
<li><p>多级安全思想</p>
<ul>
<li>多级安全的思想起源：多级安全系统的主要目标是实施强制机密性安全策略,确 保信息不会被无意泄露。</li>
<li>多级安全与军事安全策略，保密级别。</li>
<li>支配关系，安全级的表示形式通常为：一个保密级别后随一个范畴集（可包含一个或多个范畴）。</li>
<li>两个安全级之间存在的支配关系，两个安全级A和B之间的支配关系。包含多种。</li>
</ul>
</li>
<li><p>多级安全规则与BLP模型</p>
<ul>
<li><p>Simple Security Property，即：简单安全属性</p>
</li>
<li><p>Property or confinement property，即：属性</p>
</li>
<li><p>BLP的不可上读(No Read Up, NRU)和不可下写 (No Write Down, NWD)：</p>
<ul>
<li><p>这个原则阻止较低安全级别的主体（如用户或进程）读取较高安全级别的数据。其目的是防止敏感信息泄露给未经授权的用户。</p>
<p><strong>例子</strong>: 假设有三个安全级别：公开、机密和绝密。根据BLP模型，一个只有机密级别访问权限的用户不能读取绝密级别的数据。这意味着，如果一份文件被标记为绝密，那么那些只有机密或公开级别访问权限的用户就无法读取这份文件。</p>
</li>
<li><p>这个原则阻止较高安全级别的主体写入较低安全级别的对象。这样做是为了防止敏感信息通过较低安全级别的数据流向下泄露。</p>
<p><strong>例子</strong>: 继续上面的例子，一个有绝密级别访问权限的用户不能将信息写入机密或公开级别的文件中。例如，如果一个用户正在处理绝密文件，他们不能将这些信息复制或移动到只有机密或公开级别的文件中，因为这样会使得较低级别的用户能够访问到本应更高级别保护的数据。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>强制访问控制(MAC)机制举例</p>
<ul>
<li>安全级的标识和赋值<ul>
<li>安全级的标识与安全级数据库</li>
<li>主体的安全级</li>
<li>客体的安全级</li>
<li>设备的安全级</li>
</ul>
</li>
<li>MAC规则的具体实施<ul>
<li>实施的强制存取控制规则</li>
<li>客体为文件、特殊文件、目录时。客体为进程时。客体为消息队列、信号量集合、共享存储区、管道时。</li>
</ul>
</li>
<li>如何防止Trojan horses<ul>
<li>场景1：在多级安全系统中，*–特性能阻止正在机密 安全级上运行的进程中的特洛伊木马把机密信息写入 一个公开的文件里。</li>
<li>场景2: 一个公司对系统中自己拥有的信息指定一个强制存取范畴c，只有该公司的雇员才可能进入这个范畴c。如果它的一个雇员使用了特洛伊木马，他不可能将该公司的信息传递到c范畴以外的地方去，但在范畴c内部，信息可以在各个用户之间自由传递。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-4-客体重用机制"><a href="#2-4-客体重用机制" class="headerlink" title="2.4 客体重用机制"></a>2.4 客体重用机制</h2><ul>
<li>客体重用<ul>
<li>定义：包含一个或多个客体的存储介质(例如，页面，磁盘扇区， 磁带)的主体的重新分配。</li>
<li>残留数据又称残留信息：是指数据在被以某种形式擦除后所残留的物理表现。</li>
</ul>
</li>
<li>标准要求: TCSEC（C2-A1)和GB17859(第二级<del>第五级）的要求, CC和GB/T18336—2001(EAL 2</del>EAL 7)。</li>
<li>硬盘、软盘、可擦写光盘的物理盘块空间</li>
<li>内存页面：“内存物理页面”和“盘上物理页面”</li>
<li>高速缓存：Linux内核在运行中常常会需要使用一些页高速缓存区，由于这些页高速缓存空间的释放和再分配，也可能会泄露其以前曾经被存放的信息。</li>
</ul>
<h2 id="2-5-标识与鉴别"><a href="#2-5-标识与鉴别" class="headerlink" title="2.5 标识与鉴别"></a>2.5 标识与鉴别</h2><ul>
<li>可追踪机制（ACCOUNTABLE MECHANISMS）</li>
<li>之一：标识与鉴别（Identification &amp; Authentication）<ul>
<li>基本概念：<ul>
<li>标识</li>
<li>鉴别</li>
</ul>
</li>
<li>标识机制：<ul>
<li>uid/gid</li>
<li>主体/进程</li>
<li>FreeBSD</li>
<li>chown</li>
</ul>
</li>
<li>与鉴别有关的认证机制<ul>
<li>TCB（可信计算基）要做很多工作。</li>
</ul>
</li>
</ul>
</li>
<li>几个技术要点：• 对口令内部存储的访问控制和加密处理 • 口令从终端到认证机传输过程中的保护 • 登陆尝试次数的限制 • 用户安全属性的检查，比如用户进程的安全 级、计算特权集、审计屏蔽码等。 • 审计处理，对口令的使用和更改进行审计； 及时通知系统管理员、通知用户等。</li>
<li>口令质量测试</li>
</ul>
<h2 id="2-6-可信路径机制"><a href="#2-6-可信路径机制" class="headerlink" title="2.6 可信路径机制"></a>2.6 可信路径机制</h2><ul>
<li>可追踪机制(ACCOUNTABLE MECHANISMS)</li>
<li>之二：可信路径(Trusted Path)<ul>
<li>用户必须确定是与真实的安全 内核通信</li>
<li>一种用于保障用户和真实的内核通信的机制 就 是可信路径（或可信通路）</li>
</ul>
</li>
<li>Requirements in TCSEC</li>
<li>Approaches for trusted path<ul>
<li>方法一：给每个用户两台终端，一台做通常的工作，一台用作与内核的硬连接。缺点：这种办法虽然十分简 单，但太昂贵了。</li>
<li>方法二：对用户建立可信路径的一种现实方法是使用通用终端，通过发信号给核心。这个信号是不可信软件不能拦截、覆盖或伪造的。 一般称这个信号为“安全注意键”, Secure Attention Key 。 – 缺点：目前大多数终端十分智能，内核要使该机制不被特洛伊木马欺骗十分困难。</li>
<li>安全注意键（SAK）机制的实现方法，激活方式等</li>
</ul>
</li>
</ul>
<h2 id="2-7-安全审计机制"><a href="#2-7-安全审计机制" class="headerlink" title="2.7 安全审计机制"></a>2.7 安全审计机制</h2><ul>
<li>可追踪机制(ACCOUNTABLE MECHANISMS)</li>
<li>之三：安全审计(Security Audit)<ul>
<li>概念、目的、意义</li>
<li>Audit Assurance，为了确保审计员能够获得真实的和有价值的信 息，以作出正确的判断和及时的决策。</li>
<li>Audit Events，审计事件，是系统审计用户操作的最基本单位。</li>
<li>What events to be audited? 审计事件可分为主体审计事件和客体审计事件两 大类，主体，客体。</li>
<li>审计事件标准</li>
<li>主体审计事件</li>
<li>客体审计事件</li>
<li>事件筛选机制</li>
<li>审计保护</li>
<li>演示实例</li>
<li>An Example for Audit：审计点、审计过程、审计方法、审计必要机制。</li>
</ul>
</li>
</ul>
<h2 id="2-8-最小特权管理"><a href="#2-8-最小特权管理" class="headerlink" title="2.8 最小特权管理"></a>2.8 最小特权管理</h2><blockquote>
<p>把权限拆细，最小特权原则！</p>
</blockquote>
<ul>
<li>之一：最小特权管理（Least Privilege Management）<ul>
<li>What is the Privilege in an OS</li>
<li>操作系统中超越DAC和MAC检查的特权</li>
<li>Basic Idea<ul>
<li>最小特权管理的思想是系统不应给用户超过执 行任务所需特权以外的特权</li>
</ul>
</li>
<li>Problems in Privilege Management</li>
<li>Examples to enforce Privilege Management</li>
<li>进程和程序文件的权能状态定义，权能遗传算法。</li>
<li>用户初始进程的特权状态：由于用户通过会话（如：login）成为系统的主体进程，所以要在此过程中根据用户属性 (比如: 角色 )为初始的主体设置恰当的权能状态。</li>
</ul>
</li>
</ul>
<h2 id="2-9-隐蔽通道分析与标识-amp"><a href="#2-9-隐蔽通道分析与标识-amp" class="headerlink" title="2.9 隐蔽通道分析与标识&amp;"></a>2.9 隐蔽通道分析与标识&amp;</h2><ul>
<li>之二：隐蔽通道分析与标识(Covert Channel Analysis and Identification)<ul>
<li>定义：如果一个通信信道既不是设计用于通信的，也不是有意用于传递信息的，则称该通信信道是隐蔽的。</li>
<li>在实施了强制访问控制的多级安全操作系统中，特洛伊木马只有利用隐蔽 通道才能将信息传送给低安全级进程 (木马主人）。</li>
<li>隐蔽通道与完整性策略有关<ul>
<li>隐蔽通道的概念除了与保护信息流的安全策略有关之外，与系统的完整性策略也有关系。<ul>
<li>在实现强制安全策略（比如BLP安全策略）的系统中，隐蔽通道分析要确保能找出所有从特定安全级到低安全级或者不可比安全级的非法泄密路径。</li>
<li>在实现强制完整性策略（比如Biba）的系统中，隐蔽通道分析要确保能找出所有从特定完整级到低完整级，或者不可比完整级的非法泄密路径。</li>
</ul>
</li>
</ul>
</li>
<li>隐蔽通道分类<ul>
<li>隐蔽存储通道Storage Channel</li>
<li>隐蔽定时通道Timing Channel</li>
</ul>
</li>
<li>噪音通道和无噪通道：无噪通道指的是发送者发送的信号与接收者接收的信号百分之百相同。</li>
<li>无害通道与有害通道。</li>
<li>国内外安全产品评估标准对隐蔽通道分析的要求：TCSEC (橘皮书)，我国的GB17859。</li>
<li>国内外安全产品评估标准 对隐蔽通道分析的要求。</li>
<li>隐蔽通道分析的基本工作流程。</li>
<li>隐蔽存储通道的判别标准、隐蔽定时通道的判别标准。</li>
</ul>
</li>
<li>Identification of Covert Channels<ul>
<li>隐蔽通道分析的层次性</li>
<li>橘皮书建议采用的分析资源</li>
<li>源代码级分析的优点</li>
<li>隐蔽通道的经典标识方法评价</li>
<li>主要方法<ul>
<li>Shared Resource Matrix: 优点：是目前唯一一种可以分析DTLS的方法。缺点：分析代码非常困难。（闭包！大题！）</li>
</ul>
</li>
<li>传递闭包</li>
<li>SRM方法分析</li>
<li>Covert Flow Tree &amp; Covert Flow Graph</li>
<li>结合语义分析的Tsai信息流分析</li>
<li>Formal method by Tsai, Tsai方法的主要缺点</li>
</ul>
</li>
<li>隐蔽通道的带宽计算技术<ul>
<li>影响带宽计算的因素</li>
<li>国外主要带宽计算技术</li>
</ul>
</li>
<li>隐蔽通道的处理技术<ul>
<li>常用处理技术</li>
<li>隐蔽通道处理技术选择因素</li>
<li>隐蔽通道的处理技术实例</li>
<li>隐蔽通道场景实例分析<ul>
<li>已标识隐蔽存储通道场景-1: 进程标识符信道</li>
<li>已标识隐蔽存储通道场景 2: 最近访问时间信道</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="2-A-系统完整性保护"><a href="#2-A-系统完整性保护" class="headerlink" title="2.A 系统完整性保护"></a>2.A 系统完整性保护</h2><ul>
<li>之三：系统完整性保护(System Integrity)<ul>
<li>完整性要求: 系统完整性（System Integrity）通常使用完整性敏感标 记来确信信息在传送中未受损。完整性保护要求包括三种类型： a,存储数据的完整性；b,传输数据的完整性；c,处理数据的完整 性。</li>
<li>存储数据的完整性：存储数据的完整性检测，存储数据的完整性检测和恢复。</li>
<li>传输数据的完整性：数据交换完整性检测，源数据交换恢复，目的数据交换恢复</li>
<li>处理数据的完整性：基本回退，高级回退</li>
</ul>
</li>
</ul>
<h2 id="2-B-可信恢复机制"><a href="#2-B-可信恢复机制" class="headerlink" title="2.B 可信恢复机制"></a>2.B 可信恢复机制</h2><ul>
<li>之四：可信恢复机制(Trusted Recovery)<ul>
<li>可信恢复<ul>
<li>TCB提供的过程和机制</li>
<li>不减弱保护的情况下启动TCB</li>
</ul>
</li>
<li>可信恢复要求<ul>
<li>手动恢复</li>
<li>自动恢复</li>
<li>无过分丢失的自动恢复</li>
<li>功能恢复</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="3-安全模型"><a href="#3-安全模型" class="headerlink" title="3. 安全模型"></a>3. 安全模型</h1><h2 id="3-1-安全模型开发方法"><a href="#3-1-安全模型开发方法" class="headerlink" title="3.1 安全模型开发方法"></a>3.1 安全模型开发方法</h2><ul>
<li><p>安全策略vs.安全模型(Security Policy vs. Security Model)</p>
<ul>
<li><p>What properties do the security policy really care about? 机密性、完整性、可用性</p>
</li>
<li><p>Security Policy and Security Mechanism: 安全机制是实施安全策略的某些部分的实体（entity) 或规程(procedure)。</p>
</li>
<li><p>Why need security model? 安全策略通常是隐含定义而不是明确定义的，安全模型是安全策略的清晰表述。</p>
</li>
</ul>
</li>
<li><p>Objectives of Developing A Formal Security Model</p>
</li>
<li><p>Basic Demands for Developing A Formal Security Model</p>
</li>
<li><p>State-Machine and Development of Security Models</p>
</li>
<li><p>What is State-Machine? -&gt; 状态变量表示机器的状态，转换函数或者操作规则用以描述状态变量的变化过程。</p>
</li>
<li><p>Why State-Machine is suite for the Description of Security Models?</p>
</li>
<li><p>How to develop a state-machine security model?</p>
<ol>
<li>定义安全相关的<strong>状态变量</strong>。</li>
<li>定义<strong>安全状态</strong>的条件，这个定义是一个不变式， 它表达了在状态转换期间状态变量的数值所必须始终保持的关系。</li>
<li><strong>定义状态转换函数</strong>。这些函数描述了状态变量可能发生 的变化，也称为操作规则，因为它们的意图是限制系统可能 产生的变化的类型。</li>
<li><strong>检验函数是否维持了安全状态</strong>。要求：如果系统在运行 之前处于安全状态，那么系统在运行之后仍将保持在安全状 态。</li>
<li><strong>定义初始状态</strong>，选择每个状态变量的值。</li>
<li>依据安全状态的定义，<strong>证明初始状态安全</strong>。</li>
</ol>
</li>
<li><p>How to prove the security of a state-machine security model?</p>
<ul>
<li>用严格的数学推导来证明系统从一个安全状态 出发，并且无论调用哪个函数系统都将保持在安全状态。</li>
<li>证明初始状态是安全的，证明所有的函数都是安全状态。</li>
</ul>
</li>
</ul>
<h2 id="3-2-BLP机密性安全模型"><a href="#3-2-BLP机密性安全模型" class="headerlink" title="3.2 BLP机密性安全模型"></a>3.2 BLP机密性安全模型</h2><ul>
<li>典型安全模型介绍(Typical Security Models)</li>
<li>经典BLP模型<ul>
<li>简介</li>
<li>BLP模型形式化地定义了系统状态及状态转换间的转换规则， 并制定了一组约束系统状态间转换规则的安全公理。</li>
<li>模型的安全策略：自主安全策略，强制安全策略。</li>
</ul>
</li>
<li>系统状态表示：描述状态机所有的状态，描述状态之间的转换，安全公理。</li>
<li>模型的几个重要定理。BLP模型为了证明系统为安全状态及转换规则保持安全状态，证明了10个重要的定理。</li>
<li>BLP模型的不足，TMach对BLP的改进，Fluke Microkernel的改进，RSBAC的改进。</li>
</ul>
<h2 id="3-3-BIBA完整性安全模型"><a href="#3-3-BIBA完整性安全模型" class="headerlink" title="3.3 BIBA完整性安全模型"></a>3.3 BIBA完整性安全模型</h2><ul>
<li>Integrity Models<ul>
<li>完整性概念比机密性概念更模糊，更依赖于上下文。完整性威胁可能是意外的(accidental)或恶意的(malicious)。</li>
<li>Commercial Concerns<ul>
<li>完整性比机密性显得更加重要。</li>
</ul>
</li>
<li>Principles of Operation: 三个操作原则，通常，商用安全性控制是自主的、过程的和分散的。 信息的分类也是一个很大的问题。</li>
</ul>
</li>
<li>Biba Integrity Model<ul>
<li>它基本是BLP模型的对偶，不同 的只是它对系统中的每个主体和客体均分配一 个完整性级别（integrity level）。</li>
<li>Information transfer path: 对一个客体的不可靠信息流破坏或毁坏了 该客体的完整性。这个不可靠的信息可能来自一个更低 完整性级别的主体或者一个更低完整性级别的客体。三种访问模式。</li>
</ul>
</li>
<li>Low-Water-Mark Policy on Subjects<ul>
<li>一些策略</li>
<li>Problems of LWM: 主体在对某些持有较低或不相容的完整级别的客体 执行“observe”操作后，会降低自身的完整级别，有可能减少主体可存取的客体集，使某些原来对主体说来是可以存取的客体在执行“observe”操作后 变成不可存取的</li>
<li>Other LWM Policies</li>
</ul>
</li>
<li>Ring Policy<ul>
<li>一些策略</li>
<li>Problems of Ring Policy：由于“observe”存取是非受限的，仍 可能发生不恰当的“modify”操作。为了避免这种情况，主体在使用来自低完整 级别客体的数据时要十分小心。</li>
</ul>
</li>
<li>Strict Integrity Policy<ul>
<li>No Read-Down</li>
<li>No Write-Up</li>
<li>严格完整策略防止信息从低完整性级别客体向 更高或不可比完整性级别客体传递，保证信息 流仅是“observe”和“modify” 的结果。</li>
</ul>
</li>
<li>Biba vs. BLP<ul>
<li>具有简单性。</li>
<li>Biba和BLP模型相结合的可能性。</li>
</ul>
</li>
<li>Biba模型的不足<ul>
<li>完整标签的确定很困难</li>
<li>在有效保护数据一致性方面不完备</li>
<li>不同性质的范畴在同时满足机密性和完整性目标方面难以配合使用</li>
</ul>
</li>
</ul>
<h2 id="3-4-Chinese-Wall混合安全模型-amp"><a href="#3-4-Chinese-Wall混合安全模型-amp" class="headerlink" title="3.4 Chinese Wall混合安全模型&amp;"></a>3.4 Chinese Wall混合安全模型&amp;</h2><ul>
<li><p>Chinese Wall Model</p>
<ul>
<li>概述</li>
<li>Organization</li>
<li>Definitions</li>
<li>Temporal Element</li>
<li>CW-Simple Security Condition</li>
<li>Sanitization</li>
<li>Writing</li>
<li>CW-*-Property</li>
<li>Compare to Bell-LaPadul</li>
</ul>
</li>
<li><p>根据中国墙模型思想，假定公司A、公司B同属于一个利益冲突类P；公司X、公司Y同属于另一个利益冲突类Q，试 问： （1）假定用户Alice读取过公司A的数据和公司X的数据， 用户Bob读取过公司A的数据和公司Y的数据，那么接下来， 用户Alice能否写公司A的数据？为什么？请说明理由。 （2） 假定用户Alice读取过公司A的数据，以及公司X已经清洗过(sanitized)的数据，用户Bob读取过公司A的数据和公司Y的数据，那么接下来，用户Alice能否读取公司Y的数据？ 为什么？请说明理由。</p>
</li>
</ul>
<blockquote>
<p>根据中国墙模型的安全策略，我们可以对您的问题进行分析。中国墙模型是一种动态的访问控制策略，用于防止冲突利益和信息流的不当传递。它通常应用于金融、法律和信息服务行业。</p>
<p>在中国墙模型中，数据被分为不同的利益冲突类（Conflict of Interest Class）。如果一个用户访问了某一利益冲突类中的信息，那么他就不能访问其他利益冲突类中的信息。这是为了避免信息交叉导致的潜在冲突。</p>
<p>针对您的问题：</p>
<ol>
<li><strong>关于Alice写公司A的数据</strong>：<ul>
<li>Alice已经读取了公司A（属于利益冲突类P）和公司X（属于利益冲突类Q）的数据。</li>
<li>根据中国墙模型，Alice可以继续访问她已经访问过的利益冲突类（即类P和类Q）中的数据。</li>
<li>因此，Alice能够写公司A的数据，因为公司A属于她已经访问过的类P。</li>
</ul>
</li>
<li><strong>关于Alice读取公司Y的数据</strong>：<ul>
<li>Alice读取了公司A的数据（属于类P）和公司X经过清洗的数据。</li>
<li>清洗过的数据通常意味着去除了可能引起利益冲突的敏感信息。</li>
<li>如果公司X清洗过的数据不再被视为属于冲突利益类Q的一部分，那么Alice访问这些数据不会违反中国墙模型的规定。</li>
<li>在这种情况下，Alice理论上可以访问公司Y的数据，因为她没有直接从属于类Q的源数据中获取信息。</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="3-5-1-基于属性访问控制技术研究-amp"><a href="#3-5-1-基于属性访问控制技术研究-amp" class="headerlink" title="3.5.1 基于属性访问控制技术研究&amp;"></a>3.5.1 基于属性访问控制技术研究&amp;</h2><ul>
<li>访问控制是公认的确保数据安全共享的重要手段之一，访问控制技术根据预先设定的访问控制策略，保障资源只能被合法用户执行合法操作，防止了信息的非授权访问。</li>
<li>基于属性访问控制定义：基于属性的访问控制（Attribute Based Access Control， ABAC）：一种访问控制方法，主体对客体执行操作的请求被授 予或拒绝是基于主体所分配的属性，客体所分配的属性，环境 条件以及一组根据这些属性和条件来规定的策略。</li>
<li>基于属性访问控制定义，基于属性访问控制定义。</li>
<li>优点</li>
<li>属性访问控制研究点</li>
<li>ABAC系统分为两个阶段：准备阶段和执行阶段<ul>
<li>准备阶段：主要负责收集构建访问控制系统所需的属性集合以及对访 问控制策略进行描述。</li>
<li>执行阶段：主要负责对访问请求的响应及对访问策略的更新。</li>
</ul>
</li>
</ul>
<blockquote>
<p>实体<strong>属性发现</strong>是ABAC研究中的基础，自动化的策略挖掘方法是需要解决的重要问题。</p>
<p>自动化的<strong>策略挖掘方法</strong>是需要解决的重要问题</p>
<p>设计复杂度较低且具有丰富表达能力的<strong>访问控制描述语言</strong>才能保证ABAC系统高效准确运行</p>
</blockquote>
<ul>
<li><p>基于属性访问控制研究</p>
<ul>
<li>通过以上ABAC研究点的阐述，ABAC研究主要分为ABAC模 型，策略以及属性三类</li>
<li>纯ABAC模型</li>
<li>ABAC的混合模型</li>
<li>ABAC通用模型研究</li>
<li>ABAC特定领域模型研究</li>
<li>ABAC混合模型研究</li>
</ul>
</li>
<li><p>基于属性访问策略研究</p>
<ul>
<li>ABAC策略描述语言研究</li>
<li>ABAC策略挖掘研究</li>
<li>ABAC策融合冲突研究</li>
<li>ABAC属性发现研究</li>
<li>ABAC属性安全研究</li>
</ul>
</li>
</ul>
<h2 id="3-5-2-RBAC中立安全模型-amp"><a href="#3-5-2-RBAC中立安全模型-amp" class="headerlink" title="3.5.2 RBAC中立安全模型&amp;"></a>3.5.2 RBAC中立安全模型&amp;</h2><ul>
<li><p>Role-Based Access Control, RBAC</p>
<ul>
<li><p>RBAC概述</p>
</li>
<li><p>RBAC的优点</p>
</li>
<li><p>基本概念及原理</p>
</li>
<li><p>模型的基本性质</p>
</li>
</ul>
</li>
<li><p>Some issues in RBAC</p>
</li>
</ul>
<h2 id="3-6-DTE中立安全模型-amp"><a href="#3-6-DTE中立安全模型-amp" class="headerlink" title="3.6 DTE中立安全模型&amp;"></a>3.6 DTE中立安全模型&amp;</h2><ul>
<li>Domain and Type Enforcement, DTE<ul>
<li>TE/DTE 概述</li>
<li>DTE策略描述</li>
<li>DTE Implementation</li>
<li>DTE 的特点</li>
</ul>
</li>
</ul>
<h1 id="4-安全体系结构"><a href="#4-安全体系结构" class="headerlink" title="4. 安全体系结构"></a>4. 安全体系结构</h1><h2 id="4-1-安全体系结构概述"><a href="#4-1-安全体系结构概述" class="headerlink" title="4.1 安全体系结构概述"></a>4.1 安全体系结构概述</h2><ul>
<li>安全体系结构的含义及类型<ul>
<li>体系结构的主要任务：建立一个计算机系统往往需要满足多种要求，比如：安 全性要求、性能要求、可扩展性要求、容量要求、使用 方便性要求和成本要求等。全局性地折衷考虑，这就是体系结构要完成的主要任务。</li>
<li>安全体系结构的定义：安全体系结构描述的是一个系统如何组织 成一个整体以满足既定的安全性要求。</li>
<li>安全体系结构组成。</li>
<li>安全体系结构作用。</li>
<li>Multiple Architectural Views<ul>
<li>Abstract View，抽象体系</li>
<li>Generic View，通用体系</li>
<li>Logical View，逻辑体系</li>
<li>Specific View，特殊体系</li>
</ul>
</li>
</ul>
</li>
<li>安全体系结构的设计原则：七个基本设计原则<ul>
<li>Consider Security from the Start</li>
<li>Anticipate Future Security Requirements</li>
<li>Minimize and Isolate Security Controls</li>
<li>Enforce Least Privilege</li>
<li>Structure the Security-relevant Functions</li>
<li>Make Security Friendly</li>
<li>Do not Depend on Secrecy for Security</li>
</ul>
</li>
</ul>
<h2 id="4-2-GFAC与FLASK安全体系结构"><a href="#4-2-GFAC与FLASK安全体系结构" class="headerlink" title="4.2 GFAC与FLASK安全体系结构"></a>4.2 GFAC与FLASK安全体系结构</h2><ul>
<li>广义存取控制框架(GFAC，General Framework for Access Control)<ul>
<li>To Support Multiple Policies</li>
<li>GFAC概述</li>
<li>GFAC定义的三个概念: 权威(Authorities), 安全属性(Attributes), 规则(Rules)</li>
<li>GFAC基本结构: AEF(Access control Enforcement Facility), ADF(Access control Decision Facility)</li>
</ul>
</li>
<li>GFAC分析<ul>
<li>优缺点</li>
</ul>
</li>
<li>FLASK, FLux Advanced Security Kernel<ul>
<li>FLASK安全体系结构概述</li>
<li>FLASK Architecture</li>
<li>FLASK体系结构基本组成</li>
</ul>
</li>
<li>Object Manager(客体管理器)<ul>
<li>客体管理器OM基本组成</li>
<li>Object Labeling客体标记决策</li>
<li>Requesting and Caching Security Decisions 请求和缓存安全决策</li>
<li>Polyinstantiation Support 支持多实例化</li>
<li>Revocation Support Mechanisms 支持吊销机制</li>
<li>A revocation of microkernel permissions</li>
<li>Fluke API的两个性质</li>
</ul>
</li>
<li>Security Server(安全服务器)<ul>
<li>SS基本功能</li>
<li>SS的强制性</li>
<li>SS中的安全策略管理</li>
</ul>
</li>
</ul>
<h2 id="4-3-LSM安全框架"><a href="#4-3-LSM安全框架" class="headerlink" title="4.3 LSM安全框架"></a>4.3 LSM安全框架</h2><ul>
<li>支持FLASK的LSM框架(Linux Security Module), </li>
<li>LSM的实施<ul>
<li>关键数据结构的修改</li>
<li>钩函数的调用</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意: LSM只提供对钩函数的调用，具体钩函数的完善需要各安全模块完成。</p>
</blockquote>
<ul>
<li>安全系统调用</li>
<li>安全模块管理</li>
<li>相当于加了一层Proxy，由于Proxy过于“中心化”，也可能会导致一些其他的问题。</li>
</ul>
<h1 id="5-安全系统开发方法"><a href="#5-安全系统开发方法" class="headerlink" title="5. 安全系统开发方法"></a>5. 安全系统开发方法</h1><h2 id="5-1-安全系统的开发方法"><a href="#5-1-安全系统的开发方法" class="headerlink" title="5.1 安全系统的开发方法"></a>5.1 安全系统的开发方法</h2><ul>
<li>安全系统设计原则<ul>
<li>特点</li>
<li>机制的经济性(Economy of mechanism)</li>
<li>基于“许可”的安全(Fail-safe defaults)</li>
<li>完全的访问仲裁(Complete mediation)</li>
<li>开放型系统设计(Open design)</li>
<li>权限分离(Separation of privilege)</li>
<li>最小特权(Least privilege)</li>
<li>公共机制的最小化(Least common mechanism)</li>
<li>用户友好(Psychological acceptability)</li>
</ul>
</li>
<li>安全操作系统的开发方法(Kernel Implementation Strategies)<ul>
<li>安全内核与传统操作系统设计比较<ul>
<li>设计安全内核要用到常规的操作系统的设计概念。</li>
<li>不同的是，在设计安全内要优先考虑三个原则。完整性、隔离性、可验证性。</li>
</ul>
</li>
<li>安全内核的开发方法。</li>
<li>早期的开发方法。</li>
<li>改进/增强法分析，优缺点。</li>
<li>Identical Operating System (Virtual Machine)<ul>
<li>虚拟机法：在现有操作系统与硬件之间增加一个新的分层， 作为安全内核，操作系统几乎不变地作为虚拟机。</li>
<li>优缺点</li>
</ul>
</li>
<li>Compatible Operating System (Emulation)<ul>
<li>仿真法：对现有操作系统的内核做面向安全策略的修改，然后在安全内核与原ISOS用户接口界面中间再 编写一层仿真程序。</li>
<li>优缺点</li>
</ul>
</li>
<li>New Operating System<ul>
<li>新建法：包括面向安全策略的安全内核在内，重新设计整个操作系统</li>
<li>优缺点</li>
</ul>
</li>
</ul>
</li>
<li>开发过程模型(Development Model)<ul>
<li>CC提供的评估对象开发模型</li>
</ul>
</li>
</ul>
<h1 id="6-操作系统与虚拟化安全实现-amp"><a href="#6-操作系统与虚拟化安全实现-amp" class="headerlink" title="6. 操作系统与虚拟化安全实现&amp;"></a>6. 操作系统与虚拟化安全实现&amp;</h1><h2 id="6-1-操作系统安全实践"><a href="#6-1-操作系统安全实践" class="headerlink" title="6.1 操作系统安全实践"></a>6.1 操作系统安全实践</h2><ul>
<li>安胜OS系统设计<ul>
<li>设计目标-v3.0</li>
<li>设计目标-v4.0</li>
</ul>
</li>
<li>系统总体结构</li>
<li>关键技术实现</li>
<li>多策略安全模型的建立<ul>
<li>多级机密性安全模型（DMLR_MLS）</li>
<li>完整性保护模型(DTE_IPM)</li>
<li>最小特权控制模型(PCM_RBPC)</li>
</ul>
</li>
<li>支持多策略的安全体系结构/框架<ul>
<li>策略实施</li>
<li>策略重用</li>
<li>策略共存</li>
</ul>
</li>
</ul>
<blockquote>
<p>针对支持FLASK体系结构的LSM框架无法灵活支持“策略重用”和“策略 共存”的问题，提出了一种支持多策略的、由”策略等价、策略冲突和策 略协作”组成的安全体系结构。</p>
</blockquote>
<ul>
<li>安胜OS多策略组合器的决策算法</li>
<li>功能描述与半形式化规范</li>
<li>安全机制的设计和实现<ul>
<li>用户标识与鉴别</li>
<li>自主访问控制</li>
</ul>
</li>
<li>实现的技术要点</li>
<li>安全机制的设计和实现<ul>
<li>强制完整性访问控制</li>
<li>强制机密性访问控制</li>
<li>最小特权控制</li>
<li>隐蔽通道分析</li>
<li>密码服务</li>
</ul>
</li>
</ul>
<h2 id="6-2-系统虚拟化平台安全实践"><a href="#6-2-系统虚拟化平台安全实践" class="headerlink" title="6.2 系统虚拟化平台安全实践"></a>6.2 系统虚拟化平台安全实践</h2><ul>
<li>系统虚拟化平台安全性分析<ul>
<li>安全机制的实现</li>
<li>安全机制的漏洞</li>
</ul>
</li>
<li>虚拟机监控器安全体系结构<ul>
<li>XSM<ul>
<li>适用于Xen的通用安全框架</li>
</ul>
</li>
<li>框架接口目标</li>
<li>XSM的合理性</li>
</ul>
</li>
<li>新的使用模型<ul>
<li>用于分解Dom0</li>
<li>用于划分资源</li>
<li>用于保护平台免受第三方软件攻击</li>
<li>用于保护平台核心的安全服务</li>
</ul>
</li>
<li>XSM安全的好处<ul>
<li>安全功能的封装</li>
<li>安全功能的扩展</li>
</ul>
</li>
<li>XSM的实现<ul>
<li>安全功能</li>
<li>安全模块</li>
</ul>
</li>
<li>XSM特有实现</li>
<li>XSM的模块管理</li>
<li>已实现的XSM模块</li>
<li>XSM钩子<ul>
<li>做什么</li>
<li>钩子放置方法</li>
<li>目前的钩子位置</li>
</ul>
</li>
<li>性能分析</li>
<li>ACM 模块</li>
<li>Hooks函数</li>
<li>ACM STE策略</li>
<li>ACM 中国墙策略</li>
<li>Flask 模块 -&gt; Flask 如何使用XSM</li>
<li>虚拟机安全迁移机制<ul>
<li>虚拟机迁移的好处</li>
<li>动态迁移技术</li>
<li>虚拟机动态迁移方法</li>
<li>基于可信第三方的安全迁移协议实例</li>
<li>vTPM实例在硬件平台之间的安全迁移协议实例</li>
</ul>
</li>
<li>虚拟机安全监控技术<ul>
<li>概述</li>
<li>VMI技术</li>
<li>VMWare VMSafe安全框架</li>
<li>XenAccess 安全API</li>
</ul>
</li>
<li>虚拟机之间的隐蔽通道分析<ul>
<li>概述</li>
<li>虚拟化平台上的隐蔽通道类型<ul>
<li>XenCC－基于对mfn2pfn映射表读写的隐蔽存储通道</li>
<li>基于CPU负载的隐蔽通道</li>
<li>基于共享内存的定时隐蔽通道</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="6-3-虚拟可信平台技术"><a href="#6-3-虚拟可信平台技术" class="headerlink" title="6.3 虚拟可信平台技术"></a>6.3 虚拟可信平台技术</h2><ul>
<li><p>主要内容</p>
<ul>
<li>可信计算技术概述</li>
<li>虚拟可信平台架构</li>
<li>TCG VPWG工作组</li>
<li>虚拟可信平台关键技术</li>
</ul>
</li>
<li><p>可信计算</p>
<ul>
<li>概念</li>
<li>可信平台模块TPM</li>
<li>TPM提供受保护的功能和被隔离的位置</li>
</ul>
</li>
<li><p>可信计算平台</p>
<ul>
<li>构成</li>
<li>通过TPM硬件对软件层次的攻击进行保护，可以使用户获 得更强的保护能力</li>
<li>TPM不仅能在各种终端系统中建立可信链，还能将可信链扩展到网络中</li>
</ul>
</li>
<li><p>完整性度量架构IMA: 该模块度量每一个加载的应用程序，运行 库以及内核模块。</p>
</li>
<li><p>可信软件栈</p>
<ul>
<li>TPM设备驱动程序(TDD)</li>
<li>TPM设备驱动库(TDDL)</li>
<li>TSS核心服务(TCS)</li>
<li>与TSS服务提供者(TSP)</li>
</ul>
</li>
<li><p>虚拟可信平台架构</p>
<ul>
<li>TPM虚拟化</li>
<li>vTPM的实现结构</li>
</ul>
</li>
<li><p>为了保持TPM安全属性，设计虚拟化TPM必须解决以下四个问题。</p>
</li>
<li><p>开源软件资源，基于开源软件的虚拟可信平台架构</p>
</li>
<li><p>TCG VPWG工作组</p>
</li>
<li><p>虚拟可信平台关键技术</p>
<ul>
<li>关键技术之一 信任链扩展</li>
<li>关键技术之二 远程(递归)证实</li>
<li>关键技术之三 迁移授权与vTPM迁移</li>
</ul>
</li>
</ul>
<h2 id="6-4-Linux安全增强实践扩展"><a href="#6-4-Linux安全增强实践扩展" class="headerlink" title="6.4 Linux安全增强实践扩展"></a>6.4 Linux安全增强实践扩展</h2><ul>
<li>主要内容<ul>
<li>eBPF机制<ul>
<li>演进</li>
<li>工作原理</li>
<li>eBPF和Linux内核模块的区别</li>
<li>eBPF的局限性</li>
</ul>
</li>
<li>seccomp机制<ul>
<li>seccomp的引入背景</li>
<li>机制工作原理</li>
<li>内核实现</li>
</ul>
</li>
<li>namespace机制<ul>
<li>namespace机制的引入背景</li>
<li>namespace类型</li>
<li>namespace生命周期</li>
<li>namespace实例</li>
<li>内核实现</li>
</ul>
</li>
<li>cgroup机制<ul>
<li>Cgroup机制的引入背景</li>
<li>cgroup控制资源分配的实例</li>
</ul>
</li>
</ul>
</li>
</ul>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/PKU/" class="category-chain-item">PKU</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E7%A0%94%E4%B8%80%E8%AF%BE%E7%A8%8B/">#研一课程</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>PKU-操作系统与虚拟化安全</div>
      <div>https://alexanderliu-creator.github.io/2023/12/25/pku-cao-zuo-xi-tong-yu-xu-ni-hua-an-quan/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Alexander Liu</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年12月25日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/01/25/stable-diffusion-and-comfyui-tutorial/" title="Stable Diffusion and ComfyUI Tutorial">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Stable Diffusion and ComfyUI Tutorial</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/12/07/tsinghua-openbmb-nlp/" title="Tsinghua OpenBMB NLP">
                        <span class="hidden-mobile">Tsinghua OpenBMB NLP</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  





  <script>
  Fluid.utils.createScript('https://lib.baomitu.com/mermaid/8.14.0/mermaid.min.js', function() {
    mermaid.initialize({"theme":"default"});

    Fluid.events.registerRefreshCallback(function() {
      if ('mermaid' in window) {
        mermaid.init();
      }
    });
  });
</script>






    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
